---
title: "Klasterisasi Warna Foto"
subtitle: "Manipulasi Foto dengan Klasterisasi K-Rerata"
description: "Bagaimana mengurangi variasi warna dalam sebuah foto? Salah satu caranya adalah dengan menerapkan klasterisasi k-rerata. Dengan metode ini, foto tersebut akan tersusun hanya dalam k warna. Ide dasar dan cara detailnya dijelaskan dalam artikel ini."
draft: true
author:
  - name: Yosep Dwi Kristanto
    url: https://people.usd.ac.id/~ydkristanto/
    affiliation: Pendidikan Matematika, Universitas Sanata Dharma, Yogyakarta
    affiliation-url: https://www.usd.ac.id/s1pmat
    orcid: 0000-0003-1446-0422
date: 2025-10-01
categories:
  - klasterisasi
  - tutorial
  - fotografi
image: "sampul-klasterisasi-warna.png"
image-alt: "Gambar yang menunjukkan sebuah foto asli dan hasil pereduksian warnanya dengan menggunakan klasterisasi k-rerata"
keywords: 
  - fotografi
  - klasterisasi
  - klasterisasi k-rerata
  - machine learning
  - pemelajaran mesin
  - pemelajaran statistik
  - statistical learning
lightbox: true
copyright: "© 2025 Yosep Dwi Kristanto"
license: "CC BY"
code-annotations: select
editor_options: 
  chunk_output_type: console
---

Apa yang kamu lihat dari sebuah foto? Mungkin kamu melihat kenangan yang tersimpan. Mungkin kamu juga ingin menggali pesan yang tersirat. Oke, mari kita melihat sebuah foto atau gambar dari sudut pandang yang berbeda! Kita dapat melihat sebuah gambar sebagai matriks.

![Meme seseorang yang menatap selembar kertas mungil secara intens](aset/epsilon_terlalu_kecil-01.png){#fig-meme-epsilon fig-alt="Meme orang yang menatap selembar kertas mungil secara intens"}

Perhatikan @fig-meme-epsilon! Apa yang dilihat oleh orang dalam meme pada @fig-meme-epsilon? Karena terlalu kecil, mari kita memperbesarnya dan menaruhnya ke bidang koordinat Kartesius. Kita lakukan hal itu dengan [pemrograman R](https://www.R-project.org/ "R: A Language and Environment for Statistical Computing"){.external target="_blank"}. Untuk itu, kita panggil paket-paket yang kita perlukan seperti pada @lst-muat-paket.

```{r}
#| lst-label: lst-muat-paket
#| lst-cap: "Memuat paket-paket yang diperlukan"
#| code-fold: show
#| message: false
#| warning: false

library(magick)
library(tidyverse)
library(scatterplot3d)
library(scales)
library(cowplot)

```

Paket-paketnya telah siap. Kita lanjut memperbesar gambar yang dilihat oleh orang dalam meme tersebut dan memposisikannya dalam bidang koordinat Kartesius. Perhatikan @fig-matriks-epsilon!

```{r}
#| echo: false
#| label: fig-matriks-epsilon
#| fig-cap: "Gambar epsilon berukuran 8 piksel × 8 piksel pada bidang koordinat Kartesius"

# Memuat dan mengatur skala
gambar_epsilon <- image_read(
  path = "aset/epsilon_kecil.png"
) |> 
  image_scale("8x8!")

# Mengekstrak data piksel mentah
epsilon_mentah <- image_data(gambar_epsilon)

# Dimensi gambar
lebar_gambar  <- dim(epsilon_mentah)[2]
tinggi_gambar <- dim(epsilon_mentah)[3]

# Mengkonversi ke data frame
rgb_epsilon_df <- as.data.frame.table(epsilon_mentah, responseName = "nilai") |>
  mutate(
    kanal = as.integer(Var1),
    koord_x = as.integer(Var2),
    koord_y = as.integer(Var3),
    nilai   = as.integer(nilai)
  ) |>
  select(kanal, koord_x, koord_y, nilai) |>
  pivot_wider(
    names_from = kanal,
    values_from = nilai,
    names_prefix = "ch"
  ) |>
  transmute(
    koord_x,
    koord_y,
    R = ch1,
    G = ch2,
    B = ch3,
    R_norm = R / 255,
    G_norm = G / 255,
    B_norm = B / 255
  )

# Membalik koordinat y
rgb_epsilon_terbalik_df <- rgb_epsilon_df |> 
  mutate(
    koord_y = tinggi_gambar - koord_y + 1
  )

# Plot gambar
rgb_epsilon_terbalik_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = rgb(R_norm, G_norm, B_norm))
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal()

```

Sekarang, apa yang kamu amati dari @fig-matriks-epsilon? Ternyata itu adalah simbol epsilon. Meskipun tampak kabur, piksel-piksel epsilon tersebut tampak jelas. Setiap piksel berkorespondensi dengan satu warna. Warna tersebut dapat dinyatakan ke dalam tiga warna dasarnya, yaitu RGB (*red*, *green*, dan *blue*). Dengan demikian, kita dapat menyatakan gambar tersebut sebagai tiga matriks warna dasar: $R$, $G$, dan $B$.

```{r}
#| echo: false

R_matriks <- rgb_epsilon_df |> 
  select(koord_x, koord_y, R) |> 
  pivot_wider(
    names_from = koord_x,
    values_from = R
  ) |> 
  arrange(koord_y)
G_matriks <- rgb_epsilon_df |> 
  select(koord_x, koord_y, G) |> 
  pivot_wider(
    names_from = koord_x,
    values_from = G
  ) |> 
  arrange(koord_y)
B_matriks <- rgb_epsilon_df |> 
  select(koord_x, koord_y, B) |> 
  pivot_wider(
    names_from = koord_x,
    values_from = B
  ) |> 
  arrange(koord_y)

R_matriks <- as.matrix(R_matriks[,-1])
G_matriks <- as.matrix(G_matriks[,-1])
B_matriks <- as.matrix(B_matriks[,-1])

print("Matriks R")
R_matriks
print("Matriks G")
G_matriks
print("Matriks B")
B_matriks

```

*Okay*, kita telah dapat melihat sebuah gambar dengan menggunakan matriks-matriks $R$, $G$, dan $B$. Kita dapat memasangkan nilai-nilai yang bersesuaian dari matriks tersebut sebagai triplet. Misalnya, komponen pada baris pertama dan kolom pertama dalam matriks-matriks $R$, $G$, dan $B$, secara berturut-turut adalah 171, 200, dan 209. Dengan demikian, kita mendapatkan satu triplet $\left( 171,200,209 \right)$. Dengan cara ini, kita juga dapat membuat 63 triplet lainnya.

Sekarang kita memiliki 64 triplet. Semua triplet yang merepresentasikan warna tersebut dapat kita plot dalam ruang dimensi tiga. Hasilnya ditunjukkan pada @fig-ruang-warna-epsilon.

```{r}
#| echo: false
#| label: fig-ruang-warna-epsilon
#| fig-cap: "Titik-titik dalam ruang yang merepresentasikan warna dalam gambar epsilon"
#| fig-asp: 0.5625

warna_df <- rgb_epsilon_df |> 
  mutate(
    warna_hex = rgb(R_norm, G_norm, B_norm)
  )

scatterplot3d(
  x = warna_df$R,
  y = warna_df$G,
  z = warna_df$B,
  color = warna_df$warna_hex,
  pch = 16,
  cex.symbols = 1,
  xlab = "R",
  ylab = "G",
  zlab = "B"
)

```

Nah, sekarang kita dapat melihat sebuah gambar atau foto dengan menggunakan matriks, yaitu tiga matriks warna dasarnya. Dari tiga matriks tersebut, kita dapat mengkonstruksi titik-titik yang merepresentasikan warna tersebut ke dalam ruang dimensi tiga. Kita gunakan perspektif seperti ini untuk memanipulasi sebuah foto sehingga variasi warnanya tereduksi. Tujuan kita berikutnya adalah untuk membuat foto @fig-karuna-donau-asli menjadi @fig-karuna-donau-4-warna. Hal ini telah dijanjikan pada [pos sebelumnya](/pos/2025-09-klasterisasi-k-rerata/index.qmd "Klasterisasi K-Rerata: Langkah Demi Langkah Klasterisasi dengan Pemrograman R").

::: {#fig-foto-asli-dan-hasil-klasterisasi layout-ncol="2"}
![Foto asli](aset/karuna_donau_tile.png){#fig-karuna-donau-asli}

![Hasil reduksi menjadi empat warna](aset/karuna_donau_4_warna.png){#fig-karuna-donau-4-warna}

Foto asli dan hasil reduksinya menjadi 4 warna
:::

Bagaimana cara mencapai tujuan tersebut? Mari kita bahas gambaran umumnya terlebih dahulu pada bagian berikutnya.

## Ide Dasar {#sec-ide-dasar}

Untuk menyerhanakan warna foto pada @fig-karuna-donau-asli, kita gunakan perspektif yang telah dibahas pada bagian sebelumnya. Setelah itu, kita terapkan klasterisasi $k$-rerata terhadap titik-titik warna yang dihasilkan. Secara umum, tahapan-tahapan utama yang nanti kita lakukan adalah sebagai berikut.

-   Mengekstrak data warna R, G, dan B dari foto.

-   Klasterisasi $k$-rerata terhadap data warna.

-   Mengganti setiap warna pada foto asli dengan pusat klasternya.

Dengan cara seperti itu, kita akan mendapatkan sebuah foto yang hanya memuat $k$ warna. Warna-warna itu diperoleh dari pusat klaster-klaster yang terbentuk. Tak perlu berlama-lama, mari kita mulai tahapan pertamanya.

## Mengekstrak Data Warna {#sec-mengekstrak-data-warna}

Tahapan pertamanya adalah mengestrak data warna dari sebuah foto. Foto awal yang kita gunakan adalah foto pada @fig-karuna-donau-asli. Untuk melakukannya, kita gunakan kode pada @lst-ekstrak-warna.

```{r}
#| lst-label: lst-ekstrak-warna
#| lst-cap: "Membuat data warna dari foto"
#| code-fold: show

# Memuat dan menskala gambar
foto_ku <- image_read(
  "aset/karuna_donau.png"
) |> 
  image_scale("256x256!")

# Ekstrak data mentah piksel
data_mentah_foto <- image_data(foto_ku)

# Ukuran foto
lebar_foto  <- dim(data_mentah_foto)[2]
tinggi_foto <- dim(data_mentah_foto)[3]

# Konversi ke data frame dan membalik koordinat y
rgb_foto_df <- as.data.frame.table(data_mentah_foto, responseName = "nilai") |>
  mutate(
    kanal = as.integer(Var1),
    koord_x = as.integer(Var2),
    koord_y = as.integer(Var3),
    nilai   = as.integer(nilai)
  ) |>
  select(kanal, koord_x, koord_y, nilai) |>
  pivot_wider(
    names_from = kanal,
    values_from = nilai,
    names_prefix = "ch"
  ) |>
  transmute(
    koord_x,
    koord_y = tinggi_foto - koord_y + 1,
    R = ch1,
    G = ch2,
    B = ch3,
    R_norm = R / 255,
    G_norm = G / 255,
    B_norm = B / 255,
    warna_hex = rgb(R_norm, G_norm, B_norm)
  )
 head(rgb_foto_df)
 
```

Dari kode di atas, kita mendapatkan data warna `rgb_foto_df`. Data tersebut memuat koordinat piksel-pikselnya (`koord_x` dan `koord_y`), warna dasar setiap pikselnya (`R`, `G`, dan `B`), dan warna-warna dasar tersebut yang telah diskala agar minimumnya 0 dan maksimumnya 1 (`R_norm`, `G_norm`, dan `B_norm`). Selain itu, kita juga membuat kolom `warna_hex` untuk merangkum informasi warna pada kolom-kolom `R`, `G`, dan `B`.

Mari kita selami `rgb_foto_df` lebih mendalam. Untuk itu, kita gambarkan diagram pencar untuk variabel-variabel warnanya, yaitu `R`, `G`, dan `B`. Perhatikan @fig-ruang-warna-foto!

```{r}
#| echo: false
#| label: fig-ruang-warna-foto
#| fig-cap: "Titik-titik dalam ruang yang merepresentasikan warna dalam foto"
#| fig-asp: 0.5625

scatterplot3d(
  x = rgb_foto_df$R,
  y = rgb_foto_df$G,
  z = rgb_foto_df$B,
  color = rgb_foto_df$warna_hex,
  pch = 16,
  cex.symbols = 1,
  xlab = "R",
  ylab = "G",
  zlab = "B"
)

```

## Klasterisasi $K$-Rerata {#sec-klasterisasi-k-rerata}

Selanjutnya, kita lakukan klasterisasi terhadap `rgb_foto_df` dengan menggunakan variabel-variabel `R_norm`, `G_norm`, dan `B_norm`. Untuk melakukannya, kita menggunakan fungsi `kmeans()`. Fungsi ini menggunakan input sebuah matriks. Oleh karena itu, terlebih dahulu kita membuat matriks tersebut. Matriks tersebut memuat tiga kolom, yaitu `R_norm`, `G_norm`, dan `B_norm`. Perhatikan @lst-matriks-foto!

```{r}
#| lst-label: lst-matriks-foto
#| lst-cap: "Membuat matriks"
#| code-fold: show

matriks_foto <- rgb_foto_df |> 
  select(R_norm, G_norm, B_norm) |> 
  as.matrix()

```

Kita telah memperoleh `matriks_foto`. Kita siap untuk melakukan klasterisasi $k$-rerata dengan fungsi `kmeans()`. Perhatikan @lst-kmeans-foto.

```{r}
#| lst-label: lst-kmeans-foto
#| lst-cap: "Klasterisasi k-rerata terhadap `matriks_foto`"
#| code-fold: show

set.seed(123)

# Pilih nilai k
k <- 4

# Lakukan klasterisasi k-rerata
hasil_krerata <- kmeans(
  x = matriks_foto,
  centers = k
)

```

Hasil klasterisasi tersebut kita simpan sebagai sebuah objek dengan nama `hasil_krerata`. Terdapat informasi penting yang terkandung dalam `hasil_krerata`, yaitu `cluster` (klaster) dan `centers` (pusat setiap klaster). Kedua informasi tersebut berguna untuk mengidentifikasi klaster-klaster warnanya dan menyederhanakan warna-warnanya dengan pusat klasternya.

Sekarang, kita membuat `rgb_foto_klaster_df` yang memuat informasi klaster dan pusatnya tersebut dalam kolom-kolom `klaster` dan `pusat_hex`. Perhatikan @lst-menyisipkan-klaster. Untuk melihat beberapa baris awalnya, kita terapkan `head()` pada data tersebut.

```{r}
#| lst-label: lst-menyisipkan-klaster
#| lst-cap: "Membuat data yang memuat informasi klaster dan warna pusat klaster"
#| code-fold: show

rgb_foto_klaster_df <- rgb_foto_df |> 
  mutate(
    klaster = hasil_krerata$cluster,
    pusat_R = hasil_krerata$centers[klaster, "R_norm"],
    pusat_G = hasil_krerata$centers[klaster, "G_norm"],
    pusat_B = hasil_krerata$centers[klaster, "B_norm"]
  ) |> 
  mutate(
    pusat_hex = rgb(pusat_R, pusat_G, pusat_B)
  ) |> 
  select(koord_x, koord_y, R, G, B, warna_hex, klaster, pusat_hex)

head(rgb_foto_klaster_df)

```

Dari data yang telah kita buat di atas, kita dapat memvisualisasikan warna-warna yang masuk ke dalam setiap klasternya. Perhatikan @fig-heatmap-klaster-warna!

```{r}
#| echo: false
#| label: fig-heatmap-klaster-warna
#| fig-cap: "Klaster dan warna-warna anggotanya"
#| fig-subcap: 
#|   - "Klaster 1"
#|   - "Klaster 2"
#|   - "Klaster 3"
#|   - "Klaster 4"
#| layout-ncol: 2

plot_cluster_heatmap <- function(
    df, cluster_col, color_col, centroid_col, id
) {
  # Capture column names
  cluster_col <- enquo(cluster_col)
  color_col   <- enquo(color_col)
  centroid_col <- enquo(centroid_col)
  
  # Filter for chosen cluster
  df_cluster <- df %>% filter(!!cluster_col == id)
  
  if (nrow(df_cluster) == 0) {
    stop("No rows found for cluster id = ", id)
  }
  
  # Extract colors + centroid
  colors <- df_cluster %>% pull(!!color_col)
  centroid <- df_cluster %>% pull(!!centroid_col) %>% unique()
  
  # Convert to LAB
  rgb_vals <- t(col2rgb(colors)) / 255
  lab_vals <- convertColor(rgb_vals, from = "sRGB", to = "Lab", scale.in = 1)
  
  # Convert centroid
  centroid_rgb <- t(col2rgb(centroid)) / 255
  centroid_lab <- convertColor(centroid_rgb, from = "sRGB", to = "Lab", scale.in = 1)
  
  # Distances
  distances <- apply(lab_vals, 1, function(x) sqrt(sum((x - centroid_lab)^2)))
  
  dfc <- data.frame(color = colors, dist = distances) %>%
    arrange(dist)
  
  # Force centroid as true center
  dfc$color[1] <- centroid
  
  # Grid size
  n <- ceiling(sqrt(nrow(dfc)))
  total <- n^2
  
  # Pad if not full square
  if (nrow(dfc) < total) {
    dfc <- dfc %>% add_row(color = rep(NA, total - nrow(dfc)), dist = Inf)
  }
  
  # Spiral coordinates
  center <- ceiling(n/2)
  coords <- expand.grid(x = 1:n, y = 1:n)
  spiral_order <- order((coords$x - center)^2 + (coords$y - center)^2,
                        atan2(coords$y - center, coords$x - center))
  coords <- coords[spiral_order, ]
  
  dfc <- bind_cols(dfc, coords)
  
  # Plot
  ggplot(dfc, aes(x, y, fill = color)) +
    geom_tile(color = "white") +
    scale_fill_identity(na.value = "grey90") +
    coord_equal() +
    theme_void()
}

plot_cluster_heatmap(rgb_foto_klaster_df, klaster, warna_hex, pusat_hex, 1)
plot_cluster_heatmap(rgb_foto_klaster_df, klaster, warna_hex, pusat_hex, 2)
plot_cluster_heatmap(rgb_foto_klaster_df, klaster, warna_hex, pusat_hex, 3)
plot_cluster_heatmap(rgb_foto_klaster_df, klaster, warna_hex, pusat_hex, 4)

```

## Menyederhanakan Warna {#sec-menyederhanakan-warna}

Tiba saatnya kita menyederhanakan warna. Caranya adalah dengan mengganti setiap warna dengan pusat klasternya. Mari kita lihat kembali `rgb_foto_klaster_df`. Data ini hanya memuat $k=4$ warna, seperti yang ditunjukkan pada luaran @lst-melihat-ringkasan berikut.

```{r}
#| lst-label: lst-melihat-ringkasan
#| lst-cap: "Melihat warna pusat klaster unik dan banyaknya"
#| code-fold: show

rgb_foto_klaster_df |> 
  group_by(pusat_hex) |> 
  summarise(
    n = n()
  )

```

Kita dapat melihat kembali titik-titik warnanya ke dalam ruang dimensi tiga agar dapat mengamati hasil klasterisasi warnanya. Perhatikan @fig-ruang-warna-klaster-foto!

```{r}
#| echo: false
#| label: fig-ruang-warna-klaster-foto
#| fig-cap: "Titik-titik dalam ruang yang merepresentasikan warna dalam foto setelah klasterisasi"
#| fig-asp: 0.5625

scatterplot3d(
  x = rgb_foto_klaster_df$R,
  y = rgb_foto_klaster_df$G,
  z = rgb_foto_klaster_df$B,
  color = rgb_foto_klaster_df$pusat_hex,
  pch = 16,
  cex.symbols = 1,
  xlab = "R",
  ylab = "G",
  zlab = "B"
)

```

Sekarang, kita gambarkan kembali piksel-piksel dalam `rgb_foto_klaster_df` pada bidang koordinat Kartesius dengan kode pada @lst-klasterisasi-4-warna-foto. Hasilnya ditunjukkan pada @fig-foto-warna-klaster.

```{r}
#| label: fig-foto-warna-klaster
#| lst-label: lst-klasterisasi-4-warna-foto
#| lst-cap: "Memplot piksel-piksel foto dengan pereduksian warna"
#| code-fold: show
#| fig-cap: "Penyederhanaan foto asli yang awalnya memiliki hampir 40 ribu warna menjadi $k=4$."

rgb_foto_klaster_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = pusat_hex)
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  )

```

Sampai di sini kita telah berhasil mereduksi variasi warna dari sebuah foto. Teknik yang telah kita lakukan tersebut tentu juga dapat diterapkan dengan $k$ yang berbeda. Misalnya, kita juga dapat melakukannya dengan $k$ = 16 dan 2. Hasilnya disajikan pada @fig-foto-asli-klaster-16-4-2.

```{r}
#| label: fig-foto-asli-klaster-16-4-2
#| fig-cap: "Perbandingan foto asli dan hasil reduksi warnanya dengan klasterisasi k-rerata"
#| fig-subcap: 
#|   - "Foto asli"
#|   - "Klasterisasi dengan k = 16"
#|   - "Klasterisasi dengan k = 4"
#|   - "Klasterisasi dengan k = 2"
#| echo: false
#| layout-ncol: 2

# Klasterisasi
hasil_krerata2 <- kmeans(
  x = matriks_foto,
  centers = 2
)

hasil_krerata16 <- kmeans(
  x = matriks_foto,
  centers = 16
)

# Menyiapkan data
rgb_3_klaster_df <- rgb_foto_df |> 
  mutate(
    klaster4 = hasil_krerata$cluster,
    pusat_R = hasil_krerata$centers[klaster4, "R_norm"],
    pusat_G = hasil_krerata$centers[klaster4, "G_norm"],
    pusat_B = hasil_krerata$centers[klaster4, "B_norm"]
  ) |> 
  mutate(
    pusat_hex4 = rgb(pusat_R, pusat_G, pusat_B)
  ) |> 
  select(koord_x, koord_y, R, G, B, klaster4, pusat_hex4) |> 
  mutate(
    klaster2 = hasil_krerata2$cluster,
    pusat_R = hasil_krerata2$centers[klaster2, "R_norm"],
    pusat_G = hasil_krerata2$centers[klaster2, "G_norm"],
    pusat_B = hasil_krerata2$centers[klaster2, "B_norm"]
  ) |> 
  mutate(
    pusat_hex2 = rgb(pusat_R, pusat_G, pusat_B)
  ) |> 
  select(-pusat_R, -pusat_G, -pusat_B) |> 
  mutate(
    klaster16 = hasil_krerata16$cluster,
    pusat_R = hasil_krerata16$centers[klaster16, "R_norm"],
    pusat_G = hasil_krerata16$centers[klaster16, "G_norm"],
    pusat_B = hasil_krerata16$centers[klaster16, "B_norm"]
  ) |> 
  mutate(
    pusat_hex16 = rgb(pusat_R, pusat_G, pusat_B)
  ) |> 
  select(-pusat_R, -pusat_G, -pusat_B)

# Plot foto
p1 <- rgb_foto_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = warna_hex)
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  ) + 
  labs(
    title = "Foto asli"
  )

p2 <- rgb_3_klaster_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = pusat_hex16)
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  ) + 
  labs(
    title = "Klasterisasi warna (k = 16)"
  )

p3 <- rgb_3_klaster_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = pusat_hex4)
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  ) + 
  labs(
    title = "Klasterisasi warna (k = 4)"
  )

p4 <- rgb_3_klaster_df |> 
  ggplot(
    aes(x = koord_x, y = koord_y, fill = pusat_hex2)
  ) +
  geom_tile() +
  scale_fill_identity() +
  coord_equal() +
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  ) + 
  labs(
    title = "Klasterisasi warna (k = 2)"
  )

p1
p2
p3
p4

```

Mungkin kamu penasaran bagaimana komposisi warna dalam foto yang variasi warnanya sudah berkurang tersebut. Mari kita selidiki dan hasilnya disajikan pada @fig-komposisi-warna.

```{r}
#| label: fig-komposisi-warna
#| echo: false
#| fig-cap: "Komposisi warna pada foto"
#| fig-subcap: 
#|   - "Foto dengan k = 2"
#|   - "Foto dengan k = 4"
#|   - "Foto dengan k = 16"
#| fig-asp: 0.75
#| layout: "[[1,1], [1]]"

# Menyiapkan ringkasan data
ringkas_2 <- rgb_3_klaster_df |> 
  group_by(pusat_hex2) |> 
  summarise(
    n = n(),
    .groups = "drop"
  )
ringkas_4 <- rgb_3_klaster_df |> 
  group_by(pusat_hex4) |> 
  summarise(
    n = n(),
    .groups = "drop"
  )
ringkas_16 <- rgb_3_klaster_df |> 
  group_by(pusat_hex16) |> 
  summarise(
    n = n(),
    .groups = "drop"
  )

# Visualisasi ringkasan data
pr2 <- ringkas_2 |> 
  mutate(pct = n / sum(n)) |> 
  ggplot(aes(x = pusat_hex2, y = pct, fill = pusat_hex2)) + 
  geom_col() + 
  scale_fill_identity() + 
  scale_y_continuous(labels = percent_format(accuracy = 1)) + 
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  )

pr4 <- ringkas_4 |> 
  mutate(pct = n / sum(n)) |> 
  ggplot(aes(x = reorder(pusat_hex4, -pct), y = pct, fill = pusat_hex4)) + 
  geom_col() + 
  scale_fill_identity() + 
  scale_y_continuous(labels = percent_format(accuracy = 1)) + 
  theme_minimal() + 
  theme(
    axis.title = element_blank()
  )

pr16 <- ringkas_16 |> 
  mutate(pct = n / sum(n)) |> 
  ggplot(aes(x = reorder(pusat_hex16, -pct), y = pct, fill = pusat_hex16)) + 
  geom_col() + 
  scale_fill_identity() + 
  scale_y_continuous(labels = percent_format(accuracy = 1)) + 
  theme_minimal() + 
  theme(
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 60, hjust = .75)
  )

pr2
pr4
pr16

```

## Catatan Akhir {#sec-catatan-akhir}

Kita telah mereduksi variasi warna dalam sebuah foto dengan menggunakan [klasterisasi $k$-rerata](/pos/2025-09-klasterisasi-k-rerata/index.qmd "Klasterisasi K-Rerata: Langkah Demi Langkah Klasterisasi dengan Pemrograman R"). Untuk melakukannya, kita perlu mengetahui bagaimana sebuah foto atau gambar dapat direpresentasikan dengan matriks-matriks warna dasarnya. Setelah itu, kita ekstrak data warna piksel-piksel dalam gambar tersebut. Hal ini kita lakukan pada @sec-mengekstrak-data-warna. Setelah kita mendapatkan data warna tersebut, kita gunakan data tersebut untuk melakukan klasterisasi $k$-rerata (lihat @sec-klasterisasi-k-rerata). Di akhir, kita ubah warna tiap-tiap pikselnya dengan warna pusat klasternya. Dengan cara ini, kita mendapatkan gambar yang hanya tersusun dari $k$ warna. Hasil akhirnya dapat dilihat pada @fig-foto-asli-klaster-16-4-2.

Sebagai catatan, kita menggunakan klasterisasi $k$-rerata terhadap titik-titik warna yang dinyatakan ke dalam RGB. Algoritma $k$-rerata tersebut mengandalkan jarak untuk membuat klaster-klaster. Akan tetapi, persepsi kita terhadap warna tidaklah linear di RGB. Dalam RGB, dua warna mungkin memiliki jarak yang dekat, tetapi secara intuitif kita menilai warna tersebut jauh berbeda. Sebaliknya, mungkin ada dua warna yang jauh secara numerik dalam ruang RGB, tetapi bagi kita dua warna itu dekat secara intuitif. Oleh karena itu, kita dapat memilih format warna yang lebih sesuai dengan persepsi kita, misalnya [Lab](https://en.wikipedia.org/wiki/CIELAB_color_space "CIELAB color space"){.external target="_blank"}. Silakan gunakan metode yang kamu pelajari di artikel ini, tetapi dengan menggunakan ruang warna Lab.
