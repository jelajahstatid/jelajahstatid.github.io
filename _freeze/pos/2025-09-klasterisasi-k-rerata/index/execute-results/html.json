{
  "hash": "f442901dfc24f8d86a08c8e49620ce50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Klasterisasi K-Rerata\"\nsubtitle: \"Langkah Demi Langkah Klasterisasi dengan Pemrograman R\"\ndescription: \"Mulai dari memanipulasi gambar sampai menghindari paradoks Simpson, itulah manfaat analisis klaster. Artikel ini membahas secara tuntas analisis klaster yang sederhana, yaitu klasterisasi k-rerata (k-means clustering), mulai dari menjelaskan algoritmanya seperti apa sampai mendemonstrasikan algoritma tersebut secara mendetail.\"\nauthor:\n  - name: Yosep Dwi Kristanto\n    url: https://people.usd.ac.id/~ydkristanto/\n    affiliation: Pendidikan Matematika, Universitas Sanata Dharma, Yogyakarta\n    affiliation-url: https://www.usd.ac.id/s1pmat\n    orcid: 0000-0003-1446-0422\ndate: 2025-09-23\ncategories: \n  - klasterisasi\n  - tutorial\n  - visualisasi data\nimage: \"sampul-klasterisasi-k-rerata.png\"\nimage-alt: \"Ilustrasi setiap iterasi dalam klasterisasi k-rerata\"\nkeywords: \n  - analisis klaster\n  - klasterisasi\n  - k-rerata\n  - k-means clustering\n  - machine learning\n  - ilmu data\n  - paradoks Simpson\n  - pemelajaran mesin\n  - pemelajaran statistik\n  - statistical learning\nlightbox: true\ncopyright: \"Â© 2025 Yosep Dwi Kristanto\"\nlicense: \"CC BY\"\ncode-annotations: select\neditor_options: \n  chunk_output_type: console\n---\n\nAda banyak metode untuk memanipulasi sebuah gambar. Salah satunya ditunjukkan pada @fig-klaterisasi-gambar. Apa perbedaan gambar sebelah kiri dan kanan pada gambar tersebut?\n\n![Gambar asli (kiri) dan gambar setelah dimanipulasi (kanan)](aset/klasterisasi_karuna_donau.png){#fig-klaterisasi-gambar}\n\n*Yup*! Gambar sebelah kiri memiliki warna yang lebih bervariasi daripada yang kanan. Faktanya, gambar di sebelah kiri memiliki hampir 40 ribu warna sedangkan yang sebelah kanan hanya empat warna saja. Bagaimana cara melakukannya?\n\nTentu ada banyak cara untuk melakukannya. Akan tetapi, salah satunya adalah dengan menggunakan klasterisasi $k$-rerata. Untuk itu, kita akan belajar teknik klasterisasi tersebut. Kita awali dengan (a) latar belakang perlunya klasterisasi, kemudian (b) kita belajar bagaimana algoritmanya bekerja, dan akhirnya (c) kita aplikasikan algoritma tersebut untuk membagi data menjadi beberapa klaster. Jangan khawatir, penerapan algoritmanya nanti kita lakukan secara langkah demi langkah. Kita lakukan semuanya dengan menggunakan [pemrograman R](https://www.R-project.org/){.external target=\"_blank\"}. Untuk itu, kita buka paket-paket yang diperlukan.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nlibrary(tidyverse)\nlibrary(cowplot)\n```\n:::\n\n\n## Paradoks Simpson {#sec-paradoks-simpson}\n\nBayangkan kamu ingin menemukan model untuk datamu, misalnya `contoh_data`. Biasanya, kamu perlu memvisualisasikan data tersebut untuk melihat polanya. Diagram pencar data tersebut disajikan pada @fig-plot-contoh-data.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Diagram pencar `contoh_data`](index_files/figure-html/fig-plot-contoh-data-1.png){#fig-plot-contoh-data width=672}\n:::\n:::\n\n\nBerdasarkan @fig-plot-contoh-data, kamu kemungkinan besar menduga bahwa hubungan antara `x` dan `y` dalam data tersebut mengikuti model linear dengan korelasi positif: semakin besar nilai `x`, semakin besar juga nilai `y`. Dengan demikian, kamu akan mendapatkan model seperti yang ditunjukkan pada @fig-model-contoh-data.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Model linear untuk variabel-variabel `x` dan `y` dalam `contoh_data`](index_files/figure-html/fig-model-contoh-data-1.png){#fig-model-contoh-data width=672}\n:::\n:::\n\n\nAkan tetapi, setelah dicermati kembali, tampaknya `contoh_data` tersebut terbagi menjadi beberapa klaster. Berdasarkan pengamatan terhadap @fig-model-contoh-data saja, kita dapat melihat bahwa data tersebut memiliki lima klaster. Setelah mempertimbangkan klaster-klaster tersebut, kita mendapatkan model linear yang sama sekali berbeda. Perhatikan @fig-model-klaster-contoh-data!\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Model linear untuk variabel-variabel `x` dan `y` setelah mempertimbangkan klaster-klaster dalam `contoh_data`](index_files/figure-html/fig-model-klaster-contoh-data-1.png){#fig-model-klaster-contoh-data width=672}\n:::\n:::\n\n\nFenomena yang baru saja kita alami tersebut dinamakan *paradoks Simpson*. Kita mendapatkan korelasi yang positif ketika kita tidak mempertimbangkan klaster, dan korelasinya negatif ketika kita mempertimbangkan klaster. Oleh karena itu, penting bagi kita untuk mencermati data secara lebih hati-hati, khususnya jika dalam data tersebut memuat beberapa klaster.\n\nInformasi tentang klaster-klaster tersebut mungkin sudah ada dalam data. Akan tetapi, informasi tersebut juga mungkin belum ada. Jika klaster-klaster tersebut belum ada, kita dapat melakukan analisis klaster dengan menggunakan klasterisasi $k$-rerata (atau $k$*-means clustering*). Bagaimana caranya? Mari kita bahas di bagian berikutnya, @sec-klasterisasi-k-rerata.\n\n::: {.callout-note appearance=\"simple\" icon=\"false\"}\nJika kamu ingin menemukan ide mendasar algoritma $k$-rerata secara terbimbing, silakan kunjungi media interaktif di [tautan berikut](https://people.usd.ac.id/~ydkristanto/index.php/media-pengajaran/klasterisasi-k-rerata/ \"Klasterisasi K-Rerata: Bagaimana Ide Dasarnya?\"){.external target=\"_blank\"}. Media interaktif itu akan memandumu menemukan algoritma tersebut secara mandiri.\n:::\n\n## Klasterisasi $K$-Rerata {#sec-klasterisasi-k-rerata}\n\nKlasterisasi $k$-rerata merupakan algoritma pemelajaran mesin (*machine learning*) tanpa pengawasan yang membagi data tak berlabel menjadi $k$ klaster yang berbeda dan tak saling tumpang tindih. Sebelum dilakukan klasterisasi ini, banyaknya klaster $k$ perlu ditentukan terlebih dahulu. Algoritma klasterisasi ini adalah sebagai berikut.\n\n1.  **Inisialisasi:** Pertama, kita pilih banyaknya klaster, yaitu $k$. Setelah itu, algoritmanya akan memposisikan $k$ titik secara acak sebagai pusat klaster (*centroid*) yang pertama.\n\n2.  **Penugasan:** Setiap titik data dipasangkan ke pusat klaster terdekat. Proses ini menghasilkan $k$ klaster awal.\n\n3.  **Pembaruan:** Setelah semua titik masuk ke dalam klaster, algoritmanya kemudian menghitung kembali koordinat tiap-tiap pusat klasternya. Pusat klaster tersebut merupakan rerata dari semua titik dalam klaster tersebut.\n\n4.  **Ulangi:** Langkah 2 dan 3 diulangi kembali. Ketika pusat klaster berpindah, setiap titik datanya dipasangkan kembali dengan pusat klaster baru yang terdekat, kemudian pusat setiap klasternya dihitung kembali. Proses ini diulang secara terus menerus sampai pusat klasternya tidak berpindah secara signifikan atau banyak maksimum iterasinya tercapai.\n\nPenasaran dengan bagaimana algoritma tersebut bekerja? Pada bagian berikutnya, @sec-penerapan-algoritma-k-rerata, kita akan menerapkan algoritma tersebut kepada [Old Faithful Geyser](https://doi.org/10.2307/2347385){.external target=\"_blank\"}.\n\n## Penerapan Algoritma $K$-Rerata {#sec-penerapan-algoritma-k-rerata}\n\nKita terapkan algoritma $k$-rerata kepada data Old Faithful Geyser. Data ini sudah ada dalam R dengan nama `faithful`. Data ini memuat 272 baris dan dua variabel. Variabel `waiting` merupakan selang waktu antara dimulainya dua erupsi yang berurutan, sedangkan variabel `eruptions` merupakan lamanya erupsi yang kedua. Mari kita panggil data ini lihat beberapa barisnya dengan kode berikut.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\ndata(\"faithful\")\n\nhead(faithful)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions waiting\n1     3.600      79\n2     1.800      54\n3     3.333      74\n4     2.283      62\n5     4.533      85\n6     2.883      55\n```\n\n\n:::\n:::\n\n\nKita dapat mengenal data `faithful` tersebut secara lebih dekat dengan membuat diagram pencarnya. Perhatikan @fig-diagram-pencar-faithful!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfaithful |> \n  ggplot(aes(x = eruptions, y = waiting)) + \n  geom_point() + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Diagram pencar hubungan antara `eruptions` dan `waiting` dalam data `faithful`](index_files/figure-html/fig-diagram-pencar-faithful-1.png){#fig-diagram-pencar-faithful width=672}\n:::\n:::\n\n\nBerdasarkan @fig-diagram-pencar-faithful, kita dapat melihat bahwa tampaknya data `faithful` memiliki dua klaster. Oleh karena itu, kita akan pilih $k=2$. Sebelum kita menerapkan algoritma $k$-rerata, terlebih dahulu kita normalbakukan variabel-variabel dalam data `faithful` tersebut. Mengapa demikian?\n\nKlasterisasi $k$-rerata menggunakan jarak untuk menentukan klaster tiap-tiap titik datanya. Jika variabel-variabelnya memiliki skala yang berbeda (variabel `eruptions` merentang dari 1.6 sampai 5.1 sedangkan `waiting` merentang dari 43 sampai 96), variabel yang jangkauannya lebih besar tentu memiliki dampak besar terhadap perhitungan jaraknya. Hal ini akan menyebabkan hasil klasterisasinya tidak akurat.\n\nOleh karena itu, kita normalbakukan variabel-variabel `eruptions` dan `waiting` untuk membuat variabel-variabel baru, yaitu `eruptions_std` dan `waiting_std`. Untuk melihat hasilnya, kita dapat tampilkan beberapa baris pertamanya.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nfaithful <- faithful |> \n  mutate(\n    eruptions_std = scale(eruptions),\n    waiting_std = scale(waiting)\n  )\n\nhead(faithful)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions waiting eruptions_std waiting_std\n1     3.600      79    0.09831763   0.5960248\n2     1.800      54   -1.47873278  -1.2428901\n3     3.333      74   -0.13561152   0.2282418\n4     2.283      62   -1.05555759  -0.6544374\n5     4.533      85    0.91575542   1.0373644\n6     2.883      55   -0.52987412  -1.1693335\n```\n\n\n:::\n:::\n\n\n*Okay!* Data `faithful` telah siap dihidangkan untuk klasterisasi $k$-rerata dengan $k=2$. Tak usah berlama-lama, mari kita mulai ke iterasi yang pertama.\n\n### Iterasi 1 {#sec-iterasi-1}\n\nKita telah menentukan $k=2$, sehingga algoritma tersebut selanjutnya menentukan dua titik secara acak sebagai pusat klaster-klaster awalnya. Untuk alasan demonstrasi, kita tentukan dua titik tersebut adalah $\\left( -1.4, 1 \\right)$ dan $\\left( 1.4, -1 \\right)$. Berikutnya, kita tentukan jarak setiap titik ke pusat klaster-klaster awal tersebut. Titik-titik yang lebih dekat ke $\\left( -1.4, 1 \\right)$ berarti masuk ke \"Klaster 1\", sedangkan titik-titik yang lebih dekat ke $\\left( 1.4, -1 \\right)$ berarti masuk ke \"Klaster 2\".\n\nUntuk data dengan dua variabel dan $k=2$, penentuan klaster ini juga dapat dilakukan dengan menggunakan garis yang tegak lurus dengan ruas garis yang menghubungkan dua pusat klaster tersebut dan membagi ruas garis tersebut menjadi dua sama panjang. Titik-titik data yang berada pada sisi yang sama dengan pusat klaster pertama masuk ke \"Klaster 1\", sedangkan sisanya masuk ke \"Klaster 2\".\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nfaithful_1_1 <- faithful |> \n  select(eruptions_std, waiting_std) |> \n  mutate(\n    d1 = (eruptions_std - (-1.4))^2 + (waiting_std - 1)^2,\n    d2 = (eruptions_std - 1.4)^2 + (waiting_std - (-1))^2,\n    d = if_else(d1 <= d2, d1, d2),\n    klaster = if_else(d1 <= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_1_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions_std waiting_std       d1       d2        d   klaster\n1    0.09831763   0.5960248 2.408152 4.241672 2.408152 Klaster 1\n2   -1.47873278  -1.2428901 5.036755 8.346098 5.036755 Klaster 1\n3   -0.13561152   0.2282418 2.194289 3.866681 2.194289 Klaster 1\n4   -1.05555759  -0.6544374 2.855804 6.149177 2.855804 Klaster 1\n5    0.91575542   1.0373644 5.364119 4.385346 4.385346 Klaster 2\n6   -0.52987412  -1.1693335 5.463127 3.753088 3.753088 Klaster 2\n```\n\n\n:::\n:::\n\n\nAgar dua klaster yang terbentuk dapat terlihat dengan jelas, mari kita visualisaskan titik-titik datanya, beserta dengan garis yang membagi titik-titik tersebut menjadi dua klaster. Perhatikan @fig-iterasi-1-1!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_1_1 <- faithful_1_1 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = tibble(\n      x = c(-1.4, 1.4),\n      y = c(1, -1),\n      klaster = c(\"Klaster 1\", \"Klaster 2\")\n    ),\n    aes(x, y),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = tibble(\n      x = c(-1.4, 1.4),\n      y = c(1, -1),\n      klaster = c(\"Klaster 1\", \"Klaster 2\")\n    ),\n    aes(x, y, color = klaster),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = 7/5,\n    intercept = 0,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_1_1\n```\n\n::: {.cell-output-display}\n![Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi pertama (Iterasi 1-1)](index_files/figure-html/fig-iterasi-1-1-1.png){#fig-iterasi-1-1 width=672}\n:::\n:::\n\n\nLangkah kedua di iterasi pertama adalah menentukan pusat masing-masing klaster dengan cara menentukan reratanya.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\npusat_klaster_1_2 <- faithful_1_1 |> \n  group_by(klaster) |> \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_1_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã 3\n  klaster        x      y\n  <chr>      <dbl>  <dbl>\n1 Klaster 1 -0.730 -0.449\n2 Klaster 2  0.678  0.418\n```\n\n\n:::\n:::\n\n\nSelanjutnya, kita plot pusat klaster-klaster yang baru tersebut ke diagram pencar sebelumnya, menggantikan pusat-pusat klaster yang lama. Hasilnya disajikan pada @fig-iterasi-1-2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Menyiapkan data `faithful_1_2`\nfaithful_1_2 <- faithful_1_1 |> \n  select(eruptions_std, waiting_std, klaster) |> \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_1_2[[1,2]])^2 + (waiting_std - pusat_klaster_1_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_1_2[[2,2]])^2 + (waiting_std - pusat_klaster_1_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 1-2\nplot_1_2 <- faithful_1_2 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_1_2\n```\n\n::: {.cell-output-display}\n![Pusat dua klaster pada langkah kedua dalam iterasi pertama (Iterasi 1-2)](index_files/figure-html/fig-iterasi-1-2-1.png){#fig-iterasi-1-2 width=672}\n:::\n:::\n\n\nIterasi pertama telah selesai dilakukan. Sekarang kita lanjut ke @sec-iterasi-2.\n\n### Iterasi 2 {#sec-iterasi-2}\n\nKita masuk ke iterasi yang kedua. Pada langkah pertama, kita gunakan pusat klaster-klaster sebelumnya untuk memasukkan titik-titik datanya ke klasternya masing-masing.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nfaithful_2_1 <- faithful_1_2 |> \n  select(-d, -klaster) |> \n  mutate(\n    d = if_else(d1 <= d2, d1, d2),\n    klaster = if_else(d1 <= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_2_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions_std waiting_std        d1        d2         d   klaster\n1    0.09831763   0.5960248 1.7796010 0.3683804 0.3683804 Klaster 2\n2   -1.47873278  -1.2428901 1.1897322 7.4106840 1.1897322 Klaster 1\n3   -0.13561152   0.2282418 0.8128978 0.6985503 0.6985503 Klaster 2\n4   -1.05555759  -0.6544374 0.1478379 4.1560559 0.1478379 Klaster 1\n5    0.91575542   1.0373644 4.9200217 0.4404101 0.4404101 Klaster 2\n6   -0.52987412  -1.1693335 0.5583201 3.9784302 0.5583201 Klaster 1\n```\n\n\n:::\n:::\n\n\nKita visualisasikan titik-titik data dalam `faithful` beserta dengan klaster-klaster yang telah dihasilkan. Perhatikan @fig-iterasi-2-1!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_2_1 <- faithful_2_1 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 2,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.624589,\n    intercept = -0.058,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_2_1\n```\n\n::: {.cell-output-display}\n![Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi kedua (Iterasi 2-1)](index_files/figure-html/fig-iterasi-2-1-1.png){#fig-iterasi-2-1 width=672}\n:::\n:::\n\n\nBerikutnya, kita tentukan pusat klaster-klaster yang baru. Caranya sama, yaitu kita tentukan rerata semua titik pada masing-masing klaster.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\npusat_klaster_2_2 <- \n  faithful_2_1 |> \n  group_by(klaster) |> \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_2_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã 3\n  klaster        x      y\n  <chr>      <dbl>  <dbl>\n1 Klaster 1 -1.21  -1.16 \n2 Klaster 2  0.729  0.698\n```\n\n\n:::\n:::\n\n\nApa selanjutnya? Kita plot pusat-pusat klaster yang baru beserta dengan titik-titik datanya. Hasilnya disajikan pada @fig-iterasi-2-2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mempersiapkan `faithful_2_2`\nfaithful_2_2 <- faithful_2_1 |> \n  select(eruptions_std, waiting_std, klaster) |> \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_2_2[[1,2]])^2 + (waiting_std - pusat_klaster_2_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_2_2[[2,2]])^2 + (waiting_std - pusat_klaster_2_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 2-2\nplot_2_2 <- faithful_2_2 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_2_2\n```\n\n::: {.cell-output-display}\n![Pusat-pusat klaster pada langkah kedua dalam iterasi kedua (Iterasi 2-2)](index_files/figure-html/fig-iterasi-2-2-1.png){#fig-iterasi-2-2 width=672}\n:::\n:::\n\n\nMari kita lanjut ke iterasi berikutnya, @sec-iterasi-3.\n\n### Iterasi 3 {#sec-iterasi-3}\n\nPada langkah pertama di iterasi ketiga, kita pasangkan setiap titik ke dalam klasternya masing-masing berdasarkan jaraknya terhadap pusat klaster-klaster yang baru.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nfaithful_3_1 <- faithful_2_2 |> \n  select(-d, -klaster) |> \n  mutate(\n    d = if_else(d1 <= d2, d1, d2),\n    klaster = if_else(d1 <= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_3_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions_std waiting_std         d1        d2          d   klaster\n1    0.09831763   0.5960248 4.81663204 0.4075842 0.40758421 Klaster 2\n2   -1.47873278  -1.2428901 0.07632207 8.6381936 0.07632207 Klaster 1\n3   -0.13561152   0.2282418 3.09872776 0.9672434 0.96724344 Klaster 2\n4   -1.05555759  -0.6544374 0.28368178 5.0114795 0.28368178 Klaster 1\n5    0.91575542   1.0373644 9.37813119 0.1503982 0.15039817 Klaster 2\n6   -0.52987412  -1.1693335 0.46850713 5.0695722 0.46850713 Klaster 1\n```\n\n\n:::\n:::\n\n\nSelanjutnya kita plot titik-titik yang telah masuk ke dalam klasternya masing-masing dengan menggunakan diagram pencar. Perhatikan @fig-iterasi-3-1!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_3_1 <- faithful_3_1 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.0436,\n    intercept = -0.486595,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_3_1\n```\n\n::: {.cell-output-display}\n![Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi ketiga (Iterasi 3-1)](index_files/figure-html/fig-iterasi-3-1-1.png){#fig-iterasi-3-1 width=672}\n:::\n:::\n\n\nPada langkah kedua, kita tentukan pusat-pusat klaster yang baru. Caranya adalah sebagai berikut.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\npusat_klaster_3_2 <- faithful_3_1 |> \n  group_by(klaster) |> \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_3_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã 3\n  klaster        x      y\n  <chr>      <dbl>  <dbl>\n1 Klaster 1 -1.25  -1.19 \n2 Klaster 2  0.715  0.680\n```\n\n\n:::\n:::\n\n\nKita plot pusat klaster-klaster yang baru tersebut bersama dengan titik-titik data sebelumnya. Perhatikan @fig-iterasi-3-2!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mempersiapkan `faithful_3_2`\nfaithful_3_2 <- faithful_3_1 |> \n  select(eruptions_std, waiting_std, klaster) |> \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_3_2[[1,2]])^2 + (waiting_std - pusat_klaster_3_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_3_2[[2,2]])^2 + (waiting_std - pusat_klaster_3_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 3-2\nplot_3_2 <- faithful_3_2 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_3_2\n```\n\n::: {.cell-output-display}\n![Pusat-pusat klaster pada langkah kedua dalam iterasi ketiga (Iterasi 2-2)](index_files/figure-html/fig-iterasi-3-2-1.png){#fig-iterasi-3-2 width=672}\n:::\n:::\n\n\nKita telah menyelesaikan langkah kedua dalam iterasi ketiga. Sekarang, mari kita lanjut ke iterasi berikutnya!\n\n### Iterasi 4 {#sec-iterasi-4}\n\nApa langkah pertama di iterasi keempat ini? Ya! Kita masukkan setiap titik ke dalam klasternya berdasarkan jaraknya ke pusat klaster-klaster yang terakhir.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nfaithful_4_1 <- faithful_3_2 |> \n  select(-d, -klaster) |> \n  mutate(\n    d = if_else(d1 <= d2, d1, d2),\n    klaster = if_else(d1 <= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_4_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions_std waiting_std         d1        d2          d   klaster\n1    0.09831763   0.5960248 4.99975759 0.3869199 0.38691994 Klaster 2\n2   -1.47873278  -1.2428901 0.05581732 8.5091284 0.05581732 Klaster 1\n3   -0.13561152   0.2282418 3.24674404 0.9271753 0.92717528 Klaster 2\n4   -1.05555759  -0.6544374 0.32272192 4.9148263 0.32272192 Klaster 1\n5    0.91575542   1.0373644 9.64038624 0.1680127 0.16801271 Klaster 2\n6   -0.52987412  -1.1693335 0.51720760 4.9695885 0.51720760 Klaster 1\n```\n\n\n:::\n:::\n\n\nSekarang setiap titik telah memiliki klasternya masing-masing. Kita plot titik-titik tersebut ke dalam diagram pencar. Perhatikan @fig-iterasi-4-1!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_4_1 <- faithful_4_1 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.0508,\n    intercept = -0.534564,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_4_1\n```\n\n::: {.cell-output-display}\n![Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi keempat (Iterasi 4-1)](index_files/figure-html/fig-iterasi-4-1-1.png){#fig-iterasi-4-1 width=672}\n:::\n:::\n\n\nKita lanjut ke langkah kedua. Di langkah kedua ini, kita cari pusat klaster-klasternya yang baru.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npusat_klaster_4_2 <- faithful_4_1 |> \n  group_by(klaster) |> \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std),\n    .groups = \"drop\"\n  )\n\npusat_klaster_4_2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã 3\n  klaster        x      y\n  <chr>      <dbl>  <dbl>\n1 Klaster 1 -1.26  -1.20 \n2 Klaster 2  0.708  0.675\n```\n\n\n:::\n:::\n\n\nBerikutnya, kita plot pusat-pusat klaster yang baru tersebut bersama dengan titik-titik datanya. Perhatikan gambar berikut!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mempersiapkan `faithful_4_2`\nfaithful_4_2 <- faithful_4_1 |> \n  select(eruptions_std, waiting_std, klaster) |> \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_4_2[[1,2]])^2 + (waiting_std - pusat_klaster_4_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_4_2[[2,2]])^2 + (waiting_std - pusat_klaster_4_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 4-2\nplot_4_2 <- faithful_4_2 |> \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_4_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_4_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_4_2\n```\n\n::: {.cell-output-display}\n![Pusat-pusat klaster pada langkah kedua dalam iterasi keempat (Iterasi 4-2)](index_files/figure-html/fig-iterasi-4-2-1.png){#fig-iterasi-4-2 width=672}\n:::\n:::\n\n\n### Kilas Balik {#sec-kilas-balik}\n\nSampai di sini, kita telah melakukan empat kali iterasi. Apakah kita perlu melakukan iterasi lagi? Ataukah iterasinya sudah cukup? Untuk menjawab pertanyaan-pertanyaan tersebut, kita dapat menggunakan $WCSS$ (*Within-Cluster Sum of Squares*) atau jumlah kuadrat jarak setiap titik ke pusat klasternya. Dengan demikian, $WCSS$ ditentukan dengan @eq-wcss.\n\n$$\nWCSS=\\sum_{j=1}^{k}\\sum_{x_{i}\\in C_{j}}^{}\\left\\| x_{i}-p_{j}\\right\\|^2\n$$ {#eq-wcss}\n\n-   $C_{j}$ adalah klaster ke-$j$.\n\n-   $x_{i}$ adalah sebuah titik data dalam klaster $C_{j}$.\n\n-   $p_{j}$ adalah pusat klaster (*centroid*) dari $C_{j}$.\n\n-   $\\left\\| x_{i} - p_{j} \\right\\|^2$ adalah kuadrat jarak antara titik data dan pusat klasternya.\n\nDengan rumus ini, kita dapat menentukan $WCSS$ pada langkah pertama dalam iterasi pertama sebagai berikut.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nwcss_1_1 <- faithful_1_1 |> \n  summarise(\n    wcss = sum(d)\n  )\n\nwcss_1_1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      wcss\n1 1046.952\n```\n\n\n:::\n:::\n\n\nDengan cara yang serupa, kita dapat menentukan $WCSS$ untuk langkah pertama dan kedua dalam semua iterasi. Kita simpan nilai-nilai $WCSS$ tersebut ke dalam `wcss_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\ndaftar_faithful <- list(\n  \"1_1\" = faithful_1_1,\n  \"1_2\" = faithful_1_2,\n  \"2_1\" = faithful_2_1,\n  \"2_2\" = faithful_2_2,\n  \"3_1\" = faithful_3_1,\n  \"3_2\" = faithful_3_2,\n  \"4_1\" = faithful_4_1,\n  \"4_2\" = faithful_4_2\n)\n\nwcss_df <- map_dfr(\n  daftar_faithful,\n  ~ summarise(.x, wcss = sum(d)),\n  .id = \"faithful\"\n) |> \n  mutate(\n    iterasi = seq(from = 0.5, to = 4, by = 0.5),\n    group = as_factor(rep(c(\"M\", \"E\"), 4))\n  )\n\nwcss_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  faithful       wcss iterasi group\n1      1_1 1046.95159     0.5     M\n2      1_2  356.18666     1.0     E\n3      2_1  170.24221     1.5     M\n4      2_2   80.67025     2.0     E\n5      3_1   79.61314     2.5     M\n6      3_2   79.34288     3.0     E\n7      4_1   79.31314     3.5     M\n8      4_2   79.28340     4.0     E\n```\n\n\n:::\n:::\n\n\nKita telah memiliki untuk setiap langkahnya dalam `wcss_df`. Sekarang, kita dapat melihat tren nilai $WCSS$ tersebut. Perhatikan @fig-tren-wcss!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwcss_df |> \n  ggplot(aes(x = iterasi, y = wcss)) + \n  geom_line(\n    col = \"#00BA38\",\n    linewidth = 1\n  ) + \n  geom_point(\n    aes(col = group),\n    shape = 1,\n    size = 3,\n    stroke = 1.5\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n```\n\n::: {.cell-output-display}\n![Tren nilai WCSS dari langkah pertama iterasi pertama sampai langkah kedua iterasi keempat](index_files/figure-html/fig-tren-wcss-1.png){#fig-tren-wcss width=672}\n:::\n:::\n\n\nBerdasarkan @fig-tren-wcss, kita dapat melihat bahwa nilai $WCSS$ sudah konvergen pada iterasi kedua. Bahkan, dari iterasi ketiga sampai keempat, perubahan anggota kluster sudah tidak signifikan. Oleh karena itu, iterasinya kita cukupkan sampai iterasi keempat. Untuk melihat kembali apa yang telah kita lakukan mulai iterasi pertama sampai keempat, perhatikan @fig-semua-iterasi!\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Empat iterasi klasterasisasi k-rerata terhadap data `faithful` yang dinormalbakukan.](index_files/figure-html/fig-semua-iterasi-1.png){#fig-semua-iterasi width=672}\n:::\n:::\n\n\n## Klasterisasi $K$-Rerata dengan Fungsi `kmeans()` {#sec-klasterisasi-k-rerata-dengan-fungsi-kmeans}\n\nPada @sec-penerapan-algoritma-k-rerata, kita telah melakukan klasterisasi $k$-rerata langkah demi langkah, dari iterasi pertama sampai keempat. Banyak hal yang telah kita lakukan. Apakah ada fungsi di R yang dapat melakukan klasterisasi $k$-rerata secara otomatis dan cepat? Tentu saja ada! Fungsi itu adalah `kmeans()`.\n\nUntuk membagi data kita sebelumnya, yaitu `faithful,` menjadi $k=2$ klaster, kita gunakan kode seperti pada @lst-hasil-krerata.\n\n\n::: {.cell}\n\n```{#lst-hasil-krerata .r .cell-code  lst-cap=\"Klusterasi krerata dengan `kmeans()`\" code-fold=\"show\"}\n# Menyiapkan dataframe untuk `kmeans()`\nfaithful_std <- faithful |> \n  select(eruptions_std, waiting_std)\n\n# Menerapkan `kmeans()`\nhasil_krerata <- kmeans(x = faithful_std, centers = 2)\n```\n:::\n\n\nHasil klasterisasi $k$-rerata yang telah kita lakukan pada @lst-hasil-krerata disimpan dalam sebuah objek dengan nama `hasil_krerata`. Terdapat beberapa nilai yang dapat kita lihat dari `hasil_krerata` tersebut, di antaranya adalah `cluster` (sebuah vektor bilangan bulat dari 1 sampai $k$ yang mengindikasikan klaster-klaster setiap titiknya), `centers` (matriks pusat klaster-klaster yang terbentuk), `totss` (total dari jumlah kuadrat), `withinss` (vektor dari jumlah kuadrat dalam setiap klasternya), `tot.withinss` (total dari jumlah kuadrat dalam setiap klasternya, yaitu `sum(withinss)`, atau $WCSS$), `betweenss` (jumlah kuadrat antarklasternya, yaitu `totss-tot.withinss`), `size` (banyaknya titik dalam setiap klaster), dan `iter` (banyaknya iterasi).\n\nSekarang kita masukkan informasi klaster dalam `hasil_krerata` tersebut (yaitu `hasil_kerata$cluster`) ke dalam data `faithful` dan kita lihat hasilnya.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n# Memasukkan klaster yang dihasilkan ke dalam `faithful`\nfaithful <- faithful |> \n  mutate(\n    klaster = hasil_krerata$cluster\n  )\n\nhead(faithful)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  eruptions waiting eruptions_std waiting_std klaster\n1     3.600      79    0.09831763   0.5960248       2\n2     1.800      54   -1.47873278  -1.2428901       1\n3     3.333      74   -0.13561152   0.2282418       2\n4     2.283      62   -1.05555759  -0.6544374       1\n5     4.533      85    0.91575542   1.0373644       2\n6     2.883      55   -0.52987412  -1.1693335       1\n```\n\n\n:::\n:::\n\n\nIngin tahu bagaimana visualisasi hasilnya? Mari kita plot diagram pencar data `faithful`. Perhatikan @fig-diagram-pencar-kmeans!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfaithful |> \n  mutate(\n    klaster = as_factor(3 - klaster)\n  ) |> \n  ggplot(\n    aes(x = eruptions_std, y = waiting_std, color = klaster)\n  ) + \n  geom_point() + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n```\n\n::: {.cell-output-display}\n![Klaster-klaster dalam data `faithful` hasil klasterisasi k-rerata dengan fungsi `kmeans()`](index_files/figure-html/fig-diagram-pencar-kmeans-1.png){#fig-diagram-pencar-kmeans width=672}\n:::\n:::\n\n\nApakah @fig-diagram-pencar-kmeans sama dengan @fig-iterasi-4-2? Ternyata sama hasilnya.\n\n## Catatan Akhir {#sec-catatan-akhir}\n\nKita telah mempelajari klasterisasi $k$-rerata. Mengapa kita perlu mempelajari metode ini? Jawabannya telah kita pelajari pada @sec-paradoks-simpson. Setelah itu, bagaimana kerja algoritma $k$-rerata juga telah kita bahas di @sec-klasterisasi-k-rerata. Langkah-langkah rinci algoritma tersebut telah diilustrasikan pada @sec-penerapan-algoritma-k-rerata. Tak hanya itu, @sec-klasterisasi-k-rerata-dengan-fungsi-kmeans juga memberikan jalan cepat dengan fungsi `kmeans()`.\n\nSekarang, kita kembali ke permasalahan awal. Bagian awal artikel ini menyebutkan bahwa klasterisasi $k$-means dapat digunakan untuk memanipulasi gambar sehingga menghasilkan @fig-klaterisasi-gambar. Bagaimana caranya? Tutorial selengkapnya dapat ditemukan pada [pos berikutnya](/pos/2025-10-klasterisasi-warna-foto/index.qmd \"Klasterisasi Warna Foto: Manipulasi Foto dengan Klasterisasi K-Rerata\")!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}