[
  {
    "objectID": "reprex/quarto_observable_plot.html",
    "href": "reprex/quarto_observable_plot.html",
    "title": "Observable Plot",
    "section": "",
    "text": "This code defines the URL for a CSV file containing music revenue data from RIAA. The data file is hosted on a GitHub repository.\n\ncsvUrl = \"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/refs/heads/main/pos/2025-01-pendapatan-musik/aset/pendapatan_as_riaa.csv\"\n\n\n\n\n\n\nThis code loads the CSV data from the specified URL using D3.js. The d3.autoType function automatically converts numeric and date fields in the dataset for easier analysis.\n\nrevenueData = d3.csv(csvUrl, d3.autoType)\n\n\n\n\n\n\nThis code creates a bar chart using Observable Plot. The chart visualizes inflation-adjusted music revenue (pendapatan_infl) by year (tahun) and format (format). The chart includes a color legend with 4 columns and interactive tooltips for data points.\n\nPlot.plot({\n  color: {\n    legend: true,\n    columns: 4\n},\n  marks: [\n    Plot.rectY(revenueData,{\n      y: \"pendapatan_infl\",\n      x: \"tahun\",\n      fill: \"format\",\n      tip: true\n    })\n  ]\n})\n\n\n\n\n\n\n\n\nGambar 1: The colors in the bar chart are not displayed, although the tooltips are functioning correctly.\n\n\n\n\n\n\n\n Kembali ke atas"
  },
  {
    "objectID": "pos/2025-10-analisis-komponen-utama/index.html",
    "href": "pos/2025-10-analisis-komponen-utama/index.html",
    "title": "Analisis Komponen Utama",
    "section": "",
    "text": "Program Makan Bergizi Gratis (MBG) menjadi topik hangat berita nasional ketika artikel ini ditulis. Namun, artikel ini tidak akan membahas program itu melainkan topik yang serupa, yaitu tentang pangan. Secara lebih khusus, artikel ini akan menyingkap pola konsumsi pangan penduduk Indonesia per provinsi dengan menggunakan analisis komponen utama (AKU) atau principal component analysis (PCA). Kita awali pembahasannya dengan mengenal apa itu AKU."
  },
  {
    "objectID": "pos/2025-10-analisis-komponen-utama/index.html#sec-sekilas-tentang-analisis-komponen-utama",
    "href": "pos/2025-10-analisis-komponen-utama/index.html#sec-sekilas-tentang-analisis-komponen-utama",
    "title": "Analisis Komponen Utama",
    "section": "Sekilas Tentang AKU",
    "text": "Sekilas Tentang AKU\nAKU merupakan sebuah metode untuk menganalisis data yang titik-titik datanya dideskripsikan dengan beberapa variabel kuantitatif yang saling berkorelasi. Tujuan AKU adalah untuk:\n\nmengekstrak informasi yang paling penting dari data;\nmemampatkan ukuran data dengan menyimpan informasi yang penting saja;\nmenyederhanakan deskripsi dari data; dan\nmenganalisis struktur dari titik-titik data dan variabel-variabelnya.\n\nUntuk mencapai tujuan-tujuan tersebut, AKU menghitung variabel-variabel baru yang dinamakan komponen utama (principal component). Komponen utama yang pertama dibuat agar memiliki variansi atau inersia sebesar mungkin. Alhasil, komponen ini akan menjelaskan atau mengekstrak sebagian besar dari variansi data. Komponen utama yang kedua dihitung agar tegak lurus dengan komponen utama yang pertama dan memiliki variansi sebesar mungkin. Komponen-komponen utama berikutnya dihitung dengan cara yang serupa. Ringkasnya, komponen utama yang pertama didesain agar dapat menjelaskan variansi data sebesar mungkin, sedangkan komponen-komponen utama berikutnya menjelaskan variansi sisanya (yang tidak dijelaskan komponen utama yang pertama).\n\n\n\n\n\n\nMenyingkap Ide Mendasar AKU\n\n\n\nJika kamu ingin melihat bagaimana ide mendasar AKU, silakan kunjungi media-media interaktif pada laman berikut: Analisis Komponen Utama: Bagaimana Ide Dasarnya? dan Eksplorasi Analisis Komponen Utama, lihat Gambar 1.\n\n\n\n\n\n\n\n\n\n(a) Analisis Komponen Utama: Bagaimana Ide Dasarnya?\n\n\n\n\n\n\n\n\n\n(b) Eksplorasi Analisis Komponen Utama\n\n\n\n\n\n\nGambar 1: Media-media interaktif untuk mengenal AKU\n\n\nMedia interaktif yang ditunjukkan pada Gambar 1 (a) akan memandumu untuk memahami AKU, khususnya terkait penentuan komponen-komponen utamanya, dengan pendekatan geometris. Media yang ditunjukkan pada Gambar 1 (b) mengajakmu untuk mengeksplorasi AKU secara lebih lanjut."
  },
  {
    "objectID": "pos/2025-10-analisis-komponen-utama/index.html#sec-konsumsi-pangan-penduduk-indonesia",
    "href": "pos/2025-10-analisis-komponen-utama/index.html#sec-konsumsi-pangan-penduduk-indonesia",
    "title": "Analisis Komponen Utama",
    "section": "Konsumsi Pangan Penduduk Indonesia",
    "text": "Konsumsi Pangan Penduduk Indonesia\nKembali ke tujuan awal, selanjutnya kita mengaplikasikan AKU untuk menyingkap pola konsumsi penduduk Indonesia berdasarkan jenis pangan mulai dari tahun 2018 sampai 2024. Untuk melakukannya, kita menggunakan data dari Badan Pangan Nasional yang tersedia di satudata.badanpangan.go.id. Data ini menunjukkan nilai rata-rata konsumsi, dalam kg/kapita/tahun, penduduk Indonesia tiap provinsi berdasarkan jenis pangan pada tahun 2018 sampai 2024. Jenis-jenis pangan tersebut merupakan variabel-variabel kuantitatif yang akan kita selidiki. Variabel tersebut ada delapan, yaitu Buah/biji berminyak, Gula, Kacang-kacangan, Minyak dan Lemak, Padi-Padian, Pangan Hewani, Sayuran dan buah, dan Umbi-umbian.\nGambar 2 menunjukkan visualisasi hasil AKU terhadap data tersebut. Gambar 2 (a) menunjukkan komponen-komponen utama yang dihasilkan beserta dengan besarnya variansi data yang dapat dijelaskan oleh masing-masing komponen tersebut. Dari gambar tersebut kita dapat melihat bahwa KU1 (komponen utama pertama) dapat menjelaskan variansi terbesar, diikuti dengan KU2. Dengan demikian, selanjutnya kita gunakan dua komponen utama ini untuk menginterpretasi data. Secara total, kedua komponen utama tersebut dapat menjelaskan 44,35% variansi dalam data.\n\n\n\n\n\n\n\n\n\n\n(a) Variansi yang dijelaskan oleh setiap komponen utama\n\n\n\n\n\n\n\n\n\n(b) Hubungan antara variabel dan dua komponen utama dalam bidang AKU\n\n\n\n\n\n\n\n\n\n\n\n(c) Proyeksi titik-titik data (provinsi per tahun) pada bidang AKU\n\n\n\n\n\n\nGambar 2: Visualisasi hasil AKU\n\n\n\nGambar 2 (b) menyajikan arah dan kekuatan hubungan antara variabel-variabel asli dan dua komponen utama yang pertama: KU1 dan KU2. Misalnya, variabel Sayuran dan buah mengarah ke kiri atas. Artinya, variabel ini memiliki korelasi negatif dengan UK1 tetapi positif dengan UK2. Panjang panah menunjukkan besarnya korelasi. Meskipun sama-sama berkorelasi negatif dengan KU1, Sayuran dan buah korelasi lebih kuat dibandingkan dengan Kacang-kacangan. Tanda-tanda panah variabel tersebut juga menunjukkan korelasi antarvariabel:\n\njika tanda-tanda panahnya searah, variabel-variabel yang direpresentasikannya memiliki korelasi yang positif, misalnya antara Gula dan Pangan Hewani;\njika berlawanan arah, variabel-variabelnya berkorelasi negatif, misalnya antara Padi-Padian dan Umbi-umbian; dan\njika tegak lurus, variabel-variabelnya tidak berkorelasi, misalnya Gula dan Buah/biji berminyak.\n\nSelain untuk melihat korelasi, Gambar 2 (b) sangat berguna untuk menginterpretasi apa yang disajikan Gambar 2 (c). Gambar tersebut menyajikan proyeksi titik-titik data pada bidang AKU. Untuk menginterpretasi titik-titik data pada Gambar 2 (c) dengan Gambar 2 (b) secara lebih mudah, kita terlebih dahulu mengidentifikasi pencilan-pencilan datanya. Perhatikan Gambar 3!\n\n\n\n\n\n\n\nGambar 3: Proyeksi data pada bidang AKU dengan pemberian label untuk titik-titik pencilan\n\n\n\n\nBerdasarkan Gambar 3, kita dapat melihat bahwa titik “2018_Kalimantan Tengah” berada jauh dari kumpulan titik-titik lainnya, sehingga titik tersebut merupakan pencilan. Selain itu, titik tersebut searah dengan tanda panah variabel-variabel Gula dan Pangan Hewani, perhatikan kembali Gambar 2 (b). Dengan demikian, Provinsi Kalimantan Tengah pada tahun 2018 konsumsi pangannya pada kategori Gula atau Pangan Hewani lebih tinggi dari rerata provinsi-provinsi lainnya. Interpretasi yang serupa dapat kita lakukan untuk titik “2023_Papua”. Kita dapat menginterpretasi bahwa rerata konsumsi Provinsi Papua pada tahun 2023 untuk kategori Umbi-umbian lebih besar daripada provinsi-provinsi lainnya. Untuk mengkonfirmasi interpretasi tersebut, kita dapat membandingkannya dengan provinsi-provinsi lain yang bukan pencilan, misalnya “2020_Sumatera Barat” dan “2021_Jawa Timur”. Perhatikan Gambar 4!\n\n\n\n\n\n\n\nGambar 4: Perbandingan konsumsi per jenis pangan\n\n\n\n\nGambar 4 mengkonfirmasi interpretasi kita sebelumnya:\n\nRata-rata konsumsi pangan Provinsi Kalimantan Tengah pada tahun 2018 di kategori Pangan Hewani dan Gula lebih besar dari provinsi-provinsi lainnya. Karena kedua variabel tersebut berkorelasi negatif dengan Sayuran dan buah (lihat Gambar 2 (b)), rata-rata konsumsi Sayuran dan buah provinsi ini di tahun 2018 lebih rendah dibandingkan provinsi-prinvinsi lainnya.\nRata-rata konsumsi pangan Provinsi Papua pada tahun 2023 di kategori Umbi-umbian lebih besar dari provinsi-provinsi lainnya. Berdasarkan Gambar 3, hal ini juga terjadi untuk tahun-tahun 2018, 2019, 2021, dan 2024. Karena variabel tersebut berkorelasi negatif dengan Padi-Padian (lihat Gambar 2 (b)), konsumsi Padi-Padian provinsi Papua cenderung lebih rendah dibandingkan provinsi-provinsi lainnya.\n\nLebih lanjut, kita dapat melihat perubahan pola konsumsi pangan dari tahun ke tahun untuk provinsi tertentu. Misalnya, mari kita selidiki pola konsumsi pangan untuk Provinsi Kalimantan Timur. Perubahannya dapat kita lihat pada Gambar 5.\n\n\n\n\n\n\n\nGambar 5: Perubahan konsumsi pangan pada Provinsi Kalimantan Timur dari tahun 2018 sampai 2024\n\n\n\n\nGambar 5 memperlihatkan bagaimana titik yang merepresentasikan Provinsi Kalimantan Timur pada bidang AKU bergerak dari Kuadran III, kemudian ke Kuadran IV (yang searah dengan Minyak dan Lemak) pada tahun 2023, dan berhenti di Kuadran I (yang berlawanan arah dengan Padi-Padian, lihat kembali Gambar 2 (b)) pada tahun 2024. Dengan demikian, kita dapat menginterpretasi bahwa konsumsi pangan provinsi ini pada kategori Minyak dan Lemak bertambah mulai tahun 2023, tetapi konsumsi pada kategori Padi-Padian berkurang.\nUntuk mengkonfirmasi interpretasi ini, kita dapat membuat diagram batang konsumsi pangan per kategorinya untuk Provinsi Kalimantan Timur pada tahun 2019 (sebagai perwakilan lima tahun pertama yang tersedia di data), 2023, dan 2024. Perhatikan Gambar 6!\n\n\n\n\n\n\n\nGambar 6: Konsumsi pangan Provinsi Kalimantan Timur per kategorinya pada tahun 2019, 2023, dan 2024.\n\n\n\n\nGambar 6 menunjukkan secara jelas bahwa konsumsi penduduk Kalimantan Timur bertambah pada kategori Minyak dan Lemak tetapi berkurang pada kategori Padi-Padian mulai tahun 2023. Hal ini mengkonfirmasi interpretasi kita terhadap Gambar 5."
  },
  {
    "objectID": "pos/2025-10-analisis-komponen-utama/index.html#sec-catatan-akhir",
    "href": "pos/2025-10-analisis-komponen-utama/index.html#sec-catatan-akhir",
    "title": "Analisis Komponen Utama",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah mengenal metode statistika multivariat yang ampuh untuk mereduksi dimensi data, yaitu AKU. Hal ini kita lakukan pada Bagian 1. Metode ini kita gunakan untuk mereduksi dimensi data rata-rata konsumsi penduduk Indonesia, yang awalnya memiliki delapan variabel kuantitatif menjadi dua komponen utama saja. Dengan hanya menggunakan dua komponen utama tersebut, kita tetap masih dapat melihat struktur titik-titik data dan variabel-variabelnya. Misalnya dalam Bagian 2, kita menemukan hal-hal menarik tentang titik-titik pencilan dalam data, khususnya untuk Provinsi Kalimantan Tengah pada tahun 2018 dan Provinsi Papua pada Tahun 2023. Selain itu, dengan hanya dua komponen utama saja, kita dapat melihat perubahan konsumsi pangan Provinsi Kalimantan Timur dari tahun ke tahun, seperti yang ditunjukkan pada Gambar 5 dan Gambar 6.\nApa selanjutnya? Untuk menjawab pertanyaan ini, baik kalau kita kembali ke bagian paling awal artikel ini, yaitu tentang program MBG. Mungkin 2 – 5 tahun ke depan kita dapat menggunakan AKU untuk menyelidiki dampak program tersebut terhadap konsumsi pangan penduduk Indonesia. Hal ini bukannya tanpa tantangan. Untuk melakukannya, kita memerlukan data yang lebih detail, khususnya terkait dengan penggolongan penduduk (misalnya dari segi usia) karena tidak semua penduduk Indonesia terdampak (secara langsung) program tersebut. Meskipun demikian, menilik data kependudukan dari BPS, sasaran program tersebut cukup besar. Dengan demikian, tak ada salahnya jika kita tetap melihat dampaknya meskipun kesulitan mengakses data yang lebih detail. Tak hanya melihat pola konsumsi berdasarkan jenis pangannya, tetapi baik juga jika kita melihat hal-hal lain yang lebih detail dan relevan, seperti konsumsi energi dan protein."
  },
  {
    "objectID": "pos/2025-02-cerme14/index.html",
    "href": "pos/2025-02-cerme14/index.html",
    "title": "Mengantisipasi Bincang-Bincang Ilmiah",
    "section": "",
    "text": "Jejaring ada di mana-mana. Lingkungan sosial di sekitar kita, misalnya, dapat kita lihat sebagai sebuah jejaring. Orang adalah simpulnya dan relasi antarorang itu adalah sisinya. Jejaring juga dapat ditemukan di halte, seperti yang anakku perhatikan pada Gambar 1. Jejaring itu adalah jejaring jalur kereta. Stasiun adalah simpul dalam jejaring itu, jalur rel adalah sisinya. Pada artikel ini, aku akan memperlihatkan bagaimana bergunanya analisis jejaring untuk mengantisipasi apa yang dapat ditawarkan oleh sebuah forum ilmiah. Aku pilih forum ilmiah CERME 14 (14thCongress of the European Society for Research in Mathematics Education). Hal ini karena ketika aku menulis artikel ini, aku berada dalam kereta jalur Linz - Innsbruck - Bolzano, sedang menyiapkan bahan diskusi di forum itu. Sekali merengkuh dayung, dua tiga pulau terlampaui.\nSecara spesifik kita akan melihat bagaimana analisis jejaring dapat membantu untuk menyingkap tiga hal tentang CERME 14: kolaborasi antarnegara, koneksi antartopik, dan kedekatan antarpeneliti dalam forum ilmiah itu. Untuk mencapai ketiga hal itu, kita gunakan metadata artikel dan poster ilmiah yang telah diterima di forum tersebut. Metadata tersebut adalah identitas dokumen, pengarang, afiliasi pengarang, kata kunci, dan daftar pustaka artikel dan poster itu."
  },
  {
    "objectID": "pos/2025-02-cerme14/index.html#sec-kolaborasi-antarnegara",
    "href": "pos/2025-02-cerme14/index.html#sec-kolaborasi-antarnegara",
    "title": "Mengantisipasi Bincang-Bincang Ilmiah",
    "section": "Kolaborasi Antarnegara",
    "text": "Kolaborasi Antarnegara\nSetiap artikel dan poster ilmiah pada umumnya memuat informasi siapa saja pengarangnya dan apa afiliasi pengarang tersebut. Data afiliasi tersebut, khususnya identitas negaranya, dapat digunakan untuk menyingkap kolaborasi antarnegara. Hasilnya ditunjukkan pada Gambar 2.\n\n\n\n\n\n\n\nGambar 2: Kolaborasi antarnegara dalam kepengarangan artikel dan poster ilmiah CERME 14\n\n\n\n\nGambar 2 memperlihatkan bahwa CERME 14 tidak hanya melibatkan kontribusi peneliti dari negara-negara Eropa saja tetapi juga benua-benua lainnya. Mengetahui hal ini, kita dapat berharap akan adanya gagasan yang beragam tentang pendidikan matematika. Untuk mengkonfirmasi hal ini, kita akan melihat koneksi antartopik dalam CERME 14 pada Bagian 2."
  },
  {
    "objectID": "pos/2025-02-cerme14/index.html#sec-koneksi-antartopik",
    "href": "pos/2025-02-cerme14/index.html#sec-koneksi-antartopik",
    "title": "Mengantisipasi Bincang-Bincang Ilmiah",
    "section": "Koneksi Antartopik",
    "text": "Koneksi Antartopik\nApa saja topik yang dibahas dalam artikel dan poster ilmiah dalam CERME 14? Bagaimana keterhubungan topik-topik itu? Pertanyaan-pertanyaan ini, salah satunya, dapat dijawab dengan menggunakan analisis jejaring terhadap kata-kata kunci pada setiap artikel dan poster. Hasilnya ditunjukkan pada gambar interaktif di bawah ini.\n\n\n\n\n\n\nPada gambar di atas, kita dapat melihat jejaring kata-kata kunci yang disediakan oleh pengarang artikel dan poster dalam CERME 14. Dalam jejaring itu, ukuran setiap simpulnya merepresentasikan banyaknya simpul lain yang terhubung dengan simpul tersebut. Dengan demikian, kita dapat melihat bahwa kata kunci mathematics education, teacher education, professional development, mathematics, dan geometry adalah lima kata kunci teratas yang paling terhubung dengan kata kunci lainnya.\nKamu dapat menjelajah topik dalam CERME 14 dengan berinteraksi dengan gambar di atas. Apakah kamu menemukan topik yang familier di situ?"
  },
  {
    "objectID": "pos/2025-02-cerme14/index.html#sec-kedekatan-antarpeneliti",
    "href": "pos/2025-02-cerme14/index.html#sec-kedekatan-antarpeneliti",
    "title": "Mengantisipasi Bincang-Bincang Ilmiah",
    "section": "Kedekatan Antarpeneliti",
    "text": "Kedekatan Antarpeneliti\nForum ilmiah pada dasarnya adalah wadah untuk bertukar pikiran satu sama lain. Tukar pikiran ini kadang berjalan dengan lancar karena topik perbincangannya menarik bagi orang yang terlibat. Kadang juga topik perbincangannya sangat spesifik sehingga orang lain butuh lebih lama waktu untuk mencernanya.\nDua orang yang lebih “dekat” akan lebih mudah untuk bertukar pikiran. Kita maknai “dekat” di sini dengan seberapa mirip kata kunci dan daftar pustaka dalam artikel atau poster kedua orang tersebut. Semakin mirip kata kunci atau daftar pustakanya, kemungkinan besar kedua orang itu memiliki minat penelitian yang sama.\nKarena kedekatan antarpeneliti ini melibatkan daftar pustaka (yang sangat banyak), di sini aku akan menunjukkan kelompok peneliti di kelompok kerja tematik yang aku ikuti saja. Kelompok kerja tersebut temanya adalah sumber daya kurikulum dan desain aktivitas pembelajaran. Kedekatan peneliti yang tergabung dalam kelompok kerja ini disajikan pada Gambar 3.\n\n\n\n\n\n\n\nGambar 3: Matriks pasangan presenter berdasarkan kemiripan makalah atau posternya dilihat dari kata kunci atau daftar rujukannya\n\n\n\nWalaupun Gambar 3 memberikan informasi kedekatan setiap pasang peneliti, gambar tersebut terlalu detail. Gambar tersebut dapat diubah menjadi sebuah jejaring pada gambar di bawah ini."
  },
  {
    "objectID": "pos/2025-02-cerme14/index.html#catatan-akhir",
    "href": "pos/2025-02-cerme14/index.html#catatan-akhir",
    "title": "Mengantisipasi Bincang-Bincang Ilmiah",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah melihat bagaimana bermanfaatnya analisis jejaring untuk mengulik sebuah forum ilmiah. Pada Bagian 1, kita dapat melihat bahwa analisis jejaring mampu menunjukkan bagaimana kolaborasi antarpeneliti dalam CERME 14. Tak hanya itu, pada Bagian 2 kita telah melihat bagaimana analisis jejaring mampu menguak topik-topik penelitian dalam forum ilmiah itu. Terakhir, kita juga telah mengetahui bagaimana analisis jejaring juga dapat bermanfaat untuk melihat kedekatan antarpeneliti dalam hal topik kajiannya."
  },
  {
    "objectID": "pos/2024-08-statistik-jendela-dunia/index.html",
    "href": "pos/2024-08-statistik-jendela-dunia/index.html",
    "title": "Statistik Adalah Jendela Dunia",
    "section": "",
    "text": "Statistik adalah jendela dunia. Biasanya buku yang demikian, sekarang statistiklah yang mendapat giliran. Pos sebelumnya menunjukkan peran statistik untuk memahami keadaan sosial ekonomi dan pendidikan berbagai negara. Sekarang, kita akan melihat faedah statistik dalam memahami karakteristik-karakteristik lainnya.\nUntuk memahami dunia, kita akan menggunakan data dari Gapminder. Data tersebut dapat diunduh dari situs Gapminder. Di situs itu, kita dapat memilih berbagai macam indikator, seperti produk domestik bruto per kapita, harapan hidup, dan populasi.\nAlternatifnya, kita juga dapat mengunduhnya dari repositori Github. Data yang disiapkan oleh Jenny Bryan dan para koleganya tersebut relatif sederhana. Data ini mudah untuk diolah secara lebih lanjut. Data inilah yang akan kita gunakan pada bagian berikutnya. Untuk mengawali proses pengolahan data, kita panggil paket {tidyverse} dan {ggrepel}.\nlibrary(tidyverse)\nlibrary(ggrepel)"
  },
  {
    "objectID": "pos/2024-08-statistik-jendela-dunia/index.html#sec-data-konteks",
    "href": "pos/2024-08-statistik-jendela-dunia/index.html#sec-data-konteks",
    "title": "Statistik Adalah Jendela Dunia",
    "section": "Data dan Konteksnya",
    "text": "Data dan Konteksnya\nData yang akan kita olah dapat diunduh di tautan ini. Data tersebut merupakan fail RData. Untuk mengimpor fail RData ke dalam R, kita menggunakan fungsi load() dan url().\n\nload(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\"))\n\nSetelah kita menjalankan baris kode di atas, kita mendapatkan data dengan nama gapminder. Untuk melihat strukturnya, kita dapat menggunakan fungsi glimpse().\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\nTernyata data tersebut memiliki 1.704 baris dan 6 kolom. Keterangan lebih lanjut tentang keenam kolom tersebut disajikan pada Tabel 1.\n\n\nTabel 1: Keterangan variabel-variabel dalam gapminder.\n\n\n\n\n\n\n\nVariabel\nKeterangan\n\n\n\ncountry\nNegara\n\n\ncontinent\nBenua\n\n\nyear\nTahun\n\n\nlifeExp\nAngka harapan hidup\n\n\npop\nPopulasi\n\n\ngdpPercap\nProduk Domestik Bruto (PDB) per kapita dalam dolar internasional"
  },
  {
    "objectID": "pos/2024-08-statistik-jendela-dunia/index.html#sec-vis-data",
    "href": "pos/2024-08-statistik-jendela-dunia/index.html#sec-vis-data",
    "title": "Statistik Adalah Jendela Dunia",
    "section": "Visualisasi Data",
    "text": "Visualisasi Data\nPenjelajahan pun kita mulai. Dalam data gapminder tersebut, tahunnya merentang kapan saja? Untuk menjawabnya, kita dapat menggunakan unique().\n\nunique(gapminder$year)\n\n [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\n\n\nTernyata tahunnya merentang mulai 1952 sampai 2007 dengan interval lima tahun. Selanjutnya, bagaimana tren angka harapan hidup setiap negara pada periode tersebut? Kita dapat memvisualisasikannya dengan diagram pencar. Kita menggunakan benua (continent) sebagai pembeda warna titik-titiknya dan populasi (pop) sebagai penanda ukuran titik-titiknya.\n\nterjemahan_benua &lt;- c(\n  \"Asia\" = \"Asia\",\n  \"Europe\" = \"Eropa\",\n  \"Africa\" = \"Afrika\",\n  \"Americas\" = \"Amerika\",\n  \"Oceania\" = \"Oseania\"\n)\n\nplot_harapan_hidup &lt;- gapminder |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  ) |&gt; \n  ggplot() + \n  geom_point(\n    aes(x = year, y = lifeExp, color = continent, size = pop),\n    alpha = .6) + \n  scale_size(range = c(1, 20), guide = \"none\") + \n  scale_color_viridis_d(name = \"Benua\") + \n  theme_minimal() + \n  theme(legend.position = \"bottom\") + \n  labs(\n    x = \"Tahun\",\n    y = \"Angka harapan hidup\"\n  )\n\nprint(plot_harapan_hidup)\n\n\n\n\n\n\nGambar 1: Tren angka harapan hidup setiap negara pada tahun 1952 - 2007.\n\n\n\n\nBerdasarkan Gambar 1, kita melihat ada empat titik (negara) yang posisinya jauh di bawah dibandingkan kebanyakan negara lain. Itu terjadi pada tahun 1977, 1992, 1997, dan 2007. Kita selidiki apa saja negara tersebut.\n\nlifeExp_bawah &lt;- gapminder |&gt; \n  filter(\n    year %in% c(1977, 1992, 1997, 2007)\n  ) |&gt; \n  group_by(year) |&gt; \n  slice_min(lifeExp, n = 1) |&gt; \n  ungroup()\n\nprint(lifeExp_bawah)\n\n# A tibble: 4 × 6\n  country   continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Cambodia  Asia       1977    31.2 6978607      525.\n2 Rwanda    Africa     1992    23.6 7290203      737.\n3 Rwanda    Africa     1997    36.1 7212583      590.\n4 Swaziland Africa     2007    39.6 1133066     4513.\n\n\nKita sudah mengetahui apa saja negara tersebut. Sekarang kita masukkan informasi ini ke dalam diagram pencar pada Gambar 1. Hasilnya ditunjukkan pada Gambar 2.\n\nplot_harapan_hidup + \n  geom_text_repel(\n    data = lifeExp_bawah,\n    aes(x = year, y = lifeExp, label = country),\n    size = 3.5,\n    nudge_y = -1,\n    show.legend = FALSE\n  )\n\n\n\n\n\n\nGambar 2: Tren angka harapan hidup setiap negara pada tahun 1952 - 2007, dengan penambahan informasi negara-negara yang angka harapan hidupnya relatif rendah.\n\n\n\n\nBerdasarkan Gambar 1 dan Gambar 2, kita dapat melihat bahwa angka harapan hidupnya secara rata-rata naik dari tahun ke tahun. Untuk mengkonfirmasinya, kita dapat menambahkan visualisasi nilai tengah (median) angka harapan hidup ini. Perhatikan Gambar 3!\n\nmedian_lifeExp &lt;- gapminder |&gt; \n  group_by(year) |&gt; \n  summarise(\n    median = median(lifeExp, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nplot_harapan_hidup + \n  geom_line(\n    data = median_lifeExp,\n    aes(x = year, y = median),\n    linewidth = 1,\n    color = \"#164863\"\n  ) + \n  geom_text_repel(\n    data = lifeExp_bawah,\n    aes(x = year, y = lifeExp, label = country),\n    size = 3.5,\n    nudge_y = -1,\n    show.legend = FALSE\n  )\n\n\n\n\n\n\nGambar 3: Tren angka harapan hidup setiap negara pada tahun 1952 - 2007.\n\n\n\n\nBagaimana dengan PDB per kapita setiap negaranya? Apakah trennya juga naik dari tahun ke tahun? Mari kita visualisasikan PDB tersebut. Perhatikan Gambar 4!\n\nmedian_gdpPercap &lt;- gapminder |&gt; \n  group_by(year) |&gt; \n  summarise(\n    median = median(gdpPercap, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\ngdpPercap_atas &lt;- gapminder |&gt; \n  filter(\n    year &gt;= 1952,\n    year &lt;= 1977\n  ) |&gt; \n  group_by(year) |&gt; \n  slice_max(gdpPercap, n = 1) |&gt; \n  ungroup()\n\nplot_pdb &lt;- gapminder |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  ) |&gt; \n  ggplot() + \n  geom_point(\n    aes(x = year, y = gdpPercap, color = continent, size = pop),\n    alpha = .6\n  ) + \n  geom_line(\n    data = median_gdpPercap,\n    aes(x = year, y = median),\n    linewidth = 1,\n    color = \"#164863\"\n  ) + \n  geom_text_repel(\n    data = gdpPercap_atas,\n    aes(x = year, y = gdpPercap, label = country, color = continent),\n    size = 3.5,\n    nudge_y = -1,\n    show.legend = FALSE\n  ) + \n  scale_size(\n    range = c(1, 20),\n    guide = \"none\"\n  ) + \n  scale_color_viridis_d(name = \"Benua\") + \n  theme_minimal() + \n  theme(legend.position = \"bottom\") + \n  labs(\n    x = \"Tahun\",\n    y = \"PDB per kapita\"\n  )\n\nprint(plot_pdb)\n\n\n\n\n\n\nGambar 4: Tren PDB per kapita setiap negara pada tahun 1952 - 2007.\n\n\n\n\nTren nilai tengah PDB per kapita pada Gambar 4 tidak begitu tampak jelas. Kita plot ulang tren tersebut.\n\nmedian_gdpPercap |&gt; \n  ggplot(aes(x = year, y = median)) + \n  geom_line(\n    linewidth = 1,\n    color = \"#164863\"\n  ) + \n  theme_minimal() + \n  labs(\n    x = \"Tahun\",\n    y = \"Nilai tengah PDB per kapita\"\n  )\n\n\n\n\n\n\nGambar 5: Tren nilai tengah PDB per kapita setiap negara pada tahun 1952 - 2007.\n\n\n\n\nGambar 5 menunjukkan secara lebih jelas bahwa nilai tengah PDB per kapita mengalami kenaikan dari tahun ke tahun.\nNah, sekarang kita lanjutkan penjelajahan kita. Apakah terdapat hubungan antara PDB per kapita dengan angka harapan hidup? Kita selidiki pertanyaan ini dengan menggunakan tahun 2007.\n\ngapminder |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  ) |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(\n    aes(x = gdpPercap, y = lifeExp)\n  ) + \n  geom_point(\n    aes(color = continent, size = pop),\n    alpha = .6\n  ) + \n  geom_smooth(\n    method = \"loess\",\n    formula = y ~ x,\n    linewidth = 1,\n    alpha = .1,\n    color = \"#427D9D\"\n  ) + \n  scale_size(\n    range = c(1, 20),\n    guide = \"none\"\n  ) + \n  scale_color_viridis_d(name = \"Benua\") + \n  theme_minimal() + \n  theme(legend.position = \"bottom\") + \n  labs(\n    x = \"PDB per kapita\",\n    y = \"Angka harapan hidup\"\n  )\n\n\n\n\n\n\nGambar 6: Hubungan antara PDB per kapita dan angka harapan hidup pada tahun 2007.\n\n\n\n\nBerdasarkan Gambar 6, kita dapat melihat bahwa terdapat hubungan antara PDB per kapita dan angka harapan hidup. Semakin tinggi PDB per kapita sebuah negara, semakin tinggi juga angka harapan hidupnya. Secara spesifik, ketika PDB per kapita naik dari 0 sampai 7.500 dolar, laju kenaikan angka harapan hidupnya paling tinggi.\n\n\n\n\n\n\nCatatan\n\n\n\nBerdasarkan Gambar 6, kita mengetahui bahwa laju kenaikan angka harapan hidup paling tinggi ketika PDB per kapitanya naik dari 0 sampai 7.500 dolar. Laju kenaikan ini disajikan sebagai gradien model linear yang disajikan pada Gambar 7 berikut.\n\nKodegapminder_filter_pdb &lt;- gapminder |&gt; \n  filter(\n    year == 2007,\n    gdpPercap &gt;= 0,\n    gdpPercap &lt;= 7500\n  )\n\nmodel_linear &lt;- lm(\n  formula = lifeExp ~ gdpPercap,\n  data = gapminder_filter_pdb\n)\n\ngapminder |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  ) |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(\n    aes(x = gdpPercap, y = lifeExp)\n  ) + \n  geom_point(\n    aes(color = continent, size = pop),\n    alpha = .6\n  ) + \n  geom_smooth(\n    data = gapminder_filter_pdb,\n    method = \"lm\",\n    formula = y ~ x,\n    linewidth = 1.5,\n    alpha = .1,\n    color = \"black\"\n  ) + \n  scale_size(\n    range = c(1, 20),\n    guide = \"none\"\n  ) + \n  scale_color_viridis_d(name = \"Benua\") + \n  xlim(0, 50000) + \n  theme_minimal() + \n  theme(legend.position = \"bottom\") + \n  labs(\n    x = \"PDB per kapita\",\n    y = \"Angka harapan hidup\"\n  )\n\n\n\n\n\n\nGambar 7: Hubungan antara PDB per kapita dan angka harapan hidup pada tahun 2007 ketika PDB per kapitanya di antara 0 dan 7.500 dolar internasional\n\n\n\n\nPersamaan garis untuk model linear tersebut ditunjukkan pada Persamaan 1.\n\\[\n\\text{lifeExp} = \\text{50,89832} + \\text{0,003358}\\text{gdpPercap}\n\\tag{1}\\]\nBerdasarkan model tersebut, angka harapan hidup (lifeExp) naik 0,003358 tahun ketika PDB per kapitanya (gdpPercap) naik 1 dolar. Dengan kata lain, angka harapan hidup itu secara rata-rata naik sekitar 3,4 tahun ketika PDB per kapitanya naik 1.000 dolar.\n\n\nApakah hubungan seperti itu juga terjadi pada tahun-tahun lainnya? Kita selidiki dengan memvisualisasikan data yang serupa, tapi untuk tahun 1987, 1992, 1997, dan 2002. Perhatikan Gambar 8!\n\ngapminder |&gt; \n  filter(year %in% c(1987, 1992, 1997, 2002)) |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  ) |&gt; \n  ggplot(\n    aes(x = gdpPercap, y = lifeExp)\n  ) + \n  geom_point(\n    aes(color = continent, size = pop),\n    alpha = .6\n  ) + \n  geom_smooth(\n    method = \"loess\",\n    formula = y ~ x,\n    linewidth = 1,\n    alpha = .1,\n    color = \"#427D9D\"\n  ) + \n  scale_size(\n    range = c(1, 10),\n    guide = \"none\"\n  ) + \n  scale_color_viridis_d(name = \"Benua\") + \n  facet_wrap(\n    vars(year),\n    ncol = 2\n  ) + \n  theme_minimal() + \n  theme(legend.position = \"bottom\") + \n  labs(\n    x = \"PDB per kapita\",\n    y = \"Angka harapan hidup\"\n  )\n\n\n\n\n\n\nGambar 8: Hubungan antara PDB per kapita dan angka harapan hidup pada tahun 1987, 1992, 1997, dan 2002.\n\n\n\n\nBerdasarkan Gambar 8, kita melihat hubungan yang serupa untuk tahun 1987, 1992, 1997, dan 2002. Semakin tinggi PBD per kapita sebuah negara, semakin tinggi juga angka harapan hidupnya."
  },
  {
    "objectID": "pos/2024-08-statistik-jendela-dunia/index.html#catatan-akhir",
    "href": "pos/2024-08-statistik-jendela-dunia/index.html#catatan-akhir",
    "title": "Statistik Adalah Jendela Dunia",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah melihat situasi dunia melalui jendela yang namanya statistik. Hal ini kita lakukan dengan menjelajah dan memvisualisasikan data Gapminder. Pada Bagian 2, kita telah melihat bagaimana tren angka harapan hidup dan PDB per kapita setiap tahunnya. Selain itu, kita juga telah melihat hubungan antara PDB per kapita dan angka harapan hidup untuk tahun 1987, 1992, 1997, 2002, dan 2007.\nApa selanjutnya? Kita mungkin menyadari adanya keterbatasan visualisasi data pada Gambar 6 dan Gambar 8. Pada kedua diagram tersebut, kita belum bisa menyajikan data untuk semua tahun yang tersedia. Bagaimana cara mengatasi keterbatasan ini? Salah satunya, kita dapat menganimasikan hubungan antara PDB per kapita dan angka harapan hidup mulai tahun 1952 sampai 2007.1 Alternatifnya, kita juga dapat membuat sebuah aplikasi interaktif yang memungkinkan pengguna untuk memilih tahun-tahunnya.2 Kedua cara tersebut akan didemonstrasikan pada pos-pos berikutnya. Untuk itu, silakan tunggu terus pembaharuan blog ini!"
  },
  {
    "objectID": "pos/2024-08-statistik-jendela-dunia/index.html#footnotes",
    "href": "pos/2024-08-statistik-jendela-dunia/index.html#footnotes",
    "title": "Statistik Adalah Jendela Dunia",
    "section": "Catatan Kaki",
    "text": "Catatan Kaki\n\nAnimasi dapat dibuat di R dengan menggunakan paket {gganimate}. Pos berikutnya mendemonstrasikan bagaimana menggunakan paket tersebut untuk memvisualisasikan hubungan antara PDB per kapita dan angka harapan hidup dari tahun ke tahun.↩︎\nPos selanjutnya memperlihatkan bagaimana menggunakan aplikasi interaktif ini dengan menggunakan {shiny}.↩︎"
  },
  {
    "objectID": "pos/2024-08-peringkat-fifa-indonesia/index.html",
    "href": "pos/2024-08-peringkat-fifa-indonesia/index.html",
    "title": "Sepak Bola Indonesia vs. Negara-Negara Asia Tenggara",
    "section": "",
    "text": "Akhir-akhir ini prestasi tim nasional sepak bola Indonesia menjadi sorotan. Pertama, tim nasional U-23 Indonesia berhasil tampil ciamik di perhelatan Piala Asia U-23 AFC 2024. Timnas yang dilatih Shin Tae-yong ini secara dramatis berhasil mengalahkan Korea Selatan di babak perempat final melalui adu penalti. Akhirnya, timnas ini menduduki peringkat keempat di turnamen tersebut.\nKedua adalah prestasi tim nasional U-19 Indonesia di Kejuaraan Remaja U-19 ASEAN 2024. Di kejuaraan ini, timnas Indonesia berhasil menjadi juara grup dengan poin sempurna, mengalahkan Malaysia di babak semifinal, dan mengunci posisi juara setelah mempecundangi Thailand di babak final.\nPrestasi-prestasi itu juga sejalan dengan perjalanan tim nasional (senior) Indonesia. Berdasarkan rilis FIFA dan akun X Timnas Indonesia, Indonesia menjadi tim dengan kenaikan posisi tertinggi pada peringkat dunia FIFA di periode 4 April 2024. Indonesia naik delapan peringkat, dari peringkat 142 menjadi 134. Kenaikan peringkat yang drastis ini terjadi karena timnas Indonesia berhasil mengalahkan Vietnam, baik kandang maupun tandang, di Kualifikasi Piala Dunia FIFA 2026 pada 21 dan 26 Maret 2024.\nPrestasi-prestasi sepak bola Indonesia tersebut menambah cerita manis di tahun 2024. Mumpung masih di bulan Agustus yang penuh dengan sukacita peringatan kemerdekaan, mari kita lihat prestasi timnas Indonesia secara lebih mendalam. Kita akan melihatnya dengan menganalisis data peringkat dunia FIFA."
  },
  {
    "objectID": "pos/2024-08-peringkat-fifa-indonesia/index.html#sec-indonesia-dan-asia-tenggara",
    "href": "pos/2024-08-peringkat-fifa-indonesia/index.html#sec-indonesia-dan-asia-tenggara",
    "title": "Sepak Bola Indonesia vs. Negara-Negara Asia Tenggara",
    "section": "Statistik Sepak Bola Indonesia",
    "text": "Statistik Sepak Bola Indonesia\nKenaikan peringkat sepak bola Indonesia memang menjanjikan. Akan tetapi, bagaimana jika peringkat Indonesia dibandingkan dengan negara-negara Asia Tenggara lainnya? Animasi pada Gambar 1 berikut menunjukkan perubahan peringkat sepak bola Indonesia dibandingkan dengan negara-negara tersebut.\n\n\n\n\n\nGambar 1: Peringkat sepak bola Indonesia dibandingkan dengan negara-negara Asia Tenggara Lainnya\n\n\n\nGambar tersebut menunjukkan bagaimana posisi Indonesia berubah-ubah. Dibandingkan dengan negara-negara anggota AFF (ASEAN Football Federation), Indonesia pernah menduduki peringkat ke-11. Itu terjadi pada 5 Mei, 2 Juni, dan 14 Juli 2016. Posisi Indonesia hanya berada di atas satu negara anggota AFF, yaitu Brunei Darussalam.\n\nIndonesia juga pernah menduduk posisi teratas di antara negara-negara AFF. Itu terjadi pada 20 Juli 2005. Pada waktu itu, Indonesia berada di atas Thailand, Singapura, dan Vietnam. Meskipun Australia berada di atas Indonesia pada periode tersebut, tetapi waktu itu Australia belum bergabung ke AFF.\nSelama setahun terakhir, Indonesia termasuk ke dalam lima teratas negara-negara AFF bersama dengan Australia, Thailand, Vietnam, dan Malaysia. Gambar 2 berikut menunjukkan peringkat Indonesia dan keempat negara tersebut.\n\n\n\n\n\n\n\nGambar 2: Peringkat lima teratas negara-negara AFF\n\n\n\n\nLalu bagaimana peringkat Indonesia dibandingkan dengan semua negara anggota FIFA? Gambar 3 berikut menunjukkan tren peringkat Indonesia mulai tahun 1992.\n\n\n\n\n\n\n\nGambar 3: Peringkat FIFA untuk Indonesia mulai 1992 sampai 2024\n\n\n\n\nPeringkat tertinggi Indonesia terjadi pada 16 September 1998. Pada periode itu, Indonesia menduduki peringkat ke-76. Peringkat terbawah Indonesia adalah 191. Hal ini terjadi ketika Indonesia menduduki peringkat ke-11 dibandingkan negara-negara Asia Tenggara lainnya, seperti yang telah disebutkan sebelumnya. Kemerosotan peringkat tersebut merupakan buntut dari sanksi FIFA yang memaksa timnas Indonesia vakum dalam pertandingan internasional selama kurang lebih setahun."
  },
  {
    "objectID": "pos/2024-08-peringkat-fifa-indonesia/index.html#catatan-akhir",
    "href": "pos/2024-08-peringkat-fifa-indonesia/index.html#catatan-akhir",
    "title": "Sepak Bola Indonesia vs. Negara-Negara Asia Tenggara",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah melihat seberapa baik sepak bola Indonesia melalui kacamata statistik. Dengan menggunakan data peringkat dunia FIFA, kita dapat membandingkan sepak bola Indonesia dengan negara-negara lainnya, khususnya negara-negara anggota AFF. Gambar 1 memperlihatkan bagaimana posisi sepak bola Indonesia dibandingkan dengan negara-negara AFF setiap waktunya. Animasi yang dibuat dengan {gganimate} tersebut juga memperlihatkan poin Indonesia (beserta negara-negara AFF lainnya) setiap tahunnya.\nGambar 2 dan Gambar 3 juga memberikan informasi yang tak kalah pentingnya. Berdasarkan kedua diagram tersebut, kita dapat mengetahui bagaimana tren peringkat sepak bola Indonesia dibandingkan dengan negara-negara AFF maupun semua negara anggota FIFA.\nStatistik-statistik sepak bola Indonesia tersebut harapannya dapat memberikan pemaknaan dan warna baru dalam peringatan HUT ke-79 Republik Indonesia. Dirgahayu Indonesiaku. Semoga sepak bola Indonesia semakin berjaya!"
  },
  {
    "objectID": "pos/2024-08-indonesia-di-olimpiade/index.html",
    "href": "pos/2024-08-indonesia-di-olimpiade/index.html",
    "title": "Prestasi Indonesia di Olimpiade",
    "section": "",
    "text": "Olimpiade Musim Panas 2024 telah usai. Olimpiade itu meninggalkan banyak cerita menarik. Salah satu yang banyak diperbincangkan adalah Kim Yeji dan Yusuf Dikeç. Atlet yang secara berturut-turut membela negara Turki dan Korea Selatan tersebut tidak hanya mengukir prestasi, tetapi juga meninggalkan bekas karena gaya dan penampilannya.\nAkan tetapi, kita tidak akan memperbincangkan kedua atlet itu. Di suasana peringatan kemerdekaan Republik Indonesia ini, kita akan melihat prestasi atlet-atlet Indonesia di Olimpiade Musim Panas. Pada Olimpiade Paris 2024, Indonesia berhasil menyabet dua medali emas dan satu perunggu. Dua medali emas tersebut disabet oleh Veddriq Leonardo (panjat tebing) dan Rizki Juniansyah (angkat besi) sedangkan medali perunggunya diraih oleh Gregoria Mariska Tunjung (bulu tangkis).\nBagaimana dengan pagelaran olimpiade-olimpiade sebelumnya? Kita akan menjawab pertanyaan ini dengan menggunakan data yang tersedia di laman Wikipedia."
  },
  {
    "objectID": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-mempersiapkan-data",
    "href": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-mempersiapkan-data",
    "title": "Prestasi Indonesia di Olimpiade",
    "section": "Mempersiapkan Data",
    "text": "Mempersiapkan Data\nKita akan melakukan analisis dan visualisasi data dengan pemrograman R. Pertama, kita panggil paket-paket yang diperlukan. Kita gunakan {rvest} untuk mengimpor data dari sebuah laman web, {tidyverse} untuk menganalisis dan memvisualisasikan data, dan {ggstream} untuk membuat diagram alir.\n\nlibrary(rvest)\nlibrary(tidyverse)\nlibrary(ggstream)\n\nMengimpor Data\nSekarang kita mengimpor datanya. Data tersebut berasal dari laman Wikipedia. Data yang kita impor adalah data jumlah medali berdasarkan olimpiade dan cabang olahraganya. Untuk melakukannya, kita menggunakan baris kode seperti berikut.\n\nhtml &lt;- read_html(\"https://id.wikipedia.org/w/index.php?title=Indonesia_pada_Olimpiade&oldid=26147360\")\n\ndaftar_tabel &lt;- html |&gt; \n  html_elements(\".wikitable\") |&gt; \n  html_table()\n\nprint(daftar_tabel)\n\n[[1]]\n# A tibble: 50 × 5\n   Medali       Nama                                    Olimpiade Olahraga Nomor\n   &lt;chr&gt;        &lt;chr&gt;                                   &lt;chr&gt;     &lt;chr&gt;    &lt;chr&gt;\n 1 01  Emas     Hartono, RudyRudy Hartono               Munich 1… Bulu ta… Tung…\n 2 01  Emas     Chandra, AdeAde Chandra dan Christian … Munich 1… Bulu ta… Tung…\n 3 02  Perak    Dewi, UtamiUtami Dewi                   Munich 1… Bulu ta… Tung…\n 4 03  Perunggu Hadinata, ChristianChristian Hadinata … Munich 1… Bulu ta… Gand…\n 5 02  Perak    Sugiarto, IcukIcuk Sugiarto             Seoul 19… Bulu ta… Tung…\n 6 02  Perak    Handayani, LiliesLilies Handayani, Nur… Seoul 19… Panahan  Tim …\n 7 02  Perak    Dirc Talumewo                           Barcelon… Taekwon… Putr…\n 8 02  Perak    Rahmi Kurnia                            Barcelon… Taekwon… Putr…\n 9 02  Perak    Susilawati                              Barcelon… Taekwon… Putr…\n10 03  Perunggu Jefi Tri Aji                            Barcelon… Taekwon… Putr…\n# ℹ 40 more rows\n\n[[2]]\n# A tibble: 22 × 9\n   Olimpiade  `Jumlah atlet` `Pembawa bendera` Jumlah cabangolahrag…¹ `01  Emas`\n   &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;             &lt;chr&gt;                  &lt;chr&gt;     \n 1 Helsinki … 3              \"\"                3                      0         \n 2 Melbourne… 22             \"\"                6                      0         \n 3 Roma 1960  22             \"\"                8                      0         \n 4 Tokyo 1964 Tidak ikut     \"Tidak ikut\"      Tidak ikut             Tidak ikut\n 5 Mexico Ci… 6              \"\"                2                      0         \n 6 München 1… 6              \"Wiem Gommies\"    5                      0         \n 7 Montreal … 7              \"Donald Pandiang… 5                      0         \n 8 Moskwa 19… Tidak ikut     \"Tidak ikut\"      Tidak ikut             Tidak ikut\n 9 Los Angel… 16             \"Luki Niode\"      6                      0         \n10 Seoul 1988 29             \"Tonny Maringgi\"  11                     0         \n# ℹ 12 more rows\n# ℹ abbreviated name: ¹​`Jumlah cabangolahraga yang diikuti`\n# ℹ 4 more variables: `02  Perak` &lt;chr&gt;, `03  Perunggu` &lt;chr&gt;, Total &lt;chr&gt;,\n#   Peringkat &lt;chr&gt;\n\n[[3]]\n# A tibble: 5 × 5\n  Cabang                   Emas Perak Perunggu Total\n  &lt;chr&gt;                   &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;int&gt;\n1 Bulu tangkis  (detail)      8     6        8    22\n2 Angkat besi  (detail)       1     7        8    16\n3 Panjat tebing  (detail)     1     0        0     1\n4 Panahan  (detail)           0     1        0     1\n5 Total (4 cabang)           10    14       16    40\n\n\nApa yang dilakukan baris kode di atas? Pertama, kita membaca html pada laman Wikipedia tersebut dan menyimpannya sebagai sebuah objek dengan nama html. Setelah itu, objek html tersebut kita cari elemennya yang bernama .wikitable.1 Setelah elemen tersebut ditemukan, kita baca elemen tersebut sebagai tabel dengan fungsi html_table(). Hasil dari proses ini kemudian kita namai sebagai daftar_tabel. Untuk melihat apa isi daftar_tabel tersebut, kita dapat menggunakan fungsi print().\nSetelah kita lihat dengan print(), ternyata daftar_tabel merupakan sebuah daftar (list). Data yang kita inginkan, yaitu data jumlah medali berdasarkan olimpiade dan cabang olahraganya, merupakan elemen kedua dan ketiga dari daftar_tabel. Untuk itu, kita dapat mengekstrak kedua data tersebut dengan daftar_tabel[[1]] dan daftar_tabel[[2]]. Kita namai hasilnya dengan data_dsr_olimpiade dan data_dsr_cabang.\n\ndata_dsr_olimpiade &lt;- daftar_tabel[[2]]\ndata_dsr_cabang &lt;- daftar_tabel[[3]]\n\nMerapikan Data\nSaat ini kita telah memiliki dua data, yaitu data_dsr_olimpiade (data jumlah medali berdasarkan penyelenggaraan olimpiade) dan data_dsr_cabang (data jumlah medali berdasarkan cabang olahraga). Kita rapikan kedua data tersebut. Untuk merapikan data_dsr_olimpiade, kita lihat isi data tersebut dengan fungsi print().\n\nprint(data_dsr_olimpiade)\n\n# A tibble: 22 × 9\n   Olimpiade  `Jumlah atlet` `Pembawa bendera` Jumlah cabangolahrag…¹ `01  Emas`\n   &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;             &lt;chr&gt;                  &lt;chr&gt;     \n 1 Helsinki … 3              \"\"                3                      0         \n 2 Melbourne… 22             \"\"                6                      0         \n 3 Roma 1960  22             \"\"                8                      0         \n 4 Tokyo 1964 Tidak ikut     \"Tidak ikut\"      Tidak ikut             Tidak ikut\n 5 Mexico Ci… 6              \"\"                2                      0         \n 6 München 1… 6              \"Wiem Gommies\"    5                      0         \n 7 Montreal … 7              \"Donald Pandiang… 5                      0         \n 8 Moskwa 19… Tidak ikut     \"Tidak ikut\"      Tidak ikut             Tidak ikut\n 9 Los Angel… 16             \"Luki Niode\"      6                      0         \n10 Seoul 1988 29             \"Tonny Maringgi\"  11                     0         \n# ℹ 12 more rows\n# ℹ abbreviated name: ¹​`Jumlah cabangolahraga yang diikuti`\n# ℹ 4 more variables: `02  Perak` &lt;chr&gt;, `03  Perunggu` &lt;chr&gt;, Total &lt;chr&gt;,\n#   Peringkat &lt;chr&gt;\n\n\nData tersebut memiliki 22 baris dan 9 variabel/kolom. Kita dapat melihat beberapa baris terakhirnya dengan fungsi tail().\n\ntail(data_dsr_olimpiade)\n\n# A tibble: 6 × 9\n  Olimpiade   `Jumlah atlet` `Pembawa bendera` Jumlah cabangolahrag…¹ `01  Emas`\n  &lt;chr&gt;       &lt;chr&gt;          &lt;chr&gt;             &lt;chr&gt;                  &lt;chr&gt;     \n1 Rio de Jan… 28             \"Maria Natalia L… \"7\"                    \"1\"       \n2 Tokyo 2020  28             \"Rio Waida\"       \"8\"                    \"1\"       \n3 Paris 2024  29             \"Maryam March Ma… \"12\"                   \"2\"       \n4 Los Angele… Pertandingan … \"\"                \"\"                     \"\"        \n5 Brisbane 2… Pertandingan … \"\"                \"\"                     \"\"        \n6 Total       Total          \"Total\"           \"Total\"                \"9\"       \n# ℹ abbreviated name: ¹​`Jumlah cabangolahraga yang diikuti`\n# ℹ 4 more variables: `02  Perak` &lt;chr&gt;, `03  Perunggu` &lt;chr&gt;, Total &lt;chr&gt;,\n#   Peringkat &lt;chr&gt;\n\n\nTernyata, data_dsr_olimpiade tersebut juga memuat dua olimpiade yang belum terlaksana dan satu baris total. Kita hilangkan ketiga baris tersebut dengan menggunakan slice_head(). Dengan demikian, kita hanya menggunakan 22 - 3 = 19 barisnya saja.\n\ndata_dsr_olimpiade &lt;- data_dsr_olimpiade |&gt; \n  slice_head(n = 19)\n\nUntuk mengeceknya lagi, kita dapat menggunakan tail() lagi.\n\ntail(data_dsr_olimpiade)\n\n# A tibble: 6 × 9\n  Olimpiade   `Jumlah atlet` `Pembawa bendera` Jumlah cabangolahrag…¹ `01  Emas`\n  &lt;chr&gt;       &lt;chr&gt;          &lt;chr&gt;             &lt;chr&gt;                  &lt;chr&gt;     \n1 Athena 2004 38             Christian Hadina… 14                     1         \n2 Beijing 20… 24             Oka Sulaksana     7                      1         \n3 London 2012 22             I Gede Siman Sud… 8                      0         \n4 Rio de Jan… 28             Maria Natalia Lo… 7                      1         \n5 Tokyo 2020  28             Rio Waida         8                      1         \n6 Paris 2024  29             Maryam March Mah… 12                     2         \n# ℹ abbreviated name: ¹​`Jumlah cabangolahraga yang diikuti`\n# ℹ 4 more variables: `02  Perak` &lt;chr&gt;, `03  Perunggu` &lt;chr&gt;, Total &lt;chr&gt;,\n#   Peringkat &lt;chr&gt;\n\n\nKita telah mengkonfirmasi bahwa data_dsr_olimpiade sudah berisi baris-baris yang kita butuhkan saja. Selanjutnya, kita lihat gambaran umum data tersebut dengan fungsi glimpse().\n\nglimpse(data_dsr_olimpiade)\n\nRows: 19\nColumns: 9\n$ Olimpiade                            &lt;chr&gt; \"Helsinki 1952\", \"Melbourne 1956\"…\n$ `Jumlah atlet`                       &lt;chr&gt; \"3\", \"22\", \"22\", \"Tidak ikut\", \"6…\n$ `Pembawa bendera`                    &lt;chr&gt; \"\", \"\", \"\", \"Tidak ikut\", \"\", \"Wi…\n$ `Jumlah cabangolahraga yang diikuti` &lt;chr&gt; \"3\", \"6\", \"8\", \"Tidak ikut\", \"2\",…\n$ `01  Emas`                           &lt;chr&gt; \"0\", \"0\", \"0\", \"Tidak ikut\", \"0\",…\n$ `02  Perak`                          &lt;chr&gt; \"0\", \"0\", \"0\", \"Tidak ikut\", \"0\",…\n$ `03  Perunggu`                       &lt;chr&gt; \"0\", \"0\", \"0\", \"Tidak ikut\", \"0\",…\n$ Total                                &lt;chr&gt; \"0\", \"0\", \"0\", \"Tidak ikut\", \"0\",…\n$ Peringkat                            &lt;chr&gt; \"\", \"\", \"\", \"Tidak ikut\", \"\", \"\",…\n\n\nSetelah melihat hasilnya, kita gunakan lima variabel dari data_dsr_olimpiade saja, yaitu Olimpiade, 01  Emas, 02  Perak, 03  Perunggu, dan Peringkat. Setelah itu kita buat data tersebut menjadi data yang memanjang dengan pivot_longer() dan kita rapikan isinya. Untuk memudahkan analisis data selanjutnya, kita tambahkan variabel tahun. Variabel ini kita ekstrak dari variabel Olimpiade karena nilai-nilai variabel tersebut memuat tahun, misalnya “Helsinki 1952” dan “Melbourne 1956”.\n\ndata_dsr_olimpiade &lt;- data_dsr_olimpiade |&gt; \n  select(Olimpiade, `01  Emas`, `02  Perak`, `03  Perunggu`, Peringkat) |&gt; \n  pivot_longer(\n    cols = contains(\"0\"),\n    names_to = \"medali\",\n    values_to = \"banyak\"\n  ) |&gt; \n  rename(\n    olimpiade = Olimpiade,\n    peringkat = Peringkat\n  ) |&gt; \n  mutate(\n    tahun = as.integer(str_extract(olimpiade, \"\\\\d{4}\")),\n    peringkat = ifelse(\n      peringkat == \"\" | peringkat == \"Tidak ikut\",\n      NA, as.integer(peringkat)\n    ),\n    medali = substr(medali, 5, nchar(medali)),\n    banyak = ifelse(\n      banyak == \"Tidak ikut\",\n      NA, as.integer(banyak)\n    )\n  ) |&gt; \n  select(\n    tahun, olimpiade, medali, banyak, peringkat\n  )\n\nprint(data_dsr_olimpiade)\n\n# A tibble: 57 × 5\n   tahun olimpiade      medali   banyak peringkat\n   &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;     &lt;int&gt;     &lt;int&gt;\n 1  1952 Helsinki 1952  Emas          0        NA\n 2  1952 Helsinki 1952  Perak         0        NA\n 3  1952 Helsinki 1952  Perunggu      0        NA\n 4  1956 Melbourne 1956 Emas          0        NA\n 5  1956 Melbourne 1956 Perak         0        NA\n 6  1956 Melbourne 1956 Perunggu      0        NA\n 7  1960 Roma 1960      Emas          0        NA\n 8  1960 Roma 1960      Perak         0        NA\n 9  1960 Roma 1960      Perunggu      0        NA\n10  1964 Tokyo 1964     Emas         NA        NA\n# ℹ 47 more rows\n\n\ndata_dsr_olimpiade telah siap tersaji. Sekarang saatnya kita beralih ke data_dsr_cabang. Sebelum merapikan data ini, kita lihat datanya terlebih dahulu.\n\nprint(data_dsr_cabang)\n\n# A tibble: 5 × 5\n  Cabang                   Emas Perak Perunggu Total\n  &lt;chr&gt;                   &lt;int&gt; &lt;int&gt;    &lt;int&gt; &lt;int&gt;\n1 Bulu tangkis  (detail)      8     6        8    22\n2 Angkat besi  (detail)       1     7        8    16\n3 Panjat tebing  (detail)     1     0        0     1\n4 Panahan  (detail)           0     1        0     1\n5 Total (4 cabang)           10    14       16    40\n\n\nUntuk merapikan data tersebut, kita dapat melakukan beberapa hal. Pertama, kita hapus baris dan kolom terakhirnya (baris dan kolom total). Kedua, kita rapikan isi dari variabel Cabang. Ketiga, kita buat data tersebut menjadi data yang memanjang. Terakhir, kita konsistenkan nama variabelnya.\n\ndata_dsr_cabang &lt;- data_dsr_cabang |&gt; \n  select(-Total) |&gt; \n  filter(Cabang != \"Total (4 cabang)\") |&gt; \n  mutate(\n    Cabang = str_trim(str_remove(Cabang, \" \\\\(detail\\\\)\"))\n  ) |&gt; \n  pivot_longer(\n    cols = -Cabang,\n    names_to = \"medali\",\n    values_to = \"banyak\"\n  ) |&gt; \n  rename(cabang = Cabang)\n\nprint(data_dsr_cabang)\n\n# A tibble: 12 × 3\n   cabang        medali   banyak\n   &lt;chr&gt;         &lt;chr&gt;     &lt;int&gt;\n 1 Bulu tangkis  Emas          8\n 2 Bulu tangkis  Perak         6\n 3 Bulu tangkis  Perunggu      8\n 4 Angkat besi   Emas          1\n 5 Angkat besi   Perak         7\n 6 Angkat besi   Perunggu      8\n 7 Panjat tebing Emas          1\n 8 Panjat tebing Perak         0\n 9 Panjat tebing Perunggu      0\n10 Panahan       Emas          0\n11 Panahan       Perak         1\n12 Panahan       Perunggu      0\n\n\ndata_dsr_cabang sekarang sudah rapi. Saatnya kita lanjut ke tahapan berikutnya—visualisasi data."
  },
  {
    "objectID": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-visualisasi-data",
    "href": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-visualisasi-data",
    "title": "Prestasi Indonesia di Olimpiade",
    "section": "Visualisasi Data",
    "text": "Visualisasi Data\nPada Bagian 1 kita telah mengimpor dan merapikan data tentang banyaknya medali yang diperoleh Indonesia berdasarkan perhelatan olimpiade dan cabang-cabang olahraganya. Selanjutnya, kita akan memvisualisasikan kedua data tersebut.\nMedali dan Perhelatan Olimpiade\nBagaimana perolehan medali Indonesia di setiap keikutsertaannya di olimpiade? Untuk menjawab pertanyaan ini, kita dapat membuat diagram batang dengan menggunakan data_dsr_olimpiade. Perhatikan Gambar 1!\n\ndata_dsr_olimpiade |&gt; \n  ggplot(aes(x = tahun, y = banyak, fill = medali)) + \n  geom_col(position = \"dodge\") + \n  scale_x_continuous(\n    breaks = seq(1952, 2024, 4)\n  ) + \n  scale_y_continuous(\n    limits = c(0, 4.2),\n    expand = c(0, 0)\n  ) + \n  scale_fill_manual(\n    name = \"Medali\",\n    values = c(\n      \"Emas\" = \"#FCC861\",\n      \"Perak\" = \"#E5E5E5\",\n      \"Perunggu\" = \"#DCB386\"\n    )\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\",\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    axis.line.x = element_line(),\n    axis.ticks.x = element_line(),\n    axis.text.x = element_text(\n      angle = 90,\n      vjust = .5\n    ),\n    axis.title.x = element_blank()\n  ) + \n  labs(\n    y = \"Banyak perolehan medali\"\n  )\n\n\n\n\n\n\nGambar 1: Banyaknya medali yang diperoleh Indonesia di setiap olimpiade yang diikutinya\n\n\n\n\nBerdasarkan Gambar 1 tersebut, Indonesia pertama kali meraih medali pada tahun 1988 meskipun telah ikut olimpiade sejak 1952. Selain itu, Indonesia dapat meraih medali emas sebanyak dua kali untuk pertama kalinya pada tahun 1992. Capaian ini diulang kembali pada olimpiade terakhir, yaitu pada tahun 2024.\nBagaimana kalau kita ingin melihat tren perolehan medali emas, perak, dan perunggu setiap penyelenggaraan olimpiadenya? Perhatikan Gambar 2!\n\ndata_dsr_olimpiade |&gt; \n  ggplot(aes(x = tahun, y = banyak, col = medali)) + \n  geom_line(\n    linewidth = 1\n  ) + \n  scale_y_continuous(\n    limits = c(0, 4.2),\n    expand = c(0, 0)\n  ) + \n  scale_color_manual(\n    name = \"Medali\",\n    values = c(\n      \"Emas\" = \"#FCC861\",\n      \"Perak\" = \"#E5E5E5\",\n      \"Perunggu\" = \"#DCB386\"\n    )\n  ) + \n  facet_grid(~medali) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\",\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.minor.y = element_blank()\n  ) + \n  labs(\n    x = \"Tahun\",\n    y = \"Banyak perolehan medali\"\n  )\n\n\n\n\n\n\nGambar 2: Tren perolehan medali Indonesia di setiap olimpiade yang diikutinya\n\n\n\n\nKita dapat menggabungkan fokus informasi yang disampaikan diagram batang pada Gambar 1 dan diagram garis pada Gambar 2 dengan menggunakan diagram alir.\n\ndata_dsr_olimpiade |&gt; \n  ggplot(aes(x = tahun, y = banyak, fill = medali)) + \n  geom_vline(\n    aes(xintercept = tahun),\n    color = \"grey\",\n    linewidth = .25\n  ) + \n  geom_stream() + \n  geom_stream_label(aes(label = medali)) + \n  geom_text(\n    aes(label = olimpiade),\n    y = -4.9,\n    angle = 90,\n    hjust = 0,\n    nudge_x = -1.2,\n    color = \"grey\"\n  ) + \n  scale_fill_manual(\n    name = \"Medali\",\n    values = c(\n      \"Emas\" = \"#FCC861\",\n      \"Perak\" = \"#E5E5E5\",\n      \"Perunggu\" = \"#DCB386\"\n    )\n  ) + \n  scale_x_continuous(\n    limits = c(1948, 2026),\n    expand = c(0, 0)\n  ) + \n  scale_y_continuous(\n    limits = c(-5, 3),\n    expand = c(0, 0)\n  ) + \n  theme_void() + \n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\nGambar 3: Tren perolehan medali emas, perak, dan perunggu Indonesia di setiap olimpiade yang diikutinya\n\n\n\n\nKita telah memvisualisasikan perolehan medali Indonesia di olimpiade. Selanjutnya kita akan memvisualisasikan distribusi medali untuk cabang-cabang olahraganya.\nMedali dan Cabang Olahraga\nCabang olahraga apa saja yang menyumbangkan medali bagi Indonesia? Bagaimana distribusinya? Untuk menjawab pertanyaan-pertanyaan ini, kita dapat menggambarkan distribusinya dengan diagram batang.\n\ndata_dsr_cabang |&gt; \n  mutate(\n    cabang = fct_relevel(\n      cabang,\n      \"Bulu tangkis\", \"Angkat besi\", \"Panjat tebing\", \"Panahan\"\n    )\n  ) |&gt; \n  ggplot(aes(x = cabang, y = banyak)) + \n  geom_col(aes(fill = medali)) + \n  scale_y_continuous(\n    expand = c(0, 0)\n  ) + \n  scale_fill_manual(\n    name = \"Medali\",\n    values = c(\n      \"Emas\" = \"#FCC861\",\n      \"Perak\" = \"#E5E5E5\",\n      \"Perunggu\" = \"#DCB386\"\n    )\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\",\n    axis.line.x = element_line(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank()\n  ) + \n  labs(\n    x = \"Cabang olahraga\",\n    y = \"Banyak perolehan medali\"\n  )\n\n\n\n\n\n\nGambar 4: Distribusi medali olimpiade yang diperoleh Indonesia berdasarkan cabang olahraganya\n\n\n\n\nBerdasarkan Gambar 4, kita dapat melihat bahwa ada empat cabang olahraga yang berkontribusi bagi perolehan medali Indonesia. Keempat cabang olahraga tersebut jika diurutkan berdasarkan perolehan medalinya adalah bulu tangkis, angkat besi, panjat tebing, dan panahan."
  },
  {
    "objectID": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-catatan-akhir",
    "href": "pos/2024-08-indonesia-di-olimpiade/index.html#sec-catatan-akhir",
    "title": "Prestasi Indonesia di Olimpiade",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nDi suasana riuh rendah peringatan HUT ke-79 kemerdekaan Republik Indonesia dan Olimpiade Paris 2024 ini, bersama-sama kita telah melihat prestasi Indonesia di perhelatan olimpiade mulai tahun 1952 sampai 2024. Untuk melihatnya, kita awali dengan mempersiapkan data pada Bagian 1. Di tahapan ini, kita melakukan impor data dari Wikipedia pada Bagian 1.1 dan merapikan datanya pada Bagian 1.2.\nSetelah data rapi, kita melakukan visualisasi data pada Bagian 2. Terdapat dua macam informasi yang kita visualisasikan. Pertama adalah banyak medali di setiap pagelaran olimpiade yang Indonesia ikuti (Bagian 2.1). Kedua adalah distribusi medali berdasarkan cabang olahraganya (Bagian 2.2)."
  },
  {
    "objectID": "pos/2024-08-indonesia-di-olimpiade/index.html#footnotes",
    "href": "pos/2024-08-indonesia-di-olimpiade/index.html#footnotes",
    "title": "Prestasi Indonesia di Olimpiade",
    "section": "Catatan Kaki",
    "text": "Catatan Kaki\n\nBagaimana cara menemukan nama elemen dari objek yang ingin kita impor? Salah satunya adalah dengan membaca kode sumber laman webnya. Selain itu, jika kita menggunakan Google Chrome, kita juga dapat memanfaatkan Developer tools-nya.↩︎"
  },
  {
    "objectID": "pos/2024-08-dirgahayu-indonesia/index.html",
    "href": "pos/2024-08-dirgahayu-indonesia/index.html",
    "title": "Dirgahayu Kemerdekaan Republik Indonesia",
    "section": "",
    "text": "Di awal bulan Agustus, masyarakat Indonesia pada umumnya sibuk mempersiapkan hajatan negara. Mereka secara serentak memasang bendera merah putih, spanduk, umbul-umbul, bersih-bersih desa, dan lain sebagainya. Berbagai perlombaan pun dilakukan. Mulai dari sepak bola, bola voli, bulu tangkis, tenis meja, sampai panjat pinang. Itu semua merupakan luapan suka cita kemerdekaan dan harapan ke depan.\nNusantara Baru, Indonesia Maju. Itulah tema besar peringatan hari ulang tahun ke-79 kemerdekaan Republik Indonesia. Peringatan HUT ke-79 RI tersebut tentu memiliki banyak makna dan harapan. Menariknya, makna dan harapan tersebut tergambar dalam logo numerik yang digunakan. Salah satu harapannya adalah pertumbuhan ekonomi.\nBerdasarkan panduan identitas visualnya, angka tujuh pada logo tersebut menyerupai anak panah yang mengarah ke kanan-atas. Dalam bahasa Statistika, angka tersebut menyimbolkan tren yang naik. Perhatikan Gambar 1. Hal itu melambangkan harapan Indonesia untuk meningkatkan investasi dan ekspornya sehingga bertumbuh ekonominya.\nNah, kita akan melihat harapan besar itu, khususnya dalam hal investasi. Kita akan menggunakan data realisasi penanaman modal asing pada periode 2010 – 2024 dari Kementerian Investasi/BKPM. Data tersebut kita manfaatkan untuk memvisualisasikan dan melihat tren realisasi penanaman modal dari berbagai negara.\nKita akan memvisualisasikan data tersebut dengan pemrograman R. Untuk melakukannya, kita menggunakan paket {tidyverse}, {ggstream}, dan {ggtext}. Untuk itu kita perlu memastikan ketiga paket tersebut telah terpasang. Jika sudah, kita dapat memanggilnya dengan kode seperti berikut.\nlibrary(tidyverse)\nlibrary(ggstream)\nlibrary(ggtext)"
  },
  {
    "objectID": "pos/2024-08-dirgahayu-indonesia/index.html#sec-menjelajah-data",
    "href": "pos/2024-08-dirgahayu-indonesia/index.html#sec-menjelajah-data",
    "title": "Dirgahayu Kemerdekaan Republik Indonesia",
    "section": "Menjelajah Data",
    "text": "Menjelajah Data\nMari singsingkan lengan baju kita. Dengan semangat kemerdekaan (agak berlebihan tak apa), kita mulai penjelahan data. Data realisasi penanaman modal tersebut tersedia di situs web Kementerian Investasi/BKPM. Data yang sudah aku siapkan dapat diakses di tautan ini. Dengan fungsi read_csv() kita impor data tersebut dan kita namai dengan realisasi_penanaman_modal. Untuk melihat datanya, kita dapat menggunakan fungsi print().\n\nrealisasi_penanaman_modal &lt;- read_csv(\"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/main/pos/2024-08-dirgahayu-indonesia/aset/realisasi_penanaman_modal.csv\")\n\nprint(realisasi_penanaman_modal)\n\n# A tibble: 177 × 17\n   benua  negara  `2010` `2011` `2012` `2013` `2014` `2015` `2016` `2017` `2018`\n   &lt;chr&gt;  &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 Afrika Afrika…     NA     NA     NA     NA     NA   NA      NA     NA      0 \n 2 Afrika Afrika…     NA   1190     NA     NA    500   69.1   982.  4292.  5369.\n 3 Afrika Aljaza…     NA     NA     NA     NA     NA    0     400      0      0 \n 4 Afrika Benin       NA     NA     NA     NA     NA   NA      NA     NA     NA \n 5 Afrika Burkin…     NA     NA     NA     NA    200  300       0    411.     0 \n 6 Afrika Eswati…     NA     NA     NA     NA     NA   NA      NA     NA     NA \n 7 Afrika Ethiop…     NA     NA     NA     NA     NA   NA      NA     NA    650 \n 8 Afrika Gambia      NA     NA     NA     NA      0   NA      NA     NA     NA \n 9 Afrika Ghana       NA     NA     NA     NA     NA   NA      NA     NA     NA \n10 Afrika Guinea      NA     NA     NA     NA    500  100     200   1500      0 \n# ℹ 167 more rows\n# ℹ 6 more variables: `2019` &lt;dbl&gt;, `2020` &lt;dbl&gt;, `2021` &lt;dbl&gt;, `2022` &lt;dbl&gt;,\n#   `2023` &lt;dbl&gt;, `2024` &lt;dbl&gt;\n\n\nData tersebut memiliki 17 variabel dan 177 baris. Variabel-variabelnya adalah benua, negara, dan realisasi penanaman modal (dalam ribuan dolar AS) dari tahun 2010 sampai 2024. Akan tetapi, nilai pada tahun 2024 tersebut belum utuh. Nilainya terhitung hanya sampai pada 30 Juni 2024.\nData kita tersebut bentuknya melebar. Kita buat data itu menjadi memanjang dengan menggunakan pivot_longer(). Karena tahun 2024 nilainya belum utuh, kita perlu memfilternya agar mengabaikan data pada tahun itu. Hal ini dilakukan dengan fungsi filter() dengan argumen tahun &lt; 2024. Namun, filter seperti itu mengharuskan nilai-nilai dalam variabel tahun jenisnya adalah integer (atau numerik). Untuk itu, kita modifikasi variabel tahun agar menjadi integer dengan fungsi mutate dan as.integer(). Kita lihat hasilnya dengan print().\n\nrealisasi_penanaman_modal &lt;- realisasi_penanaman_modal |&gt; \n  pivot_longer(\n    cols = starts_with(\"20\"),\n    names_to = \"tahun\",\n    values_to = \"nilai_investasi\"\n  ) |&gt; \n  mutate(tahun = as.integer(tahun)) |&gt; \n  filter(tahun &lt; 2024)\n\nprint(realisasi_penanaman_modal)\n\n# A tibble: 2,478 × 4\n   benua  negara         tahun nilai_investasi\n   &lt;chr&gt;  &lt;chr&gt;          &lt;int&gt;           &lt;dbl&gt;\n 1 Afrika Afrika Lainnya  2010              NA\n 2 Afrika Afrika Lainnya  2011              NA\n 3 Afrika Afrika Lainnya  2012              NA\n 4 Afrika Afrika Lainnya  2013              NA\n 5 Afrika Afrika Lainnya  2014              NA\n 6 Afrika Afrika Lainnya  2015              NA\n 7 Afrika Afrika Lainnya  2016              NA\n 8 Afrika Afrika Lainnya  2017              NA\n 9 Afrika Afrika Lainnya  2018               0\n10 Afrika Afrika Lainnya  2019              NA\n# ℹ 2,468 more rows\n\n\nSekarang data kita, realisasi_penanaman_modal, memiliki empat variabel dan 2.478 baris. Keempat variabel tersebut adalah benua, negara, tahun, dan nilai_investasi. Dari data tersebut, menarik untuk menyelidiki total investasi negara-negara berdasarkan benuanya.\nKita dapat melakukannya dengan mengelompokkan baris-baris dalam realisasi_penanaman_modal berdasarkan benua, kemudian meringkasnya untuk membuat variabel baru, yaitu total_investasi. Variabel tersebut merupakan jumlah, atau sum(), dari nilai-nilai dalam nilai_investasi dalam setiap kelompoknya. Agar mudah membaca hasilnya, kita dapat mengurutkan baris-barisnya berdasarkan nilai dalam variabel total_investasi dengan menggunakan arrange().\n\nrealisasi_penanaman_modal_benua &lt;- realisasi_penanaman_modal |&gt; \n  group_by(benua) |&gt; \n  summarise(\n    total_investasi = sum(nilai_investasi, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt; \n  arrange(-total_investasi)\n\nprint(realisasi_penanaman_modal_benua)\n\n# A tibble: 6 × 2\n  benua     total_investasi\n  &lt;chr&gt;               &lt;dbl&gt;\n1 Asia           286233096.\n2 Joint           41288935.\n3 Amerika         40521759.\n4 Eropa           39327051 \n5 Afrika           7185703.\n6 Australia        6471650.\n\n\nNegara-negara Asia memberikan investasi terbesar bagi Indonesia. Proporsinya adalah sekitar 68% dari keseluruhan.\n\nApabila ditotal, negara-negara dari Asia menanamkan modal terbesar dibandingkan dengan benua-benua lainnya (sekitar 68% dari keseluruhan).\n\nSekarang kita lihat tren realisasi penanaman modal setiap tahunnya. Kita dapat melakukannya dengan menggunakan kode yang serupa, tetapi pengelompokannya berdasarkan tahun.\n\nrealisasi_penanaman_modal_tahun &lt;- realisasi_penanaman_modal |&gt; \n  group_by(tahun) |&gt; \n  summarise(\n    total_investasi = sum(nilai_investasi, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nprint(realisasi_penanaman_modal_tahun)\n\n# A tibble: 14 × 2\n   tahun total_investasi\n   &lt;int&gt;           &lt;dbl&gt;\n 1  2010       16214772.\n 2  2011       19474532.\n 3  2012       24564670.\n 4  2013       28616270.\n 5  2014       28529698.\n 6  2015       29275941.\n 7  2016       28964075.\n 8  2017       32239752.\n 9  2018       29307908.\n10  2019       28208761.\n11  2020       28666272.\n12  2021       31093069 \n13  2022       45604963.\n14  2023       50267512.\n\n\nSecara umum, kita melihat adanya tren yang naik untuk nilai variabel total_investasi. Berapakah kenaikan setiap tahunnya? Untuk menjawabnya, kita dapat menambahkan variabel baru ke dalam data tersebut dengan mutate(). Misalnya, nama variabel tersebut adalah kenaikan_investasi. Nilai variabel tersebut diperoleh dengan mengurangi nilai total_investasi sebuah baris dengan nilai dalam baris sebelumnya. Untuk mendapatkan nilai pada baris sebelumnya, kita dapat menggunakan fungsi lag().\n\nrealisasi_penanaman_modal_tahun &lt;- realisasi_penanaman_modal_tahun |&gt; \n  mutate(\n    kenaikan_investasi = total_investasi - lag(total_investasi)\n  )\n\nprint(realisasi_penanaman_modal_tahun)\n\n# A tibble: 14 × 3\n   tahun total_investasi kenaikan_investasi\n   &lt;int&gt;           &lt;dbl&gt;              &lt;dbl&gt;\n 1  2010       16214772.                NA \n 2  2011       19474532.           3259759.\n 3  2012       24564670.           5090139.\n 4  2013       28616270.           4051600.\n 5  2014       28529698.            -86571.\n 6  2015       29275941.            746242.\n 7  2016       28964075.           -311866 \n 8  2017       32239752.           3275677 \n 9  2018       29307908.          -2931844.\n10  2019       28208761.          -1099147 \n11  2020       28666272.            457512.\n12  2021       31093069            2426797.\n13  2022       45604963.          14511894.\n14  2023       50267512.           4662549.\n\n\nBerapakah rerata kenaikan realisasi penanaman modal setiap tahunnya? Kita dapat menghitungnya dengan menggunakan mean() terhadap kolom kenaikan_investasi dalam data realisasi_penanaman_modal_tahun.\n\nrerata_kenaikan_investasi &lt;- mean(realisasi_penanaman_modal_tahun$kenaikan_investasi, na.rm = TRUE)\n\nprint(rerata_kenaikan_investasi)\n\n[1] 2619442\n\n\nJadi, secara rata-rata kenaikan realisasi penanaman modal dari tahun 2010 sampai 2023 adalah sekitar 2.619.442 (ribuan dolar AS) atau sekitar 2,6 milyar dolar AS per tahunnya.\n\nTerdapat tren yang naik untuk total realisasi penanaman modal asing dari berbagai negara. Mulai tahun 2010 sampai 2023, rerata kenaikannya sekitar 2,6 milyar dolar AS per tahunnya.\n\nTren realisasi penanaman modal tersebut ditunjukkan pada Gambar 2.\n\nKoderealisasi_penanaman_modal_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  geom_line() + \n  geom_point()\n\n\n\n\n\n\nGambar 2: Tren total realisasi penanaman modal asing setiap tahunnya\n\n\n\n\nBerdasarkan Gambar 2 tersebut, kita dapat melihat bahwa kenaikan realisasi penanaman modal yang paling besar berada pada rentang tahun 2021 – 2023. Rerata kenaikan pada periode tersebut kurang lebih 9,6 milyar dolar AS per tahun.\n\nKenaikan penanaman modal asing terbesar terjadi di antara tahun 2021 dan 2023."
  },
  {
    "objectID": "pos/2024-08-dirgahayu-indonesia/index.html#sec-memvisualisasikan-data",
    "href": "pos/2024-08-dirgahayu-indonesia/index.html#sec-memvisualisasikan-data",
    "title": "Dirgahayu Kemerdekaan Republik Indonesia",
    "section": "Memvisualisasikan Data",
    "text": "Memvisualisasikan Data\nSaatnya kita wartakan temuan-temuan yang telah kita dapatkan. Berdasarkan Bagian 1, kita menemukan tiga hal.\n\nApabila ditotal, negara-negara dari Asia menanamkan modal terbesar dibandingkan dengan benua-benua lainnya (sekitar 68% dari keseluruhan).\nTerdapat tren yang naik untuk total realisasi penanaman modal asing dari berbagai negara. Mulai tahun 2010 sampai 2023, rerata kenaikannya sekitar 2,6 milyar dolar AS per tahunnya.\nKenaikan penanaman modal asing terbesar terjadi di antara tahun 2021 dan 2023.\n\nKita akan menyampaikan ketiga pesan tersebut melalui sebuah diagram. Diagram apa yang cocok? Mungkin diagram batang cocok—diagram batang yang menunjukkan realisasi penanaman modal setiap tahunnya beserta dengan proporsi setiap benuanya.\nUntuk membuat diagram batang yang demikian, kita memerlukan data yang memiliki variabel benua dan tahun, serta nilai akumulasi dari realisasi penanaman modal untuk benua dan tahun yang bersangkutan.\nUntuk membuat data seperti itu, kita menggunakan data realisasi_penanaman_modal. Setelah itu, kita kelompokkan baris-baris dalam data tersebut menurut benua dan tahun untuk dihitung jumlah (sum()) nilai-nilai variabel nilai_investasi-nya. Kita namai data ini sebagai investasi_benua_tahun.\n\ninvestasi_benua_tahun &lt;- realisasi_penanaman_modal |&gt; \n  group_by(benua, tahun) |&gt; \n  summarise(\n    total_investasi = sum(nilai_investasi, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nprint(investasi_benua_tahun)\n\n# A tibble: 84 × 3\n   benua  tahun total_investasi\n   &lt;chr&gt;  &lt;int&gt;           &lt;dbl&gt;\n 1 Afrika  2010         149993.\n 2 Afrika  2011         202130.\n 3 Afrika  2012        1195699.\n 4 Afrika  2013         801737.\n 5 Afrika  2014         663936.\n 6 Afrika  2015         192825.\n 7 Afrika  2016         744869.\n 8 Afrika  2017        1288737.\n 9 Afrika  2018         373937.\n10 Afrika  2019         326860.\n# ℹ 74 more rows\n\n\nSekarang kita gunakan data investasi_benua_tahun tersebut untuk membuat diagram batang. Diagram batang tersebut ditunjukkan pada Gambar 3.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  geom_col(aes(fill = benua))\n\n\n\n\n\n\nGambar 3: Realisasi penanaman modal asing per tahun untuk setiap benua\n\n\n\n\nDiagram batang pada Gambar 3 tersebut telah dapat menyampaikan tiga temuan kita. Akan tetapi, diagram tersebut mungkin terasa belum cukup meyakinkan. Diagram tersebut juga kurang sejalan dengan elemen grafis perayaan HUT ke-79 RI. Berdasarkan pedoman identitas visualnya, elemen grafis tersebut ditunjukkan pada Gambar 4.\n\n\n\n\n\nGambar 4: Elemen grafis peringatan HUT ke-79 RI\n\n\nElemen grafis pada Gambar 4 tersebut melambangkan aliran sungai. Harapannya, negara akan terus berkembang mengikuti zaman seperti sifat sungai.\nBerdasarkan harapan itu, kita dapat menggunakan diagram alir. Diagram seperti ini dapat kita buat dengan menggunakan fungsi geom_stream() dari paket {ggstream}. Diagram alirnya dapat dilihat pada Gambar 5.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  geom_stream(aes(fill = benua))\n\n\n\n\n\n\nGambar 5: Diagram alir sederhana yang menunjukkan realisasi penanaman modal asing per tahun untuk setiap benua\n\n\n\n\nAgar terlihat lebih bersih, kita hilangkan latar belakang plotnya. Hal ini dapat kita lakukan dengan memilih tema theme_void(). Warna yang merepresentasikan benua-benuanya juga dapat kita ganti. Untuk itu, kita perlu mengetahui apa saja benua-benua yang ada dalam data kita.\n\nunique(investasi_benua_tahun$benua)\n\n[1] \"Afrika\"    \"Amerika\"   \"Asia\"      \"Australia\" \"Eropa\"     \"Joint\"    \n\n\nTernyata ada lima benua (yaitu Afrika, Amerika, Asia, Australia, dan Eropa) serta satu kelompok dengan nama Joint. Kelompok Joint ini merupakan gabungan dari beberapa negara (tidak harus dalam satu benua).\nKita pilih warna untuk keenam kelompok tersebut. Agar warnanya sesuai dengan tema peringatan kemerdekaan Republik Indonesia, kita pilih warna-warnanya adalah #900C3F, #C70039, #FF5733, #FF8D1A, #FFC300, dan grey85. Kita petakan warna-warna ini ke nama kelompok-kelompoknya. Kita namai pemetaan tersebut dengan warna_benua.\n\nwarna_benua &lt;- c(\n  \"Asia\" = \"#900C3F\",\n  \"Amerika\" = \"#FFC300\",\n  \"Eropa\" = \"#C70039\",\n  \"Afrika\" = \"#FF5733\",\n  \"Australia\" = \"#ff8d1a\",\n  \"Joint\" = \"grey85\"\n)\n\nSekarang kita modifikasi diagram pada Gambar 5. Hasilnya seperti tampak pada Gambar 6.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  geom_stream(aes(fill = benua)) + \n  scale_y_continuous(limits = c(-6e+07, 6e+07)) + \n  scale_fill_manual(\n    values = warna_benua\n  ) + \n  theme_void()\n\n\n\n\n\n\nGambar 6: Diagram alir setelah dimodifikasi tema dan warnanya\n\n\n\n\nKita perbaiki lagi diagram pada Gambar 6 tersebut. Apakah kamu punya ide perbaikannya seperti apa?\nPertama, kita hilangkan legendanya. Kedua, kita buat teks untuk sumbu-\\(x\\) secara manual. Agar teksnya nanti kelihatan rapi, kita juga perlu mengatur ulang batas-batas jendela grafiknya. Selain itu, kita perlu mengatur agar grafiknya lebih mepet ke kiri dan kanan. Hasil eksekusi ide ini ditunjukkan pada Gambar 7.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  # Layer teks pada sumbu-x\n  geom_segment(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = 0, yend = -5e+07),\n    linewidth = .5,\n    linetype = \"dashed\",\n    alpha = .4\n  ) +\n  geom_text(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = -5.5e+07, label = tahun),\n    size = 3\n  ) + \n  # Layer diagram alir\n  geom_stream(aes(fill = benua)) + \n  # Pembatas jendela grafik\n  scale_y_continuous(limits = c(-6e+07, 6e+07)) + \n  # Pewarnaan manual\n  scale_fill_manual(\n    values = warna_benua\n  ) + \n  # Pengaturan bidang koordinat\n  coord_cartesian(expand = FALSE) + \n  # Pemilihan tema\n  theme_void() + \n  # Pengaturan tema\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\nGambar 7: Diagram alir setelah diberikan teks untuk sumbu-\\(x\\)\n\n\n\n\nApa selanjutnya? Agar diagram pada Gambar 7 tersebut jelas menyampaikan informasi apa, kita perlu menambahkan judul dan anak judul. Karena tadi kita telah menghapus legendanya, informasi legenda tersebut dapat kita masukkan ke dalam anak judul tersebut. Selain itu, kita juga dapat menambakan takarir ke dalam diagram tersebut. Takarir tersebut dapat menginformasikan sumber data yang kita gunakan. Untuk itu, kita siapkan judul, anak judul, dan takarirnya.\n\njudul &lt;- \"Realisasi Penanaman Modal Asing\"\nanak_judul &lt;- \"Terdapat tren yang naik untuk total realisasi penanaman modal asing dari berbagai negara dari benua &lt;span style='color:#900C3F'&gt;&lt;b&gt;Asia,&lt;/b&gt;&lt;/span&gt; &lt;span style='color:#FFC300'&gt;&lt;b&gt;Amerika,&lt;/b&gt;&lt;/span&gt; &lt;span style='color:#C70039'&gt;&lt;b&gt;Eropa,&lt;/b&gt;&lt;/span&gt; &lt;span style='color:#FF5733'&gt;&lt;b&gt;Afrika,&lt;/b&gt;&lt;/span&gt; dan &lt;span style='color:#FF8D1a'&gt;&lt;b&gt;Australia.&lt;/b&gt;&lt;/span&gt; Mulai tahun 2010 sampai 2023, rerata kenaikannya sekitar 2,6 milyar dolar AS per tahunnya.\"\ntakarir &lt;- \"Data: Kementerian Investasi/BKPM\"\n\nSetelah judul, anak_judul, dan takarir siap, kita dapat menambahkannya ke dalam diagram alirnya. Hasilnya ditunjukkan pada Gambar 8.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  # Layer teks pada sumbu-x\n  geom_segment(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = 0, yend = -5e+07),\n    linewidth = .5,\n    linetype = \"dashed\",\n    alpha = .4\n  ) +\n  geom_text(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = -5.5e+07, label = tahun),\n    size = 3\n  ) + \n  # Layer diagram alir\n  geom_stream(aes(fill = benua)) + \n  # Pembatas jendela grafik\n  scale_y_continuous(limits = c(-6e+07, 6e+07)) + \n  # Pewarnaan manual\n  scale_fill_manual(\n    values = warna_benua\n  ) + \n  # Pengaturan bidang koordinat\n  coord_cartesian(expand = FALSE) + \n  # Pemilihan tema\n  theme_void() + \n  # Pengaturan tema\n  theme(\n    legend.position = \"none\",\n    plot.title = element_textbox_simple(\n      size = 20,\n      face = \"bold\",\n      margin = margin(t = 10, r = 20, b = 5, l = 20)\n    ),\n    plot.subtitle = element_textbox_simple(\n      margin = margin(t = 0, r = 20, b = 5, l = 20)\n    ),\n    plot.caption = element_textbox_simple(\n      margin = margin(t = 5, r = 20, b = 10, l = 20)\n    )\n  ) + \n  labs(\n    title = judul,\n    subtitle = anak_judul,\n    caption = takarir\n  )\n\n\n\n\n\n\nGambar 8: Diagram alir setelah diberikan judul, anak judul, dan takarir\n\n\n\n\nDiagram alir yang ditunjukkan pada Gambar 8 sudah menawan. Akan tetapi, belum semua pesan yang kita temukan di Bagian 1 tersampaikan. Untuk itu, kita perlu menambahkan label pada diagram tersebut. Terlebih dahulu kita siapkan label-label tersebut.\n\npesan_1 &lt;- \"&lt;b&gt;Penanam modal terbesar&lt;/b&gt;&lt;br&gt;Apabila ditotal, negara-negara dari Asia menanamkan modal terbesar dibandingkan dengan benua-benua lainnya (sekitar 68% dari keseluruhan).\"\npesan_2 &lt;- \"&lt;b&gt;Kenaikan terbesar&lt;/b&gt;&lt;br&gt;Kenaikan penanaman modal asing terbesar terjadi di antara tahun 2021 dan 2023.\"\n\nLabel-label sudah siap. Kita masukkan kedua label tersebut (yaitu pesan_1 dan pesan_2) ke dalam diagram alirnya. Hasilnya disajikan pada Gambar 9.\n\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  # Layer teks pada sumbu-x\n  geom_segment(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = 0, yend = -5e+07),\n    linewidth = .5,\n    linetype = \"dashed\",\n    alpha = .4\n  ) +\n  geom_text(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = -5.5e+07, label = tahun),\n    size = 3\n  ) + \n  # Layer pesan 1\n  geom_segment(\n    x = 2015.05,\n    y = 5e+07,\n    yend = 0,\n    linewidth = 1\n  ) +\n  geom_textbox(\n    x = 2015,\n    y = 5e+07,\n    label = pesan_1,\n    vjust = 0.95,\n    size = 3,\n    lineheight = 1,\n    hjust = 1,\n    halign = 1,\n    box.colour = \"transparent\",\n    fill = \"transparent\",\n    width = .38\n  ) + \n  # Layer pesan 2\n  geom_segment(\n    x = 2022.55,\n    y = 5.5e+07,\n    yend = 0,\n    linewidth = 1\n  ) + \n  geom_textbox(\n    x = 2022.5,\n    y = 5.5e+07,\n    label = pesan_2,\n    vjust = 0.95,\n    size = 3,\n    lineheight = 1,\n    hjust = 1,\n    halign = 1,\n    box.colour = \"transparent\",\n    fill = \"transparent\",\n    width = .3\n  ) + \n  # Layer diagram alir\n  geom_stream(aes(fill = benua)) + \n  # Pembatas jendela grafik\n  scale_y_continuous(limits = c(-6e+07, 6e+07)) + \n  # Pewarnaan manual\n  scale_fill_manual(\n    values = warna_benua\n  ) + \n  # Pengaturan bidang koordinat\n  coord_cartesian(expand = FALSE) + \n  # Pemilihan tema\n  theme_void() + \n  # Pengaturan tema\n  theme(\n    legend.position = \"none\",\n    plot.title = element_textbox_simple(\n      size = 20,\n      face = \"bold\",\n      margin = margin(t = 10, r = 20, b = 5, l = 20),\n      lineheight = 1\n    ),\n    plot.subtitle = element_textbox_simple(\n      margin = margin(t = 0, r = 20, b = 5, l = 20),\n      lineheight = 1\n    ),\n    plot.caption = element_textbox_simple(\n      margin = margin(t = 5, r = 20, b = 10, l = 20),\n      lineheight = 1\n    )\n  ) + \n  labs(\n    title = judul,\n    subtitle = anak_judul,\n    caption = takarir\n  )\n\n\n\n\n\n\nGambar 9: Diagram alir setelah diberikan label yang menyampaikan pesan-pesan utama\n\n\n\n\nDiagram alir pada Gambar 9 tersebut telah menyampaikan temuan-temuan yang kita dapatkan pada Bagian 1. Diagram tersebut juga sudah tampak indah dan sejalan dengan harapan-harapan Indonesia tentang pertumbuhan ekonomi dan perkembangan bangsa Indonesia yang mengikuti zaman."
  },
  {
    "objectID": "pos/2024-08-dirgahayu-indonesia/index.html#sec-visualisasi-lebih-lanjut",
    "href": "pos/2024-08-dirgahayu-indonesia/index.html#sec-visualisasi-lebih-lanjut",
    "title": "Dirgahayu Kemerdekaan Republik Indonesia",
    "section": "Visualisasi Lebih Lanjut",
    "text": "Visualisasi Lebih Lanjut\nKita masih dapat memodifikasi diagram alir pada Gambar 9. Paling tidak ada dua hal yang dapat kita lakukan:\n\nmengganti jenis dan warna fonnya, dan\nmengatur ukuran dan resolusi fail gambarnya.\n\nUntuk melakukannya kita dapat menggunakan paket {showtext} dan {camcorder}. Paket {showtext} akan memudahkan kita untuk menggunakan berbagai macam jenis fon pada diagram kita nanti.\nFungsi paket {camcorder} sebenarnya untuk merekam sejarah diagram-diagram yang kita buat. Akan tetapi, di sini kita menggunakan paket tersebut untuk memastikan tampilan diagram pada fail gambar yang kita hasilkan nanti persis sama dengan diagram luaran R. Sebagai ilustrasi, jika kita menjalankan baris kode yang menghasilkan Gambar 9, kita akan mendapatkan tampilan seperti pada Gambar 10 (a). Akan tetapi, jika kita simpan diagram tersebut dengan ukuran 1280 px × 960 px, kita mendapatkan fail gambar yang tampilannya seperti pada Gambar 10 (b). Perbedaan yang mencolok dari kedua diagram tersebut adalah ukuran fonnya. Agar tampilan diagram kita konsisten, kita akan menggunakan fungsi-fungsi dari paket {camcorder}.\n\n\n\n\n\n\n\n\n\n(a) Tampilan diagram pada jendela Plots di RStudio\n\n\n\n\n\n\n\n\n\n(b) Tampilan diagram yang sama setelah disimpan dengan ukuran 1280 px × 960 px\n\n\n\n\n\n\nGambar 10: Perbedaan tampilan diagram\n\n\nJika kedua paket tersebut belum terinstal, silakan instal paket-paket tersebut dengan fungsi install.packages(). Jika sudah terinstal, mari kita panggil kedua paket tersebut.\nlibrary(showtext)\nlibrary(camcorder)\nMisalnya kita akan membuat sebuah gambar png yang berukuran 1280 px × 960 px dan memiliki kedalaman gambar 72 dpi. Kita gunakan fungsi gg_record() seperti pada baris kode di bawah. Argumen dir diisi dengan nama folder tempat kita menyimpan gambar yang akan dihasilkan.\ngg_record(\n  dir = \"rekaman/\",\n  device = \"png\",\n  width = 1280,\n  height = 960,\n  units = \"px\",\n  dpi = 72\n)\nSelanjutnya kita akan mengganti jenis dan warna fonnya. Untuk jenis fon, kita pilih fon Lato. Fon ini tersedia secara gratis di Google Fonts. Fon Lato tersebut dapat diimpor dengan menggunakan fungsi font_add_google(). Untuk menggunakan fungsi-fungsi {showtext} secara otomatis, kita perlu memanggil fungsi showtext_auto(). Untuk warna teks, kita pilih #343A40 agar tidak terlalu kontras.\n# Mengimpor fon dan menyalakan fungsi-fungsi {showtext}\nfont_add_google(\"Lato\", \"lato\")\nshowtext_auto()\n\n#' Membuat variabel `fon_judul` dan `fon_batang_tubuh`\n#' untuk digunakan di tahap berikutnya\nfon_judul &lt;- \"lato\"\nfon_batang_tubuh &lt;- \"lato\"\n\n# Menentukan `warna_teks`\nwarna_teks &lt;- \"#343A40\"\nSekarang waktunya kita beraksi untuk melakukan visualisasi data. Kita modifikasi kode-kode yang digunakan untuk membuat diagram alir pada Gambar 9. Misalnya, hasil modifikasi tersebut adalah sebagai berikut.\ninvestasi_benua_tahun |&gt; \n  ggplot(aes(x = tahun, y = total_investasi)) + \n  # Layer teks pada sumbu-x\n  geom_segment(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    aes(x = tahun, y = 0, yend = -5e+07),\n    linewidth = 1,\n    linetype = \"dashed\",\n    alpha = .4,\n    colour = warna_teks\n  ) +\n  geom_text(\n    data = data.frame(tahun = seq(2012, 2022, 2)),\n    mapping = aes(x = tahun, y = -5.5e+07, label = tahun),\n    colour = warna_teks,\n    family = fon_batang_tubuh,\n    size = 6\n  ) + \n  # Layer pesan 1\n  geom_segment(\n    x = 2015.1,\n    y = 4.5e+07,\n    yend = 0,\n    colour = warna_teks,\n    linewidth = 1.5\n  ) +\n  geom_textbox(\n    x = 2015,\n    y = 4.5e+07,\n    label = pesan_1,\n    colour = warna_teks,\n    family = fon_batang_tubuh,\n    vjust = 0.95,\n    size = 6,\n    lineheight = 1.5,\n    hjust = 1,\n    halign = 1,\n    box.colour = \"transparent\",\n    fill = \"transparent\",\n    width = .35\n  ) + \n  # Layer pesan 2\n  geom_segment(\n    x = 2022.6,\n    y = 5.5e+07,\n    yend = 0,\n    colour = warna_teks,\n    linewidth = 1.5\n  ) + \n  geom_textbox(\n    x = 2022.5,\n    y = 5.5e+07,\n    label = pesan_2,\n    colour = warna_teks,\n    family = fon_batang_tubuh,\n    vjust = 0.95,\n    size = 6,\n    lineheight = 1.5,\n    hjust = 1,\n    halign = 1,\n    box.colour = \"transparent\",\n    fill = \"transparent\",\n    width = .3\n  ) + \n  # Layer diagram alir\n  geom_stream(\n    aes(fill = benua)\n  ) + \n  # Pembatas jendela grafik\n  scale_y_continuous(limits = c(-6e+07, 6e+07)) + \n  # Pewarnaan manual\n  scale_fill_manual(\n    values = warna_benua\n  ) + \n  # Pengaturan bidang koordinat\n  coord_cartesian(expand = FALSE) + \n  # Pemilihan tema\n  theme_void(base_size = 24, base_family = fon_batang_tubuh) + \n  # Pengaturan tema\n  theme(\n    legend.position = \"none\",\n    plot.margin = margin(5, 5, 5, 0),\n    plot.background = element_rect(\n      fill = \"white\", colour = \"white\"\n    ),\n    panel.background = element_rect(\n      fill = \"white\", colour = \"white\"\n    ),\n    plot.title = element_textbox_simple(\n      colour = warna_teks,\n      hjust = 0,\n      halign = 0,\n      margin = margin(t = 30, r = 20, b = 5, l = 30),\n      lineheight = 1.5,\n      family = fon_judul,\n      face = \"bold\",\n      size = 40\n    ),\n    plot.subtitle = element_textbox_simple(\n      colour = warna_teks,\n      hjust = 0,\n      halign = 0,\n      margin = margin(t = 5, r = 20, b = 15, l = 30),\n      lineheight = 1.5,\n      family = fon_batang_tubuh\n    ),\n    plot.caption = element_textbox_simple(\n      colour = warna_teks,\n      hjust = 0,\n      halign = 0,\n      margin = margin(l = 30, b = 20, t = 10),\n      lineheight = 1.5,\n      family = fon_batang_tubuh\n    )\n  ) + \n  # Pemberian judul, anak judul, dan takarir\n  labs(\n    title = judul,\n    subtitle = anak_judul,\n    caption = takarir\n  )\nSetelah baris kode di atas dijalankan, kita akan mendapatkan diagram alir seperti yang ditunjukkan pada Gambar 11.\n\n\n\n\n\nGambar 11: Versi terakhir diagram alir yang menunjukkan tren kenaikan realisasi penanaman modal asing ke Indonesia\n\n\nFail gambar pada Gambar 11 tersebut dapat ditemukan dalam folder yang kita inputkan pada argumen dir dalam fungsi gg_record() di atas. Untuk mengakhiri perekaman, kita gunakan fungsi gg_stop_recording().\ngg_stop_recording()"
  },
  {
    "objectID": "pos/2024-08-dirgahayu-indonesia/index.html#sec-catatan-akhir",
    "href": "pos/2024-08-dirgahayu-indonesia/index.html#sec-catatan-akhir",
    "title": "Dirgahayu Kemerdekaan Republik Indonesia",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nPada bulan Agustus, semua bangsa Indonesia memperingati kemerdekaan Republik Indonesia. Banyak cara yang dapat dilakukan. Salah satu cara yang kita lakukan adalah memberikan persembahan visualisasi data yang bertemakan pertumbuhan ekonomi nasional. Hal itu kita lakukan pada Bagian 2. Diagram alir pada Gambar 9 atau Gambar 11 tidak hanya menunjukkan tren pertumbuhan ekonomi Indonesia, tetapi juga sejalan dengan semangat perkembangan bangsa Indonesia yang mengikuti zaman.\nPada pos-pos berikutnya, kamu akan melihat bagaimana Statistika dan Ilmu Data digunakan dalam merayakan HUT ke-79 Republik Indonesia. Di pos-pos tersebut, kamu akan melihat bagaimana memvisualisasikan prestasi sepak bola Indonesia dibandingkan dengan negara-negara Asia Tenggara lainnya. Selain itu, kamu juga akan melihat bagaimana torehan atlet-atlet hebat Indonesia di pagelaran olimpiade melalui Statistika dan Ilmu Data. Dirgahayu Republik Indonesia!"
  },
  {
    "objectID": "pos/2024-08-animasi-diagram-statistik/index.html",
    "href": "pos/2024-08-animasi-diagram-statistik/index.html",
    "title": "Membuat Diagram Lebih Hidup dengan Animasi",
    "section": "",
    "text": "Umumnya, diagram itu untuk menyampaikan pesan. Akibatnya, pembuatan diagram perlu disesuaikan dengan pesan yang perlu disampaikan. Nah, berdasarkan hal ini, mari kita tinjau kembali sebuah diagram pada pos sebelumnya. Gambar 1 menyajikan diagram yang dimaksud.\nGambar 1 sudah baik dalam menunjukkan seperti apa relasi antara PDB per kapita dan angka harapan hidup setiap negara pada tahun 2007. Akan tetapi, bagaimana jika kita ingin menunjukkan relasi tersebut pada tahun-tahun lainnya?\nMungkin kita langsung berpikir untuk memvisualisasikan relasi tersebut untuk setiap tahunnya. Dengan demikian, penyajian datanya seperti yang ditunjukkan pada Gambar 2.\nGambar 2: Relasi antara PDB per kapita dan angka harapan hidup setiap negara mulai tahun 1952 sampai 2007\nGambar 2 tersebut tampak sudah sesuai dengan pesan yang ingin kita sampaikan. Akan tetapi, gambar tersebut kurang efisien karena terlalu banyak memuat informasi. Apakah ada metode yang lebih efisien?\nPenggunaan animasi adalah salah satu solusinya. Pembuatan animasi tersebut dapat dilakukan di R dengan menggunakan paket {gganimate}. Tak perlu berlama-lama, mari kita panggil paket tersebut bersamaan dengan paket {tidyverse}. Paket {tidyverse} tersebut berguna untuk mengimpor, mengolah, dan memvisualisasikan data. Sebagai tambahan, sebaiknya dalam R kita juga sudah terinstal paket {gifski}. Paket ini digunakan untuk merender animasi kita nanti menjadi fail gif.\nlibrary(tidyverse)\nlibrary(gganimate)"
  },
  {
    "objectID": "pos/2024-08-animasi-diagram-statistik/index.html#sec-kreasi-animasi",
    "href": "pos/2024-08-animasi-diagram-statistik/index.html#sec-kreasi-animasi",
    "title": "Membuat Diagram Lebih Hidup dengan Animasi",
    "section": "Mengkreasi Animasi",
    "text": "Mengkreasi Animasi\nKita impor dan olah data Gapminder seperti pada pos sebelumnya. Baris kode yang digunakan adalah sebagai berikut.\n\n# Impor data `gapminder`\nload(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\"))\n\n# Menerjemahkan nama benua\nterjemahan_benua &lt;- c(\n  \"Asia\" = \"Asia\",\n  \"Europe\" = \"Eropa\",\n  \"Africa\" = \"Afrika\",\n  \"Americas\" = \"Amerika\",\n  \"Oceania\" = \"Oseania\"\n)\ngapminder &lt;- gapminder |&gt; \n  mutate(\n    continent = recode(continent, !!!terjemahan_benua)\n  )\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\nData gapminder sudah siap. Sekarang waktunya untuk membuat animasi. Berikut ini adalah baris kodenya.\n\nanim &lt;- gapminder |&gt; \n  ggplot(\n    aes(x = gdpPercap, y = lifeExp)\n  ) + \n  geom_point(\n    aes(color = continent, size = pop),\n    alpha = .6\n  ) + \n  scale_size(\n    range = c(1, 20),\n    guide = \"none\"\n  ) + \n  scale_color_viridis_d(name = \"Benua\") + \n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\",\n    plot.title = element_text(face = \"bold\")\n  ) + \n  # Penggunaan {gganimate} mulai dari sini\n  labs(\n    title = \"Tahun: {frame_time}\",\n    x = \"PDB per kapita\",\n    y = \"Angka harapan hidup\"\n  ) + \n  transition_time(year) + \n  ease_aes(\"linear\")\n\nanim\n\n\n\n\n\n\nGambar 3: Relasi antara PDB per kapita dan angka harapan hidup setiap tahunnya, disajikan dengan animasi\n\n\n\n\nDari baris kode di atas, kita menggunakan dua fungsi dari {gganimate}. Kedua fungsi tersebut adalah transition_time() dan ease_aes(). Fungsi transition_time() berfungsi untuk membagi data kita berdasarkan kolom/variabel waktu tertentu. Karena data gapminder memiliki variabel waktu year, kita masukkan variabel ini ke dalam fungsi tersebut.\nFungsi transition_time() menghasilkan variabel frame_time. Variabel ini kita masukkan ke dalam judul diagram agar judul tersebut berubah-ubah di sepanjang animasinya, perhatikan bagian kiri atas Gambar 3. Penulisan variabel ini ke dalam judul perlu kita masukkan ke dalam kurung kurawal { } agar terbaca sebagai variabel.\nFungsi ease_aes() mengatur bagaimana perubahan variabel year. Pilihan dalam fungsi ini antara lain quadratic, cubic, dan quartic. Bawaannya, argumen awal fungsi ini adalah linear."
  },
  {
    "objectID": "pos/2024-08-animasi-diagram-statistik/index.html#sec-simpan-animasi",
    "href": "pos/2024-08-animasi-diagram-statistik/index.html#sec-simpan-animasi",
    "title": "Membuat Diagram Lebih Hidup dengan Animasi",
    "section": "Menyimpan Animasi",
    "text": "Menyimpan Animasi\nSetelah animasi sudah jadi, saatnya kita simpan animasi tersebut. Sebelum kita menyimpannya, kita perlu merender animasi tersebut. Kita dapat merendernya dengan menggunakan animate() dan mengisikan argumen renderer = gifski_renderer() apabila ingin merendernya menjadi fail gif. Untuk menyimpan hasil animasinya, kita menggunakan fungsi anim_save().\n# Merender animasi\nanimate(\n  plot = anim,\n  renderer = gifski_renderer()\n)\n\n# Menyimpan animasi\nanim_save(\n  file = \"anim_pdb_harapan_hidup.gif\"\n)\nKetika menggunakan fungsi animate() dalam merender animasi, kita dapat mengatur beberapa argumen. Misalnya, nframes, fps, dan duration. Untuk lebih jelasnya, silakan kunjungi laman referensinya."
  },
  {
    "objectID": "pos/2024-08-animasi-diagram-statistik/index.html#catatan-akhir",
    "href": "pos/2024-08-animasi-diagram-statistik/index.html#catatan-akhir",
    "title": "Membuat Diagram Lebih Hidup dengan Animasi",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah dapat menyajikan data yang kompleks secara sederhana dengan animasi. Dalam R, kita dapat menggunakan paket {gganimate}. Dengan paket tersebut, kita dapat membuat objek animasi. Hal ini telah didemonstrasikan pada Bagian 1. Selanjutnya, kita dapat merender objek animasi tersebut dan menyimpannya ke dalam sebuah fail. Hal ini telah dipaparkan pada Bagian 2.\nAnimasi tetap memiliki kekurangan. Kita hanya bisa melihat animasi tersebut, tanpa melakukan interaksi. Apakah kita dapat membuat diagram yang tak hanya efisien, tetapi juga interaktif? Iya, kita dapat membuat diagram yang interaktif dengan R. Untuk mengetahui caranya, silakan pantau pos selanjutnya."
  },
  {
    "objectID": "pos/2024-07-anomali-suhu-global/index.html",
    "href": "pos/2024-07-anomali-suhu-global/index.html",
    "title": "Tren Suhu Planet Bumi",
    "section": "",
    "text": "Beberapa waktu lalu aku mendiskusikan ide Matematika Membumi. Diskusi dalam webinar YPMIPA tersebut membahas sebuah desain pembelajaran yang menggunakan data riil, yaitu data tren suhu global planet bumi dari tahun ke tahun.\nIde seperti itu sebenarnya sudah aku pikirkan dan implementasikan kurang lebih pada tahun 2019. Pada tahun itu, aku mencoba mengajak para mahasiswa calon pendidik matematika tak hanya untuk bermatematika saja, tetapi juga memiliki kesadaran akan pembangunan berkelanjutan. Keseruannya dapat dilihat pada pos media sosial berikut.\nDi artikel ini, kita tidak akan membahas desain pembelajaran tersebut. Melainkan, kita akan mengetahui bagaimana mendapatkan data tren suhu planet bumi tersebut, mengolahnya, dan memvisualisasikannya. Seluruh proses ini akan kita lakukan dengan menggunakan R."
  },
  {
    "objectID": "pos/2024-07-anomali-suhu-global/index.html#sec-impor-data",
    "href": "pos/2024-07-anomali-suhu-global/index.html#sec-impor-data",
    "title": "Tren Suhu Planet Bumi",
    "section": "Data Tren Suhu Global",
    "text": "Data Tren Suhu Global\nBanyak situs web yang menyediakan data tren suhu global. Salah satunya adalah GISTEMP. Dari situs web itu, kita memilih data gabungan antara anomali suhu udara daratan dan anomali suhu air lautan. Apa itu anomali suhu? Anomali suhu merupakan selisih terhadap suhu rata-rata atau garis dasar. Di situs GISTEMP, garis dasar yang digunakan adalah rata-rata suhu pada periode 1951 - 1980.\nLangkah awal sebelum kita melakukan proses berikutnya adalah memanggil paket {tidyverse}. Paket tersebut menyediakan berbagai macam fungsi yang akan kita gunakan untuk mencapai tujuan kita.\n\nlibrary(tidyverse)\n\nTak perlu berlama-lama, mari kita impor data tersebut dengan fungsi read_csv() dari paket {tidyverse}. Alamat fail yang akan kita impor adalah https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv. Baris pertama dalam fail tersebut merupakan keterangan “Land-Ocean: Global Means”. Dengan demikian, kita perlu menambahkan argumen skip = 1 dalam fungsi read_csv() agar data kita tidak memuat baris tersebut. Fail tersebut juga menggunakan simbol *** sebagai penanda NA. Untuk itu, kita juga perlu menambahkan argumen na = \"***\" ke dalam fungsi tersebut. Kita namai data kita tersebut dengan tren_suhu_global.\n\ntren_suhu_global &lt;- read_csv(\n  \"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\",\n  skip = 1,\n  na = \"***\"\n)\n\nSekarang kita memiliki data tren_suhu_global. Untuk melihat beberapa baris awal data tersebut, kita dapat menggunakan fungsi head().\n\nhead(tren_suhu_global)\n\n# A tibble: 6 × 19\n   Year   Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  1880 -0.19 -0.25 -0.09 -0.16 -0.1  -0.21 -0.18 -0.1  -0.15 -0.24 -0.22 -0.18\n2  1881 -0.2  -0.14  0.03  0.05  0.06 -0.19  0    -0.03 -0.15 -0.22 -0.19 -0.07\n3  1882  0.16  0.14  0.04 -0.17 -0.14 -0.23 -0.16 -0.07 -0.14 -0.24 -0.17 -0.36\n4  1883 -0.29 -0.36 -0.12 -0.18 -0.17 -0.07 -0.06 -0.13 -0.21 -0.11 -0.23 -0.11\n5  1884 -0.13 -0.07 -0.35 -0.4  -0.33 -0.35 -0.3  -0.27 -0.27 -0.25 -0.33 -0.31\n6  1885 -0.58 -0.34 -0.27 -0.42 -0.45 -0.43 -0.33 -0.31 -0.28 -0.23 -0.24 -0.1 \n# ℹ 6 more variables: `J-D` &lt;dbl&gt;, `D-N` &lt;dbl&gt;, DJF &lt;dbl&gt;, MAM &lt;dbl&gt;,\n#   JJA &lt;dbl&gt;, SON &lt;dbl&gt;\n\n\nKita juga dapat menggunakan fungsi glimpse() dari {tidyverse} untuk melihat gambaran umum dari data tersebut.\n\nglimpse(tren_suhu_global)\n\nRows: 146\nColumns: 19\n$ Year  &lt;dbl&gt; 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890…\n$ Jan   &lt;dbl&gt; -0.19, -0.20, 0.16, -0.29, -0.13, -0.58, -0.44, -0.72, -0.34, -0…\n$ Feb   &lt;dbl&gt; -0.25, -0.14, 0.14, -0.36, -0.07, -0.34, -0.51, -0.57, -0.36, 0.…\n$ Mar   &lt;dbl&gt; -0.09, 0.03, 0.04, -0.12, -0.35, -0.27, -0.43, -0.35, -0.41, 0.0…\n$ Apr   &lt;dbl&gt; -0.16, 0.05, -0.17, -0.18, -0.40, -0.42, -0.28, -0.35, -0.21, 0.…\n$ May   &lt;dbl&gt; -0.10, 0.06, -0.14, -0.17, -0.33, -0.45, -0.24, -0.31, -0.22, -0…\n$ Jun   &lt;dbl&gt; -0.21, -0.19, -0.23, -0.07, -0.35, -0.43, -0.34, -0.25, -0.17, -…\n$ Jul   &lt;dbl&gt; -0.18, 0.00, -0.16, -0.06, -0.30, -0.33, -0.18, -0.26, -0.11, -0…\n$ Aug   &lt;dbl&gt; -0.10, -0.03, -0.07, -0.13, -0.27, -0.31, -0.31, -0.35, -0.15, -…\n$ Sep   &lt;dbl&gt; -0.15, -0.15, -0.14, -0.21, -0.27, -0.28, -0.24, -0.26, -0.12, -…\n$ Oct   &lt;dbl&gt; -0.24, -0.22, -0.24, -0.11, -0.25, -0.23, -0.28, -0.35, 0.01, -0…\n$ Nov   &lt;dbl&gt; -0.22, -0.19, -0.17, -0.23, -0.33, -0.24, -0.28, -0.26, 0.03, -0…\n$ Dec   &lt;dbl&gt; -0.18, -0.07, -0.36, -0.11, -0.31, -0.10, -0.25, -0.33, -0.04, -…\n$ `J-D` &lt;dbl&gt; -0.17, -0.09, -0.11, -0.17, -0.28, -0.33, -0.31, -0.36, -0.18, -…\n$ `D-N` &lt;dbl&gt; NA, -0.10, -0.09, -0.19, -0.26, -0.35, -0.30, -0.36, -0.20, -0.0…\n$ DJF   &lt;dbl&gt; NA, -0.17, 0.08, -0.34, -0.10, -0.41, -0.35, -0.51, -0.34, 0.01,…\n$ MAM   &lt;dbl&gt; -0.12, 0.05, -0.09, -0.15, -0.36, -0.38, -0.32, -0.34, -0.28, 0.…\n$ JJA   &lt;dbl&gt; -0.16, -0.07, -0.15, -0.09, -0.31, -0.36, -0.28, -0.29, -0.14, -…\n$ SON   &lt;dbl&gt; -0.20, -0.18, -0.18, -0.18, -0.28, -0.25, -0.26, -0.29, -0.03, -…\n\n\nDari luaran fungsi tersebut, kita dapat melihat bahwa data kita memuat 145 baris dan 19 kolom. Informasi ini berguna untuk proses berikutnya."
  },
  {
    "objectID": "pos/2024-07-anomali-suhu-global/index.html#sec-gulat-data",
    "href": "pos/2024-07-anomali-suhu-global/index.html#sec-gulat-data",
    "title": "Tren Suhu Planet Bumi",
    "section": "Bergulat dengan Data",
    "text": "Bergulat dengan Data\nGulat tidak hanya dilombakan di olimpiade #Paris2024, tetapi juga umum dilakukan terhadap data. Sekarang kita akan bergulat dengan data. Seperti olahraga gulat yang menantang, bergulat dengan data juga tak kalah menantang. Akan tetapi, tantangan itu akan menghasilkan data yang rapi. Kita lakukan pergulatan ini setahap demi setahap.\nKetika kita menggunakan fungsi glimpse() sebelumnya, kita tahu bahwa data kita memuat 19 kolom. Kolom yang akan kita olah di sini adalah 13 kolom pertama. Untuk itu, pada tahap pertama, kita gunakan fungsi select() dari {tidyverse} untuk memilih ketigabelas kolom tersebut. Kita juga dapat mengganti nama kolom pertama yang awalnya Year menjadi tahun dengan menggunakan rename() dari {tidyverse}. Untuk melihat hasilnya kita dapat menggunakan fungsi head() lagi.\n\ntren_suhu_global &lt;- tren_suhu_global |&gt; \n  select(1:13) |&gt; \n  rename(tahun = Year)\n\nhead(tren_suhu_global)\n\n# A tibble: 6 × 13\n  tahun   Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct   Nov   Dec\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  1880 -0.19 -0.25 -0.09 -0.16 -0.1  -0.21 -0.18 -0.1  -0.15 -0.24 -0.22 -0.18\n2  1881 -0.2  -0.14  0.03  0.05  0.06 -0.19  0    -0.03 -0.15 -0.22 -0.19 -0.07\n3  1882  0.16  0.14  0.04 -0.17 -0.14 -0.23 -0.16 -0.07 -0.14 -0.24 -0.17 -0.36\n4  1883 -0.29 -0.36 -0.12 -0.18 -0.17 -0.07 -0.06 -0.13 -0.21 -0.11 -0.23 -0.11\n5  1884 -0.13 -0.07 -0.35 -0.4  -0.33 -0.35 -0.3  -0.27 -0.27 -0.25 -0.33 -0.31\n6  1885 -0.58 -0.34 -0.27 -0.42 -0.45 -0.43 -0.33 -0.31 -0.28 -0.23 -0.24 -0.1 \n\n\nSekarang kita mendapatkan data yang memuat 13 kolom. Kolom pertama merupakan tahun, kolom kedua sampai ketiga belas merupakan bulan Januari sampai Desember. Isi sel kolom kedua sampai ketigabelas merupakan anomali suhu.\nSampai di sini, aku teringat terhadap salah satu adegan di sebuah serial TV yang berjudul Friends. Dalam episode yang berjudul “The One with the Cop”, Ross meminta Chandler untuk mem-pivot sofa yang mereka angkat.\n\n\n\nPerintah Ross tersebut juga dapat diterapkan terhadap data kita. Kita dapat mem-pivot (memutar) data kita dengan menggunakan fungsi pivot_longer(). Dengan fungsi tersebut, data kita yang awalnya melebar akan berubah bentuknya menjadi data yang memanjang. Oleh karena itu, di tahap kedua, kita perlu memutar data kita agar menjadi data yang memanjang.\n\ntren_suhu_global &lt;- tren_suhu_global |&gt; \n  pivot_longer(\n    cols = 2:13,\n    names_to = \"bulan\",\n    values_to = \"anomali_suhu\"\n  )\n\nhead(tren_suhu_global)\n\n# A tibble: 6 × 3\n  tahun bulan anomali_suhu\n  &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n1  1880 Jan          -0.19\n2  1880 Feb          -0.25\n3  1880 Mar          -0.09\n4  1880 Apr          -0.16\n5  1880 May          -0.1 \n6  1880 Jun          -0.21\n\n\nMengapa kita memerlukan data yang memanjang? Data memanjang tersebut akan memudahkan kita untuk mengolahnya pada tahapan berikutnya.\nTahap ketiga, kita perlu menggabungkan nilai sel dalam kolom pertama dan kedua untuk membuat sebuah kolom baru, yaitu tanggal, yang formatnya Date.\n\npemetaan_bulan &lt;- c(\n  \"Jan\" = \"01\",\n  \"Feb\" = \"02\",\n  \"Mar\" = \"03\",\n  \"Apr\" = \"04\",\n  \"May\" = \"05\",\n  \"Jun\" = \"06\",\n  \"Jul\" = \"07\",\n  \"Aug\" = \"08\",\n  \"Sep\" = \"09\",\n  \"Oct\" = \"10\",\n  \"Nov\" = \"11\",\n  \"Dec\" = \"12\"\n)\n\ntren_suhu_global &lt;- tren_suhu_global |&gt; \n  mutate(\n    tanggal = as.Date(\n      paste(tahun, pemetaan_bulan[bulan], \"01\", sep = \"-\")\n    )\n  )\n\nhead(tren_suhu_global)\n\n# A tibble: 6 × 4\n  tahun bulan anomali_suhu tanggal   \n  &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;    \n1  1880 Jan          -0.19 1880-01-01\n2  1880 Feb          -0.25 1880-02-01\n3  1880 Mar          -0.09 1880-03-01\n4  1880 Apr          -0.16 1880-04-01\n5  1880 May          -0.1  1880-05-01\n6  1880 Jun          -0.21 1880-06-01\n\n\nKarena kolom tahun dan bulan sudah diwakili oleh kolom tanggal, kita dapat mengabaikan kedua kolom tersebut.\n\ntren_suhu_global &lt;- tren_suhu_global |&gt; \n  select(tanggal, anomali_suhu)\n\nhead(tren_suhu_global)\n\n# A tibble: 6 × 2\n  tanggal    anomali_suhu\n  &lt;date&gt;            &lt;dbl&gt;\n1 1880-01-01        -0.19\n2 1880-02-01        -0.25\n3 1880-03-01        -0.09\n4 1880-04-01        -0.16\n5 1880-05-01        -0.1 \n6 1880-06-01        -0.21\n\n\nNah, sekarang kita mendapatkan data yang rapi. Data kita sekarang hanya memuat dua variabel, yaitu tanggal dan anomali_suhu. Selanjutnya kita akan memvisualisasikan anomali_suhu setiap tanggal-nya."
  },
  {
    "objectID": "pos/2024-07-anomali-suhu-global/index.html#sec-visualisasi-data",
    "href": "pos/2024-07-anomali-suhu-global/index.html#sec-visualisasi-data",
    "title": "Tren Suhu Planet Bumi",
    "section": "Visualisasi Data",
    "text": "Visualisasi Data\nData yang rapi yang sudah di tangan. Selanjutnya, kita visualisasikan data tersebut ke dalam diagram garis untuk melihat tren anomali_suhu setiap tanggal-nya. Untuk melakukannya, kita dapat menggunakan fungsi ggplot() dan peranakannya. Hasilnya disajikan pada Gambar 1.\n\ndiagram_garis &lt;- tren_suhu_global |&gt; \n  ggplot(aes(x = tanggal, y = anomali_suhu)) + \n  geom_line()\n\nprint(diagram_garis)\n\n\n\n\n\n\nGambar 1: Tren anomali_suhu setiap tanggal-nya.\n\n\n\n\nDiagram pada Gambar 1 dapat kita modifikasi. Misalnya, kita dapat mengubah judul sumbu-x dan y pada diagram tersebut. Kita juga dapat mengubah warna garis serta memberikan judul, anak judul, dan takarir pada diagram tersebut. Sentuhan terakhir, kita dapat memilih tema theme_minimal() dan menambahkan pola tren tersebut dengan geom_smooth(). Hasilnya ditunjukkan pada Gambar 2.\n\ndiagram_garis + \n  geom_line(color = \"#427D9D\") + \n  geom_smooth(\n    method = \"gam\",\n    formula = y ~ s(x, bs = \"cs\"),\n    color = \"#164863\"\n  ) + \n  theme_minimal() + \n  labs(\n    title = \"Tren Anomali Suhu Setiap Waktunya\",\n    subtitle = \"Anomali suhu relatif terhadap rerata suhu pada 1951 - 1980\",\n    x = \"Waktu\",\n    y = \"Anomali Suhu (°C)\",\n    caption = \"Data: GISTEMP\"\n  )\n\n\n\n\n\n\nGambar 2: Tren anomali_suhu setiap tanggal-nya yang sudah diperbaiki."
  },
  {
    "objectID": "pos/2024-07-anomali-suhu-global/index.html#catatan-akhir",
    "href": "pos/2024-07-anomali-suhu-global/index.html#catatan-akhir",
    "title": "Tren Suhu Planet Bumi",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah memvisualisasikan tren suhu planet bumi dari tahun ke tahun, yaitu mulai 1880 sampai 2024. Untuk mendapatkan visualisasi pada Gambar 2, pertama kita impor data dari situs web GISTEMP. Hal ini telah dipaparkan pada Bagian 1. Kedua, kita telah bergulat dengan data tersebut pada Bagian 2 untuk mendapatkan data yang rapi. Ketiga, data yang rapi tersebut selanjutnya kita gunakan untuk memvisualisasikan tren suhu planet bumi setiap waktunya pada Bagian 3.\nProses yang didemonstrasikan pada artikel ini dapat digunakan untuk menyusun desain pembelajaran Matematika yang menggunakan data riil, khususnya data tentang tema perubahan iklim. Penggunaan data perubahan iklim tersebut tidak hanya dapat memupuk kesadaran peserta didik akan isu planet bumi yang ditinggalinya, tetapi juga memudahkan mereka untuk bermatematika menggunakan konteks di sekitarnya."
  },
  {
    "objectID": "ihwal.html",
    "href": "ihwal.html",
    "title": "Ihwal",
    "section": "",
    "text": "Jelajah Statistika dan Ilmu Data ini bertujuan untuk berbagi pengalaman dan pengetahuan tentang Statistika dan Ilmu Data, khususnya yang terkait dengan pemrograman.\n\n\n Kembali ke atas"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Urutkan Dengan\n      Setelan Standar\n      \n        Judul\n      \n      \n        Tanggal - Terlama\n      \n      \n        Tanggal - Terbaru\n      \n      \n        Pengarang\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nSimulasi Monte Carlo\n\n\nMemvisualisasikan Masalah Jarum Buffon\n\n\nBagaimana menggunakan simulasi Monte Carlo untuk menyelesaikan masalah jarum Buffon? Artikel ini akan mendemonstrasikan bagaimana memvisualisasikan dan menganimasikan simulasi Monte Carlo untuk masalah paling awal yang diajukan dan diselesaikan di Peluang Geometris, yaitu masalah jarum Buffon.\n\n\n\n\n\nOct 22, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nAnalisis Komponen Utama\n\n\nMenyingkap Konsumsi Pangan Penduduk Indonesia\n\n\nAnalisis Komponen Utama (AKU) merupakan metode statistika multivariat yang ampuh untuk mereduksi dimensi data. Artikel ini mendemonstrasikan penggunaan metode tersebut untuk menyelidiki pola konsumsi pangan Indonesia yang awalnya memiliki delapan variabel kuantitatif. Dengan AKU, dimensi data tersebut tereduksi secara signifikan tetapi strukturnya relatif tidak banyak berubah.\n\n\n\n\n\nOct 6, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nKlasterisasi Warna Foto\n\n\nManipulasi Foto dengan Klasterisasi K-Rerata\n\n\nBagaimana mengurangi variasi warna dalam sebuah foto? Salah satu caranya adalah dengan menerapkan klasterisasi k-rerata. Dengan metode ini, foto tersebut akan tersusun hanya dalam k warna. Ide dasar dan cara detailnya dijelaskan dalam artikel ini.\n\n\n\n\n\nOct 1, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nKlasterisasi K-Rerata\n\n\nLangkah Demi Langkah Klasterisasi dengan Pemrograman R\n\n\nMulai dari memanipulasi gambar sampai menghindari paradoks Simpson, itulah manfaat analisis klaster. Artikel ini membahas secara tuntas analisis klaster yang sederhana, yaitu klasterisasi k-rerata (k-means clustering), mulai dari menjelaskan algoritmanya seperti apa sampai mendemonstrasikan algoritma tersebut secara mendetail.\n\n\n\n\n\nSep 23, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nMengantisipasi Bincang-Bincang Ilmiah\n\n\nMenggunakan Analisis Jejaring untuk Menyingkap Forum Ilmiah\n\n\nJejaring ada di mana-mana. Konferensi ilmiah pun tak terlewatkan. Artikel ini mendemonstrasikan bagaimana analisis jejaring dapat digunakan untuk menyingkap CERME 14, salah satu konferensi terbesar di bidang Pendidikan Matematika.\n\n\n\n\n\nFeb 2, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nVisualisasi Data Pendapatan Industri Musik\n\n\nDari Pemrograman R Sampai Observable JS\n\n\nBanyak cara untuk memvisualisasikan data secara efektif. Artikel ini mendemonstrasikan bagaimana memvisualisasikan data pendapatan industri musik di AS dengan menggunakan {ggplot2} dan {plotly}. Cara tersebut dilakukan dengan menggunakan pemrograman R. Tak hanya itu, artikel ini juga mendemonstrasikan bagaimana memvisualisasikan data tersebut secara interaktif dengan menggunakan Observable Plot.\n\n\n\n\n\nJan 13, 2025\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nGunung Agung, Bromo, Merapi, dan Semeru\n\n\nSeberapa Tinggi dan Besar Keempat Gunung Itu?\n\n\nGunung Agung, Bromo, Merapi, dan Semeru termasuk gunung-gunung yang populer di Indonesia. Pemrograman R dapat digunakan untuk memodelkan keempat gunung tersebut ke dalam bentuk 2D maupun 3D. Cara seperti ini dapat digunakan untuk membandingkan seberapa tinggi dan besar gunung-gunung tersebut.\n\n\n\n\n\nAug 25, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nIndonesia Negara Dua Musim\n\n\nBagaimana Curah Hujannya?\n\n\nIndonesia memiliki dua musim, yaitu musim kemarau dan penghujan. Kedua musim ini terjadi pada periode waktu tertentu. Bagaimana sebaran curah hujan dalam periode tersebut? Bagaimana sebarannya pada wilayah-wilayah di Indonesia?\n\n\n\n\n\nAug 24, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nPrestasi Indonesia di Olimpiade\n\n\n\n\n\nIndonesia menyabet dua emas dan satu perunggu di Olimpiade Paris 2024. Prestasi itu diraih berkat performa ciamik Veddriq Leonardo, Rizki Juniansyah, dan Gregoria Mariska Tunjung. Bagaimana dengan performa Indonesia di semua perhelatan olimpiade yang pernah diikutinya?\n\n\n\n\n\nAug 17, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nSepak Bola Indonesia vs. Negara-Negara Asia Tenggara\n\n\nPeringkat Dunia FIFA\n\n\nBagaimana prestasi sepak bola Indonesia dibandingkan dengan negara-negara Asia Tenggara lainnya? Dengan menggunakan data peringkat dunia FIFA, diagram garis dan animasi diagram batang dapat dimanfaatkan untuk menyelidikanya.\n\n\n\n\n\nAug 14, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nDirgahayu Kemerdekaan Republik Indonesia\n\n\nPersembahan Untuk HUT Ke-79 RI\n\n\nPeringatan hari ulang tahun ke-79 Republik Indonesia menyimpan banyak harapan. Salah satunya adalah pertumbuhan ekonomi. Artikel ini memberikan persembahan visualisasi data dalam tema pertumbuhan ekonomi tersebut.\n\n\n\n\n\nAug 12, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nMembuat Statistik Menjadi Dinamis dan Interaktif\n\n\n\n\n\nStatistik bukan hanya untuk statistikawan tetapi juga untuk orang awam. Untuk itu, statistik perlu dikemas secara lebih menarik dan menawan. Shiny memungkinkan agar statistik disajikan secara dinamis dan interaktif agar menarik dan mudah dipelajari oleh orang awam.\n\n\n\n\n\nAug 10, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nMembuat Diagram Lebih Hidup dengan Animasi\n\n\n\n\n\nBagaimana menganimasikan diagram statistik? Artikel ini mendemonstrasikan bagaimana menggunakan paket {gganimate} untuk membuat animasi dalam penyajian data yang efisien dan menarik.\n\n\n\n\n\nAug 7, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nStatistik Adalah Jendela Dunia\n\n\n\n\n\nStatistik dapat digunakan untuk menyingkap fakta-fakta tentang dunia. Secara khusus, statistik dapat dimanfaatkan untuk melihat angka harapan hidup dan PDB per kapita berbagai negara.\n\n\n\n\n\nAug 5, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nPemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat\n\n\n\n\n\nKepulauan Raja Ampat kaya akan keanekaragaman hayatinya. Bagaimana kita dapat mengetahui keanekaragaman tersebut? Apakah kita dapat memodelkannya?\n\n\n\n\n\nAug 3, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nTren Suhu Planet Bumi\n\n\n\n\n\nBagaimana tren suhu planet bumi dari tahun ke tahun? Artikel ini mendemonstrasikan bagaimana mengimpor data tentang perubahan iklim dari sebuah situs web, mengolahnya, dan memvisualisasikannya ke dalam diagram garis. Proses seperti ini dapat diterapkan dalam menyusun desain pembelajaran Matematika yang ramah akan peserta didik dan relevan terhadap isu-isu penting planet bumi.\n\n\n\n\n\nJul 31, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\n\n\n\n\n\n\n\nLiterasi Matematika dan Status Sosial Ekonomi dalam PISA 2022\n\n\n\n\n\nBagaimana hubungan antara literasi matematika dan status sosial ekonomi berdasarkan data PISA 2022? Apakah hubungan tersebut sama untuk setiap negara atau ekonomi yang berpartisipasi dalam PISA 2022? Artikel ini menunjukkan beberapa negara yang memiliki rerata skor Matematika lebih tinggi dibandingkan dengan negara-negara lain yang rerata indeks status sosial ekonominya sama. Apa saja negara tersebut?\n\n\n\n\n\nJul 30, 2024\n\n\nYosep Dwi Kristanto\n\n\n\n\n\nTidak ada item yang cocok\n Kembali ke atas"
  },
  {
    "objectID": "pos/2024-07-literasi-matematika-sosial-budaya/index.html",
    "href": "pos/2024-07-literasi-matematika-sosial-budaya/index.html",
    "title": "Literasi Matematika dan Status Sosial Ekonomi dalam PISA 2022",
    "section": "",
    "text": "Kodelibrary(tidyverse)\nlibrary(ggrepel)\nMasuk akal memang status sosial ekonomi peserta didik berbanding lurus dengan hasil belajarnya. Semakin tinggi status sosial ekonomi seorang peserta didik, hasil belajarnya juga cenderung semakin tinggi. Misalnya saja, peserta didik yang memiliki kamar sendiri, komputer yang ditunjang dengan berbagai macam perangkat lunak pembelajaran, buku, dan orang tua yang berpendidikan tinggi memiliki kesempatan yang lebih besar untuk mendapatkan pendidikan yang berkualitas. Alhasil, hasil belajarnya relatif tinggi.\nUntuk mengkonfirmasinya, mari kita analisis data PISA 2022. Dalam PISA, status sosial ekonomi diukur dengan indeks status ekonomi, sosial, dan budaya (ESCS). Hasil belajarnya ada tiga, yaitu skor literasi Matematika, Membaca, dan Sains. Pertama, kita lihat hubungan antara rerata ESCS dan rerata skor Membaca dan Sains antarnegara pada Gambar 1.\nKode# Impor dan olah data\nhasil_belajar_escs &lt;- read_csv(\"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/main/pos/2024-07-literasi-matematika-sosial-budaya/data/hasil_belajar_escs_csv\")\nhb_escs_ms &lt;- hasil_belajar_escs |&gt; \n  select(negara, membaca, sains, escs) |&gt; \n  drop_na() |&gt; \n  pivot_longer(\n    cols = c(\"membaca\", \"sains\"),\n    names_to = \"literasi\",\n    values_to = \"rerata_skor\"\n  ) |&gt; \n  mutate(\n    literasi = str_to_title(literasi)\n  )\n\n# Visualisasi data\nhb_escs_ms |&gt; \n  ggplot(aes(x = escs, y = rerata_skor)) + \n  geom_point(\n    aes(color = literasi),\n    size = 2\n  ) + \n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x,\n    color = \"black\",\n    alpha = .1\n  ) + \n  facet_grid(~literasi) + \n  scale_color_manual(\n    name = \"Literasi\",\n    values = c(\n      \"Membaca\" = \"#427D9D\",\n      \"Sains\" = \"#9BBEC8\"\n    )\n  ) + \n  theme_minimal() + \n  theme(legend.position = \"none\") + \n  labs(\n    x = \"Rerata ESCS\",\n    y = \"Rerata skor\"\n  )\n\n\n\n\n\n\nGambar 1: Hubungan status sosial ekonomi (ESCS) dengan skor membaca dan sains antarnegara."
  },
  {
    "objectID": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#status-sosial-ekonomi-dan-literasi-matematika",
    "href": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#status-sosial-ekonomi-dan-literasi-matematika",
    "title": "Literasi Matematika dan Status Sosial Ekonomi dalam PISA 2022",
    "section": "Status Sosial Ekonomi dan Literasi Matematika",
    "text": "Status Sosial Ekonomi dan Literasi Matematika\nBerdasarkan Gambar 1, kita melihat bahwa ESCS berbanding lurus dengan skor Membaca maupun Sains. Apakah hubungan seperti ini juga berlaku untuk skor matematika? Mari kita perhatikan Gambar 2.\n\nKode# Olah data\nhb_escs_mat &lt;- hasil_belajar_escs |&gt; \n  select(negara, escs, matematika) |&gt; \n  drop_na()\n# Visualisasi data\nhb_escs_mat |&gt; \n  ggplot(aes(x = escs, y = matematika)) + \n  geom_point(\n    color = \"#164863\",\n    size = 2\n  ) + \n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x,\n    color = \"black\",\n    alpha = .1\n  ) + \n  theme_minimal() + \n  labs(\n    x = \"ESCS\",\n    y = \"Rerata skor Matematika\"\n  )\n\n\n\n\n\n\nGambar 2: Hubungan antara status sosial ekonomi (ESCS) dan skor matematika antarnegara.\n\n\n\n\nTernyata hubungan yang serupa kita temukan antara rerata indeks status sosial ekonomi dan rerata skor literasi matematika antarnegara. Semakin tinggi rerata status sosial ekonomi sebuah negara, semakin tinggi juga rerata skor Matematika negara tersebut."
  },
  {
    "objectID": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#menjelajah-lebih-dalam",
    "href": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#menjelajah-lebih-dalam",
    "title": "Literasi Matematika dan Status Sosial Ekonomi dalam PISA 2022",
    "section": "Menjelajah Lebih Dalam",
    "text": "Menjelajah Lebih Dalam\nApabila kita perhatikan kembali Gambar 2 dengan saksama, kita melihat ada beberapa titik (yang merepresentasikan beberapa negara) yang terpisah dengan sebagian besar titik lainnya. Titik-titik yang disebut pencilan tersebut terletak di bagian atas.\nKita deteksi pencilan tersebut dengan menggunakan model linear dan jarak Cook. Jarak Cook ini biasanya digunakan untuk mengestimasi pengaruh sebuah titik pada analisis regresi linear. Dengan menganggap pencilan sebagai titik-titik yang jarak Cook-nya lebih dari tiga kali rata-ratanya, kita mendapatkan titik-titik pencilan seperti yang ditunjukkan pada Gambar 3.\n\nKode# Membuat model linear\nmodel &lt;- lm(matematika ~ escs, hb_escs_mat)\n\n# Menentukan jarak Cook untuk setiap titik data\nhb_escs_mat_pencilan &lt;- hb_escs_mat |&gt; \n  mutate(\n    jarak_cook = cooks.distance(model)\n  )\n\n# Menentukan titik-titik pencilan\nrerata_jarak_cook &lt;- mean(hb_escs_mat_pencilan$jarak_cook)\nhb_escs_mat_pencilan &lt;- hb_escs_mat_pencilan |&gt; \n  mutate(\n    kelompok = ifelse(\n      jarak_cook &gt; 3 * rerata_jarak_cook,\n      \"pencilan\", \"bukan pencilan\"\n    ),\n    negara_pencilan = ifelse(\n      kelompok == \"pencilan\",\n      negara, NA\n    )\n  )\n\n# Memvisualisasikan pencilan\nhb_escs_mat_pencilan |&gt; \n  ggplot(aes(x = escs, y = matematika, color = kelompok)) + \n  geom_point(size = 2) + \n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x,\n    alpha = .1\n  ) + \n  geom_text_repel(aes(label = negara_pencilan)) + \n  scale_color_manual(\n    values = c(\n      \"bukan pencilan\" = \"#9BBEC8\",\n      \"pencilan\" = \"#164863\"\n    )\n  ) + \n  theme_minimal() + \n  theme(legend.position = \"none\") + \n  labs(\n    x = \"Rerata ESCS\",\n    y = \"Rerata skor Matematika\"\n  )\n\n\n\n\n\n\nGambar 3: Hubungan antara status sosial ekonomi (ESCS) dan skor matematika antarnegara.\n\n\n\n\nBerdasarkan Gambar 3, titik-titik pencilannya adalah Vietnam, Turki, Hongkong, Makau, Tionghoa Taipei, dan Singapura. Negara-negara dalam kelompok ini cenderung memiliki rerata skor Matematika yang lebih tinggi dibandingkan dengan negara-negara lain yang rerata indeks status sosial ekonominya sama. Berapakah perbedaan rerata skor Matematinya? Mari kita gunakan model linear untuk menyelidikinya!\n\nKodemodel_kelompok &lt;- lm(\n  matematika ~ kelompok + escs,\n  hb_escs_mat_pencilan\n)\n\nprint(model_kelompok)\n\n\nCall:\nlm(formula = matematika ~ kelompok + escs, data = hb_escs_mat_pencilan)\n\nCoefficients:\n     (Intercept)  kelompokpencilan              escs  \n          458.00            106.59             76.89  \n\n\nDari model tersebut, kita dapat melihat bahwa koefisien dari kelompok adalah sekitar 106,59. Artinya, negara-negara dalam kelompok pencilan tersebut secara rata-rata skor Matematika peserta didiknya lebih tinggi sebesar 106,59 dibandingkan dengan negara-negara lain yang rerata status sosial ekonominya sama."
  },
  {
    "objectID": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#catatan-akhir",
    "href": "pos/2024-07-literasi-matematika-sosial-budaya/index.html#catatan-akhir",
    "title": "Literasi Matematika dan Status Sosial Ekonomi dalam PISA 2022",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah melihat bahwa status sosial ekonomi berbanding lurus dengan literasi Matematika. Secara lebih detail, kita melihat ada beberapa negara yang rerata skor Matematikanya lebih besar daripada negara-negara lain dengan rerata indeks sosial ekonomi yang sama. Negara-negara tersebut adalah Vietnam, Turki, Hongkong, Makau, Tionghoa Taipei, dan Singapura. Sebagai bahan perenungan, baik jika pembaca bertanya-tanya mengapa negara-negara tersebut memiliki rerata skor Matematika yang lebih tinggi."
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html",
    "title": "Indonesia Negara Dua Musim",
    "section": "",
    "text": "November Rain merupakan satu dari banyak lagu yang akrab di telingaku. Tak hanya itu, lagu ini juga biasanya aku gunakan sebagai pengingat waktu. November biasanya menjadi awal musim penghujan. Musim penghujan tersebut pada umumnya terjadi pada bulan November hingga Maret karena adanya angin muson barat yang membawa banyak uap air ke sebagian besar wilayah Indonesia.\nMusim kemarau biasanya terjadi pada bulan Mei hingga September. Hal ini dikarenakan adanya angin muson timur yang sifatnya kering dan berhembus ke sebagian besar wilayah Indonesia. Meskipun demikian, pola musim penghujan dan kemarau tersebut dapat berbeda karena banyak hal, misalnya adalah posisi wilayahnya dan adanya pengaruh angin lokal.\nUntuk itu, melalui artikel ini aku mengajak pembaca untuk melihat dan menganalisis curah hujan di Indonesia. Nanti kita akan menganalisis curah hujan di Indonesia berdasarkan waktu dan posisi geografisnya dengan menggunakan R. Untuk mengawalinya, kita perlu memanggil beberapa paket yang diperlukan.\nlibrary(pRecipe)\nlibrary(giscoR)\nlibrary(terra)\nlibrary(tidyverse)\nlibrary(rayshader)\nlibrary(sf)\nPaket {pRecipe} akan kita gunakan untuk mengunduh dan mengimpor data presipitasi atau curah hujan. Paket {giscoR} kita pakai untuk mengunduh data dari pangkalan data Eurostat GISCO (Geographic Information System of the Commission). Secara khusus, kita menggunakan paket ini untuk mendapatkan data peta Indonesia. Kita gunakan paket {terra} untuk melakukan analisis data spasial. Seperti biasa, paket {tidyverse} kita gunakan untuk menganalisis dan memvisualisasikan data. Paket {rayshader} dapat membantu kita dalam pembuatan peta dan visualisasi data dalam 2D dan 3D. Terakhir, paket {sf} memungkinkan kita untuk mengolah data spasial yang berupa vektor."
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html#sec-mempersiapkan-data",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html#sec-mempersiapkan-data",
    "title": "Indonesia Negara Dua Musim",
    "section": "Mempersiapkan Data",
    "text": "Mempersiapkan Data\nData yang perlu kita miliki adalah data curah hujan. Data tersebut dapat kita peroleh dengan menggunakan fungsi download_data() dari {pRecipe}.\ndownload_data(\n  dataset = \"mswep\",\n  path = getwd(),\n  domain = \"raw\",\n  timestep = \"monthly\"\n)\nAda empat argumen yang kita inputkan dalam fungsi download_data() di atas. Argumen dataset = \"mswep\" mengindikasikan bahwa set data yang kita unduh adalah data MSWEP (Multi-Source Weighted-Ensemble Precipitation). Argumen path = getwd() menunjukkan tempat penyimpanan hasil unduhannya. getwd() mengindikasikan bahwa tempat penyimpanannya adalah folder kerja kita. Argumen domain = \"raw\" menunjukkan domain set data yang kita inginkan. Nilai domain tersebut juga dapat diisi dengan “global”, “land”, atau “ocean”. Terakhir, timestep = \"monthly\" menerangkan bahwa set data yang kita inginkan memiliki interval waktu bulanan.\nSetelah kita jalankan kode di atas, kita mendapatkan sebuah fail dengan nama “mswep_tp_mm_global_197902_202301_025_monthly.nc”. Fail tersebut berisi data curah hujan untuk semua wilayah di dunia. Padahal, kita hanya memerlukan data untuk Indonesia saja. Oleh karena itu, kita perlu memotong data tersebut. Untuk melakukan hal ini, kita memerlukan poligon wilayah Indonesia. Bagaimana mendapatkannya? Kita dapat memerolehnya dengan menggunakan fungsi gisco_get_countries() dari paket {giscoR}.\nsf_negara &lt;- gisco_get_countries(\n  country = \"ID\",\n  resolution = 1\n)\nSekarang kita buat sebuah SpatRaster dari fail “mswep_tp_mm_global_197902_202301_025_monthly.nc” dengan menggunakan fungsi rast() dari {terra}. Setelah itu, kita potong hasilnya dengan sf_negara menggunakan fungsi crop() dari {terra}. Kita namai hasilnya sebagai data_mswep.\ndata_mswep &lt;- rast(\n  \"mswep_tp_mm_global_197902_202301_025_monthly.nc\"\n) |&gt; \n  crop(\n    sf_negara\n  )\nJika kita menjalankan perintah print(data_mswep), kita mengetahui bahwa objek data_mswep tersebut memiliki 68 baris, 184 kolom, dan 528 lapisan/layer. Baris dan kolom tersebut menyatakan koordinat \\(x\\) dan \\(y\\) wilayah Indonesia sedangkan lapisannya merupakan nilai-nilai variabel precipitation atau curah hujan di tiap-tiap koordinat tersebut. Banyaknya lapisan adalah 528 karena nilai precipitation untuk setiap koordinat wilayahnya merentang dari 1979-02-01 sampai 2023-01-01 (528 bulan).\nPada bagian names, kita dapat melihat nama-nama variabelnya adalah precipitation_1, precipitation_2, precipitation_3, dan seterusnya sampai precipitation_528. Nama-nama ini kurang informatif. Karena nama-nama itu merepresentasikan curah hujan dari 1979-02-01 sampai 2023-01-01, kita dapat menggantinya dengan barisan tanggal itu.\nbarisan_tanggal &lt;- as.character(\n  seq(as.Date(\"1979-02-01\"), as.Date(\"2023-01-01\"), by = \"month\")\n)\n\nnames(data_mswep) &lt;- barisan_tanggal\nAgar memudahkan kita dalam mengolah data, kita ubah objek data_mswep menjadi sebuah data frame. Untuk melakukannya, kita dapat menggunakan fungsi as.data.frame() dari paket {terra}. Kita inputkan xy = TRUE ke dalam fungsi tersebut agar mempertahankan koordinat \\(x\\) dan \\(y\\). Setelah itu, kita juga dapat mengubah hasilnya menjadi sebuah tibble dengan fungsi as_tibble() agar mudah terbaca. Kita namai hasilnya dengan df_mswep.\ndf_mswep &lt;- data_mswep |&gt;\n  as.data.frame(xy = TRUE) |&gt; \n  as_tibble()\nJika kita lihat hasilnya dengan print(df_mswep), ternyata df_mswep memiliki 12.512 baris dan 530 kolom! Kita buat data tersebut menjadi data yang memanjang dengan fungsi pivot_longer(). Kolom-kolom yang kita putar adalah semua kolom kecuali kolom x dan y sehingga kita inputkan argumen cols = !c(\"x\", \"y\"). Kita namai variabel yang memuat kolom-kolom dari data sebelumnya dengan tanggal_bawah dan kita namai variabel yang berisi nilai-nilainya dengan curah_hujan. Agar nilai-nilai dalam variabel tanggal_bawah memiliki kelas date, kita modifikasi variabel ini dengan mutate() dan as.Date(). Untuk melihat hasilnya, kita dapat memanggil fungsi print() terhadap df_mswep.\ndf_mswep &lt;- df_mswep |&gt; \n  pivot_longer(\n    !c(\"x\", \"y\"),\n    names_to = \"tanggal_bawah\",\n    values_to = \"curah_hujan\"\n  ) |&gt; \n  mutate(\n    tanggal_bawah = as.Date(tanggal_bawah)\n  )\nData df_mswep telah rapi. Data tersebut memuat 6.606.336 baris dan 4 variabel/kolom. Keempat variabel tersebut adalah x, y, tanggal_bawah, dan curah_hujan. Data ini telah siap untuk kita eksplorasi pada bagian berikutnya.\n\n\n\n\n\n\nCatatan\n\n\n\nBagian 1 di atas menghasilkan sf_negara, data_mswep, dan df_mswep. Ketiga data tersebut sudah aku siapkan di awan. Untuk itu, kamu dapat memuatnya langsung ke lembar kerja R dengan kode berikut.\n\nload(url(\"https://github.com/jelajahstatid/jelajahstatid.github.io/raw/main/pos/2024-08-curah-hujan-indonesia/aset/data_curah_hujan_id.RData\"))"
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html#sec-menjelajah-data",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html#sec-menjelajah-data",
    "title": "Indonesia Negara Dua Musim",
    "section": "Menjelajah Data",
    "text": "Menjelajah Data\nData yang telah kita peroleh pada bagian Bagian 1 dapat kita gunakan untuk melihat tren rerata curah hujan per bulannya, mulai Februari 1979 sampai Januari 2023. Untuk melakukannya, kita perlu mengelompokkan baris-baris dalam df_mswep berdasarkan nilai dalam variabel tanggal_bawah. Pengelompokkan ini dapat kita lakukan dengan menggunakan fungsi group_by(). Setelah itu, kita hitung rerata curah_hujan pada setiap kelompoknya dengan menggunakan fungsi summarise().\nHasil pada proses sebelumnya kemudian dapat gunakan untuk membuat diagram garis. Perhatikan Gambar 1!\n\ndf_mswep |&gt; \n  group_by(tanggal_bawah) |&gt; \n  summarise(\n    rerata_curah_hujan = mean(curah_hujan, na.rm = TRUE),\n    .groups = \"drop\"\n  ) |&gt; \n  ggplot(\n    aes(x = tanggal_bawah, y = rerata_curah_hujan)\n  ) + \n  geom_line() + \n  theme_minimal() + \n  labs(\n    x = \"Waktu\",\n    y = \"Rerata curah hujan (mm)\"\n  )\n\n\n\n\n\n\nGambar 1: Tren rerata curah hujan di Indonesia setiap bulannya mulai Februari 1979 sampai Januari 2023\n\n\n\n\nApakah kita dapat membandingkan rerata curah hujan setiap bulannya? Pertanyaan ini dapat kita jawab dengan membandingkan distribusi curah hujan untuk bulan Januari sampai Desember. Hal ini dapat kita lakukan dengan diagram kotak. Perhatikan Gambar 2!\n\nvek_nama_bulan &lt;- c(\"Januari\", \"Februari\", \"Maret\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Agustus\", \"September\", \"Oktober\", \"November\", \"Desember\")\n\ndf_mswep |&gt; \n  mutate(\n    bulan = month(tanggal_bawah),\n    nama_bulan = vek_nama_bulan[month(tanggal_bawah)]\n  ) |&gt; \n  ggplot(\n    aes(x = fct_reorder(nama_bulan, bulan), y = curah_hujan)\n  ) + \n  geom_boxplot(outliers = FALSE) + \n  theme_minimal() + \n  labs(\n    x = \"Bulan\",\n    y = \"Curah hujan (mm)\"\n  )\n\n\n\n\n\n\nGambar 2: Perbandingan rerata curah hujan setiap bulannya\n\n\n\n\nBerdasarkan Gambar 2, kita dapat melihat bahwa bulan Januari dan Desember memiliki nilai tengah (median) curah hujan yang paling tinggi dibandingkan dengan bulan-bulan lainnya. Sebaliknya, bulan Agustus dan September memiliki curah hujan yang relatif lebih rendah dibandingkan dengan yang lain.\nPada Bagian 2 ini kita telah menjelajah data curah hujan di Indonesia. Melalui penjelajahan tersebut, kita telah melihat tren rerata curah hujan di Indonesia dari waktu ke waktu. Selain itu, kita juga telah dapat membandingkan rerata curah hujan setiap bulannya. Meskipun demikian, dalam penjelajahan tersebut kita belum mempertimbangkan perbedaan curah hujan antara satu wilayah dengan wilayah lainnya. Kita belum memanfaatkan variabel x dan y dalam data df_mswep."
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html#sec-visualisasi-data-dengan-peta-2d",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html#sec-visualisasi-data-dengan-peta-2d",
    "title": "Indonesia Negara Dua Musim",
    "section": "Visualisasi Data dengan Peta 2D",
    "text": "Visualisasi Data dengan Peta 2D\nCurah hujan tergantung dari wilayahnya. Suatu wilayah dapat memiliki curah hujan yang relatif lebih tinggi dibandingkan wilayah lainnya. Demikian juga sebaliknya. Untuk itu, kita perlu melakukan visualisasi data yang berbeda dari apa yang kita lakukan pada Bagian 2. Kita akan memanfaatkan peta.\nPeta pertama yang kita buat adalah peta yang menunjukkan rerata curah hujan di setiap wilayah Indonesia empat tahun terakhir, yaitu tahun 2019 – 2022. (Data pada tahun 2023 kita abaikan karena hanya memuat data bulan Januari.) Untuk itu, kita siapkan terlebih dahulu datanya. Data tersebut kita beri nama df_mswep_19_22.\n\n# Data curah hujan tahunan\ndf_mswep_tahunan &lt;- df_mswep |&gt; \n  filter(\n    tanggal_bawah &gt;= as.Date(\"1980-01-01\"),\n    tanggal_bawah &lt;= as.Date(\"2022-12-01\")\n  ) |&gt; \n  mutate(tahun = year(tanggal_bawah)) |&gt; \n  group_by(x, y, tahun) |&gt; \n  summarise(\n    curah_hujan_tahunan = sum(curah_hujan, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# Data curah hujan tahunan pada tahun 2019 -- 2022\ndf_mswep_19_22 &lt;- df_mswep_tahunan |&gt; \n  filter(\n    tahun %in% c(2019, 2020, 2021, 2022)\n  )\n\nprint(df_mswep_19_22)\n\n# A tibble: 50,048 × 4\n       x     y tahun curah_hujan_tahunan\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;               &lt;dbl&gt;\n 1  95.1 -10.9  2019               1056.\n 2  95.1 -10.9  2020               1966.\n 3  95.1 -10.9  2021               3029.\n 4  95.1 -10.9  2022               2868.\n 5  95.1 -10.6  2019               1071.\n 6  95.1 -10.6  2020               2034.\n 7  95.1 -10.6  2021               2997.\n 8  95.1 -10.6  2022               3136.\n 9  95.1 -10.4  2019               1029.\n10  95.1 -10.4  2020               2097.\n# ℹ 50,038 more rows\n\n\nKita gunakan df_mswep_19_22 untuk membuat peta. Terdapat tiga fungsi utama yang perlu kita gunakan:\n\ngeom_raster() untuk memplot kotak-kotak yang warnanya mengikuti nilai rerata curah hujan di setiap koordinat kotak-kotak tersebut;\ngeom_contour() untuk memvisualisasikan kontur (garis bentuk); dan\ngeom_sf() untuk memvisualisasikan objek-objek sf (misalnya titik, garis, atau poligon).\n\nPeta pertama kita dapat dibuat dengan menggunakan baris kode seperti berikut. Hasilnya ditunjukkan pada Gambar 3.\n\ndf_mswep_19_22 |&gt; \n  ggplot() + \n  geom_raster(\n    aes(\n      x = x,\n      y = y,\n      fill = curah_hujan_tahunan\n    )\n  ) +\n  geom_contour(\n    aes(\n      x = x,\n      y = y,\n      z = curah_hujan_tahunan\n    ),\n    color = \"white\"\n  ) +\n  geom_sf(\n    data = sf_negara,\n    fill = \"transparent\",\n    color = \"grey10\",\n    size = .5\n  ) +\n  facet_wrap(vars(tahun), ncol = 2) +\n  theme_minimal()\n\n\n\n\n\n\nGambar 3: Rerata curah hujan di setiap wilayah Indonesia per tahunnya\n\n\n\n\nKita dapat memperbaiki tampilan pada Gambar 3. Perbaikan tersebut dapat kita lakukan pada tema, interval, dan warnanya. Kita siapkan ketiga hal tersebut.\n\ntema_peta &lt;- function(){\n  theme_minimal() +\n    theme(\n      axis.line = element_blank(),\n      axis.title.x = element_blank(),\n      axis.title.y = element_blank(),\n      axis.text.x = element_blank(),\n      axis.text.y = element_blank(),\n      legend.position = \"bottom\",\n      panel.grid.major = element_line(\n        color = NA\n      ),\n      panel.grid.minor = element_line(\n        color = NA\n      ),\n      plot.background = element_rect(\n        fill = NA, color = NA\n      ),\n      legend.background = element_rect(\n        fill = \"white\", color = NA\n      ),\n      panel.border = element_rect(\n        fill = NA, color = NA\n      ),\n      plot.margin = unit(\n        c(\n          t = 0, r = 0,\n          b = 0, l = 0\n        ), \"lines\"\n      )\n    )\n}\n\nwarna &lt;- hcl.colors(\n  n = 5,\n  palette = \"Temps\",\n  rev = TRUE\n)\n\n# Curah hujan bulanan (mm per bulan)\nbatas_int_bulanan &lt;- c(0, 100, 300, 400, ceiling(max(df_mswep$curah_hujan)))\n\nbatas_int_bulanan_baku &lt;- (batas_int_bulanan - min(batas_int_bulanan)) / (max(batas_int_bulanan) - min(batas_int_bulanan))\n\n# Curah hujan tahunan (mm per tahun)\nbatas_int_tahunan &lt;- c(0, 1500, 3000, 4500, ceiling(max(df_mswep_tahunan$curah_hujan_tahunan)))\n\nbatas_int_tahunan_baku &lt;- (batas_int_tahunan - min(batas_int_tahunan)) / (max(batas_int_tahunan) - min(batas_int_tahunan))\n\nSebagai catatan, interval pada baris kode di atas memiliki batas-batas batas_int_tahunan dan batas_int_bulanan. Batas-batas interval bulanan maupun tahunan tersebut dibuat dengan berdasarkan kategori curah hujan BMKG.\nSekarang, kita terapkan tema, interval, dan warna yang sudah kita siapkan untuk membuat peta. Hasilnya disajikan pada Gambar 4.\n\ndf_mswep_19_22 |&gt; \n  ggplot() + \n  geom_raster(\n    aes(\n      x = x,\n      y = y,\n      fill = curah_hujan_tahunan\n    )\n  ) +\n  geom_contour(\n    aes(\n      x = x,\n      y = y,\n      z = curah_hujan_tahunan\n    ),\n    color = \"white\",\n    linewidth = .25\n  ) +\n  geom_sf(\n    data = sf_negara,\n    fill = \"transparent\",\n    color = \"grey10\",\n    linewidth = .5\n  ) + \n  scale_fill_gradientn(\n    name = \"Curah hujan\\n(mm/tahun)\",\n    colors = warna,\n    values = batas_int_tahunan_baku,\n    breaks = c(0, 1500, 3000, 4500),\n    labels = c(0, 1500, 3000, 4500)\n  ) + \n  facet_wrap(vars(tahun), ncol = 2) +\n  tema_peta()\n\n\n\n\n\n\nGambar 4: Rerata curah hujan di setiap wilayah Indonesia per tahunnya\n\n\n\n\nBerdasarkan peta pada Gambar 4, kita dapat melihat bahwa tahun 2019 curah hujannya relatif lebih rendah dibandingkan dengan tahun 2020 – 2022. Tak hanya itu, kita juga dapat membandingkan curah hujan antarwilayah di Indonesia. Tampak bahwa wilayah pesisir barat Pulau Sumatera, Kalimantan bagian utara, dan Papua bagian timur memiliki curah hujan yang relatif lebih tinggi.\nSekarang kita akan membuat sebuah peta curah hujan di Indonesia pada bulan dan tahun tertentu. Apakah kamu punya usulan bulan dan tahun berapa yang perlu kita gambar? Kita pilih bulan dan tahun yang terakhir saja, yaitu Januari 2023. Perhatikan Gambar 5!\n\npeta_2023_01 &lt;- df_mswep |&gt; \n  filter(\n    tanggal_bawah == as.Date(\"2023-01-01\")\n  ) |&gt; \n  ggplot() + \n  geom_raster(\n    aes(\n      x = x,\n      y = y,\n      fill = curah_hujan\n    )\n  ) +\n  geom_contour(\n    aes(\n      x = x,\n      y = y,\n      z = curah_hujan \n    ),\n    breaks = c(0, 100, 300, 400),\n    color = \"white\",\n    linewidth = .25\n  ) +\n  geom_sf(\n    data = sf_negara,\n    fill = \"transparent\",\n    color = \"grey10\",\n    linewidth = .5\n  ) + \n  scale_fill_gradientn(\n    name = \"Curah hujan\\n(mm/bulan)\",\n    colors = warna,\n    values = batas_int_bulanan_baku,\n    breaks = c(0, 100, 300, 400),\n    labels = c(0, 100, 300, 400)\n  ) + \n  tema_peta()\n\nprint(peta_2023_01)\n\n\n\n\n\n\nGambar 5: Curah hujan di setiap wilayah Indonesia pada Januari 2023\n\n\n\n\nBerdasarkan Gambar 5, kita dapat melihat bahwa sebagian besar wilayah Indonesia memiliki curah hujan yang cukup tinggi. Beberapa wilayah saja yang curah hujannya relatif rendah, yaitu sebagian wilayah Sulawesi, bagian selatan Kepulauan Maluku, dan wilayah Nusa Tenggara. Untuk lebih jelasnya, kita dapat melihat distribusi curah hujannya pada Januari 2023, seperti yang ditunjukkan pada Gambar 6!\n\ndf_mswep |&gt; \n  filter(\n    tanggal_bawah == as.Date(\"2023-01-01\")\n  ) |&gt; \n  ggplot(aes(x = curah_hujan)) + \n  geom_density() + \n  theme_minimal() + \n  theme(\n    axis.title.y = element_blank(),\n    axis.text.y = element_blank()\n  ) + \n  labs(\n    x = \"Curah hujan (mm/bulan)\"\n  )\n\n\n\n\n\n\nGambar 6: Distribusi curah hujan di setiap wilayah Indonesia pada Januari 2023"
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html#sec-visualisasi-data-dengan-peta-3d",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html#sec-visualisasi-data-dengan-peta-3d",
    "title": "Indonesia Negara Dua Musim",
    "section": "Visualisasi Data dengan Peta 3D",
    "text": "Visualisasi Data dengan Peta 3D\nPeta yang kita hasilkan pada Bagian 3 merupakan peta 2D meskipun terbantu oleh kontur sehingga tampak seperti 3D. Apakah kita dapat membuat peta 3D? Ya, kita dapat melakukannya dengan menggunakan paket {rayshader}.\nUntuk membuat peta 3D dari peta_2023_01 yang telah kita buat sebelumnya, kita gunakan baris kode berikut.\nplot_gg(\n  ggobj = peta_2023_01,\n  width = 7,\n  height = 7,\n  scale = 250,\n  solid = FALSE,\n  shadow = TRUE,\n  shadowcolor = \"white\",\n  shadowwidth = 0,\n  shadow_intensity = 1,\n  zoom = .7,\n  phi = 85,\n  theta = 0\n)\nFungsi plot_gg() tersebut gunanya untuk menjadikan objek peta_2023_01 menjadi 3D dengan memetakan warnanya sebagai ketinggian dalam gambar 3D tersebut. Setelah baris perintah di atas dijalankan, dalam beberapa saat kita akan mendapatkan jendela baru yang muncul. Jendela tersebut seperti yang ditunjukkan pada Gambar 7.\n\n\n\n\n\nGambar 7: Jendela kamera dari peta 3D\n\n\nKetika jendela kamera tersebut masih muncul, kita dapat mengatur posisi dan propertinya dengan menggunakan fungsi render_camera(). Kita dapat mengaturnya seperti pada baris kode berikut.\nrender_camera(\n  theta = 30,\n  phi = 75\n)\nArgumen theta = 30 menyatakan bahwa sudut rotasinya adalah 30 derajat. Argumen phi = 75 menyatakan bahwa sudut azimutnya sebesar 75 derajat. Setelah itu, kita dapat merender peta 3D tersebut dengan menggunakan baris kode sebagai berikut.\nu &lt;- \"https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/4k/air_museum_playground_4k.hdr\"\n\nfail_hdri &lt;- basename(u)\n\ndownload.file(\n  url = u,\n  destfile = fail_hdri,\n  mode = \"wb\"\n)\n\nrender_highquality(\n  filename = \"curah_hujan_indonesia.png\",\n  preview = TRUE,\n  interactive = FALSE,\n  parallel = TRUE,\n  light = TRUE,\n  environment_light = fail_hdri,\n  intensity = .45,\n  rotate_env = 90,\n  width = 1280,\n  height = 720\n)\nHasil render tersebut ditunjukkan pada Gambar 8.\n\n\n\n\n\nGambar 8: Curah hujan Indonesia pada Januari 2023"
  },
  {
    "objectID": "pos/2024-08-curah-hujan-indonesia/index.html#sec-catatan-akhir",
    "href": "pos/2024-08-curah-hujan-indonesia/index.html#sec-catatan-akhir",
    "title": "Indonesia Negara Dua Musim",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah menganalisis curah hujan di Indonesia dari waktu ke waktu. Secara lebih spesifik, kita telah melihat bulan-bulan apa saja yang curah hujannya relatif lebih tinggi. Selain itu, kita juga telah melihat bagaimana peta, baik 2D maupun 3D, dapat kita gunakan untuk memvisualisasikan data curah hujan dari berbagai wilayah Indonesia. Dengan cara ini, kita dapat mengidentifikasi daerah-daerah mana yang curah hujannya lebih tinggi dan demikian juga sebaliknya."
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "",
    "text": "Alkisah ada seorang ksatria yang sakti mandraguna bernama Hanoman. Ksatria yang merupakan seekor kera putih itu suatu ketika diutus oleh Rama untuk mencari tanaman obat di Himalaya. Ia pun pergi ke gunung itu tanpa pikir panjang. Sesampainya di sana, ia baru sadar bahwa ternyata ia tidak mengetahui bentuk dan rupa tanaman itu seperti apa. Tak habis akal, ia pun memotong gunung itu dan membawanya ke hadapan Rama. Akhirnya, Rama dan pasukannya menemukan tanaman obat itu, kemudian mereka memakannya sehingga pulih seperti sedia kala.\nCerita heroik tersebut meninggalkan beberapa pesan. Pertama, kita perlu memberikan instruksi sedetail mungkin agar instruksi tersebut dapat terlaksana dengan efektif dan efisien. Kedua, sikap Hanoman dalam cerita itu menyiratkan keinginan yang sangat kuat untuk menyelesaikan sebuah persoalan. Terakhir, kadang-kadang memindahkan gunung adalah solusi terbaik! Pesan terakhir ini relevan dengan persoalan berikut.\nKarena begitu banyaknya gunung-gunung di Indonesia, kita pilih empat saja berdasarkan kepopulerannya. Berdasarkan Google Trends, keempat gunung tersebut adalah Gunung Agung, Bromo, Merapi, dan Semeru. Untuk membandingkan keempat gunung tersebut, kita dapat “memindahkannya” sehingga berdampingan satu sama lain. Dengan demikian, kita dapat mengamatinya secara lebih mudah untuk kemudian kita bandingkan tinggi dan besar keempat gunung tersebut.\nTak seperti Hanoman yang memindahkan potongan Gunung Himalaya secara harfiah, kita hanya memindahkan representasi Gunung Agung, Bromo, Merapi, dan Semeru saja. Jika Hanoman melakukan dengan kesaktiannya, kita akan memindahkan keempat gunung tersebut dengan pemrograman R. Meskipun ada beberapa perbedaan, apa yang kita lakukan nanti intinya kurang lebih sama dengan yang dilakukan Hanoman.\nTak perlu berlama-lama, kita keluarkan kesaktian kita. Eh, maksudku, kita siapkan alat-alat yang diperlukan.\nlibrary(tidyverse)\nlibrary(raster)\nlibrary(terra)\nlibrary(rayshader)"
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memahami-ide-dasarnya",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memahami-ide-dasarnya",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "Memahami Ide Dasarnya",
    "text": "Memahami Ide Dasarnya\nSebelum kita menggambar model 3D Gunung Agung, Bromo, Merapi, dan Semeru, baik apabila kita bahas ide dasarnya: beberapa objek 3D itu dapat dinyatakan ke dalam sebuah matriks elevasi. Baris dan kolom matriks tersebut menyatakan koordinat \\(x\\) dan \\(y\\), sedangkan elemen-elemennya menyatakan ketinggiannya. Misalnya, kita memiliki matriks elevasi seperti berikut.\n\n\n   1  2  3  4  5\n1 28 30 30 26 19\n2 25 29 31 28 19\n3 24 31 37 32 19\n4 22 28 33 30 18\n5 17 19 20 19 15\n\n\nDari matriks elevasi tersebut, kita dapat membuat objek 3D dengan berdasarkan ketinggiannya (elemen-elemen matriks) dan posisinya (baris dan kolomnya). Tetapi sebelum itu, terlebih dahulu kita perhatikan proyeksi dua dimensinya seperti yang ditunjukkan pada Gambar 2.\n\n\n\n\n\n\n\nGambar 2: Proyeksi 2D dari sebuah objek 3D yang dibentuk dari matriks elevasi\n\n\n\n\nApakah kamu dapat membayangkan objek 3D-nya seperti apa jika proyeksi 2D-nya ditunjukkan pada Gambar 2? Ingat, warna pada diagram tersebut menggambarkan elevasi/ketinggiannya! Bandingkan imajinasimu dengan Gambar 3 berikut!\n\n\n\n\n\nGambar 3: Objek 3D sederhana\n\n\nProses seperti itu akan kita lakukan untuk menggambar model 3D Gunung Agung, Bromo, Merapi, dan Semeru. Untuk melakukannya, kita perlu memiliki matriks elevasi keempat gunung tersebut. Matriks tersebut akan kita siapkan pada bagian berikutnya."
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-mempersiapkan-data",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-mempersiapkan-data",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "Mempersiapkan Data",
    "text": "Mempersiapkan Data\nSeperti yang telah dijelaskan pada Bagian 1, kita perlu memiliki matriks elevasi Gunung Agung, Bromo, Merapi, dan Semeru. Matriks ini dapat ditemukan di banyak tempat. Salah satunya di situs webnya Derek Watkin. Sebelum mengunduh datanya, kamu perlu login terlebih dahulu ke dalam situs web NASA Earthdata.\nSetelah berhasil login, kita perlu mencari persegi tempat keempat gunung tersebut. Untuk mencarinya, kita dapat menyeret dan memperbesar laman dalam situs web tersebut. Lokasi keempat gunung tersebut ada pada enam persegi, yaitu S08E110, S08E112, S08E113, S09E112, S09E113, dan S09E115. Untuk mengunduhnya, klik perseginya dan kemudian klik tombol “Download DEM”. Setelah itu, ekstrak semua fail zip-nya. Pindahkan fail-fail tersebut ke dalam folder kerjamu.\nSampai di sini, kita memiliki enam fail dengan nama S08E110.hgt, S08E112.hgt, S08E113.hgt, S09E112.hgt, S09E113.hgt, dan S09E115.hgt dalam folder kerja kita. Kita gunakan semua fail tersebut untuk membuat matriks_elevasi dengan kode berikut.\nS08E110 &lt;- terra::rast(\"S08E110.hgt\")\nS08E112 &lt;- terra::rast(\"S08E112.hgt\")\nS08E113 &lt;- terra::rast(\"S08E113.hgt\")\nS09E112 &lt;- terra::rast(\"S09E112.hgt\")\nS09E113 &lt;- terra::rast(\"S09E113.hgt\")\nS09E115 &lt;- terra::rast(\"S09E115.hgt\")\n\nmatriks_elevasi &lt;- terra::merge(\n  S08E110, S08E112, S08E113,\n  S09E112, S09E113, S09E115\n)\nvarnames(matriks_elevasi) &lt;- \"elevasi\"\nnames(matriks_elevasi) &lt;- \"elevasi\"\nSeperti yang dilakukan Hanoman terhadap Gunung Himalaya, kita juga perlu memotong matriks_elevasi agar hanya memuat koordinat \\(x\\) dan \\(y\\) dari Gunung Agung, Bromo, Merapi, dan Semeru seperlunya saja. Potongan-potongan tersebut kita beri nama matriks_agung, matriks_bromo, matriks_merapi, dan matriks_semeru. Untuk memudahkan dalam pengolahan data berikutnya, kita ubah matriks-matriks tersebut menjadi tibble dan menambahkan satu variabel gunung untuk menjadi identifikasi nama gunungnya.\n# Gunung Agung\nbatas_agung &lt;- extent(\n  115.4562, 115.5562,\n  -8.393267, -8.293267\n)\nmatriks_agung &lt;- crop(matriks_elevasi, batas_agung)\ndf_agung &lt;- as.data.frame(matriks_agung, xy = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(gunung = \"Agung\")\n\n# Gunung Bromo\nbatas_bromo &lt;- extent(\n  112.9, 113.0,\n  -8.0, -7.9\n)\nmatriks_bromo &lt;- crop(matriks_elevasi, batas_bromo)\ndf_bromo &lt;- as.data.frame(matriks_bromo, xy = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(gunung = \"Bromo\")\n\n# Gunung Merapi\nbatas_merapi &lt;- extent(\n  110.3967, 110.4967,\n  -7.590278, -7.490278\n)\nmatriks_merapi &lt;- crop(matriks_elevasi, batas_merapi)\ndf_merapi &lt;- as.data.frame(matriks_merapi, xy = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(gunung = \"Merapi\")\n\n# Gunung Semeru\nbatas_semeru &lt;- extent(\n  112.8722, 112.9722,\n  -8.157778, -8.057778\n)\nmatriks_semeru &lt;- crop(matriks_elevasi, batas_semeru)\ndf_semeru &lt;- as.data.frame(matriks_semeru, xy = TRUE) |&gt; \n  as_tibble() |&gt; \n  mutate(gunung = \"Semeru\")\nKode di atas menghasilkan empat tibble, yaitu df_agung, df_bromo, df_merapi, dan df_semeru. Selanjutnya, kita gabung keempat tibble tersebut menjadi df_gunung.\ndf_gunung &lt;- bind_rows(\n  df_agung, df_bromo, df_merapi, df_semeru\n)\nNah, sekarang kita “pindahkan” keempat gunung tersebut dari posisi asalnya. Posisi akhir yang kita targetkan adalah posisi dengan koordinat \\(x\\) dan \\(y\\) minimumnya bernilai nol.\ndf_gunung &lt;- df_gunung |&gt; \n  group_by(gunung) |&gt; \n  mutate(\n    x_trans = x - min(x),\n    y_trans = y - min(y)\n  ) |&gt; \n  ungroup()\nApakah sampai di sini kamu berhasil menjalankan baris-baris kode di atas sampai mendapatkan df_gunung? Jika iya, selamat! Jika tidak, mungkin ada beberapa hal yang perlu dicek kembali. Tetapi jika kamu langsung ingin mendapatkan df_gunung tersebut tanpa menjalankan semua baris kode di atas, kamu dapat mendapatkannya dengan menjalankan kode berikut.\n\nload(url(\"https://github.com/jelajahstatid/jelajahstatid.github.io/raw/main/pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/aset/df_gunung.RData\"))\n\nKita telah memiliki data untuk menggambarkan Gunung Agung, Bromo, Merapi, dan Semeru secara berdampingan. Kita siap untuk melanjutkan perjalanan kita ke tahapan selanjutnya."
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memvisualisasikan-data",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memvisualisasikan-data",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "Memvisualisasikan Data",
    "text": "Memvisualisasikan Data\nKita telah bekerja keras di Bagian 2. Sekarang, kita masuk ke tahapan yang mengasyikkan. Yup, di tahapan ini kita akan memvisualisasikan data. Data yang kita gunakan adalah df_gunung. Visualisasi data pertama yang kita lakukan adalah membuat proyeksi 2D dari Gunung Agung, Bromo, Merapi, dan Semeru. Sebelum itu, kita siapkan temanya terlebih dahulu.\n\ntema_gunung &lt;- function(){\n  theme(\n      axis.title = element_blank(),\n      axis.text = element_blank(),\n      axis.ticks = element_blank(),\n      legend.position = \"right\",\n      plot.margin = margin(\n        t = 10, r = 10,\n        b = 10, l = 10,\n        unit = \"pt\"\n      )\n    )\n}\n\nSelanjutnya kita siap untuk memvisualisasikan proyeksi 2D dari Gunung Agung, Bromo, Merapi, dan Semeru. Untuk melakukannya, kita gunakan baris kode di bawah ini. Hasilnya ditunjukkan pada Gambar 4.\n\nplot_2d_gunung &lt;- df_gunung |&gt; \n  ggplot(\n    aes(x_trans, y_trans)\n  ) + \n  geom_tile(aes(fill = elevasi)) + \n  geom_contour(\n    aes(z = elevasi), \n    breaks = c(seq(500, 3500, by = 250)),\n    color = \"white\",\n    linewidth = .25,\n    alpha = .3\n  ) + \n  scale_fill_gradient(\n    name = \"Elevasi (m)\",\n    low = \"#6DAA55\",\n    high = \"#205544\"\n  ) + \n  facet_wrap(vars(gunung)) + \n  coord_fixed() +\n  tema_gunung()\n\nprint(plot_2d_gunung)\n\n\n\n\n\n\nGambar 4: Proyeksi 2D Gunung Agung, Bromo, Merapi, dan Semeru\n\n\n\n\nBerdasarkan Gambar 4 tersebut, apakah kamu sudah dapat membandingkan tinggi dan besar keempat gunung tersebut? Ya, Gunung Semeru tampak paling tinggi dibandingkan ketiga gunung lainnya. Selain itu, kita dapat melihat bahwa Gunung Bromo tampak relatif lebih luas dibandingkan ketiga gunung lainnya.\nUntuk melihat bentuk detailnya, kita dapat menggambar keempat gunung tersebut ke dalam bentuk 3D. Untuk melakukannya, kita gunakan metode yang telah dibahas pada pos sebelumnya. Bagaimana caranya? Kita jalankan kode berikut ini.\nplot_gunung &lt;- plot_2d_gunung + \n  theme(\n    legend.position = \"none\"    # Menghapus legenda\n  )\n\nplot_gg(\n  plot_gunung,\n  multicore = TRUE,\n  scale = 150\n)\nBeberapa saat setelah kode di atas kita jalankan, kita akan mendapatkan jendela kamera. Melalui jendela tersebut, kita dapat mengatur tampilan objek 3D-nya sesuai yang kita inginkan. Selain itu, kita juga dapat mengatur tampilannya dengan baris kode, misalnya seperti berikut.\nrender_camera(\n    theta = 45,\n    phi = 55,\n    zoom = .85\n)\nSetelah kita mendapatkan tampilan yang cocok, kita jalankan kode berikut untuk merender gambarnya.\nrender_snapshot()\nHasil gambarnya seperti yang ditunjukkan pada Gambar 5.\n\n\n\n\n\nGambar 5: Model 3D Gunung Agung, Bromo, Merapi, dan Semeru\n\n\nBerdasarkan Gambar 5, kita dapat membandingkan tinggi dan besar keempat gunung tersebut. Gunung semeru tampak paling tinggi. Gunung Bromo bentuknya lebih melebar dibandingkan dengan ketiga gunung lainnya. Selain itu, berdasarkan gambar tersebut kita dapat membandingkan bentuk detail keempat gunung tersebut."
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memperkirakan-tinggi-dan-volume",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-memperkirakan-tinggi-dan-volume",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "Memperkirakan Tinggi dan Volume",
    "text": "Memperkirakan Tinggi dan Volume\nSecara sederhana, sebenarnya kita telah dapat membandingkan tinggi dan volume keempat gunung pada Gambar 5. Akan tetapi, kita juga dapat memperkirakan berapakah tinggi dan volume keempat gunung tersebut.\nPertama, kita akan menentukan tinggi Gunung Agung, Bromo, Merapi, dan Semeru. Berdasarkan Wikipedia, tinggi keempat gunung tersebut secara berturut-turut adalah 3.142, 2.614, 2.968, dan 3.676. Sekarang, kita perkirakan tinggi keempat gunung tersebut dengan menggunakan data elevasi dalam df_gunung.\n\nketinggian &lt;- df_gunung |&gt; \n  group_by(gunung) |&gt; \n  summarise(\n    elevasi_maksimum = max(elevasi, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\nprint(ketinggian)\n\n# A tibble: 4 × 2\n  gunung elevasi_maksimum\n  &lt;chr&gt;             &lt;int&gt;\n1 Agung              3013\n2 Bromo              2775\n3 Merapi             2918\n4 Semeru             3669\n\n\nMeskipun hasilnya berbeda dengan informasi dalam Wikipedia, kita mendapatkan ketinggian-ketinggian yang tak jauh berbeda. Agar lebih mudah dalam membandingkan tinggi keempat gunung tersebut, kita buat diagram batangnya. Diagram batang tersebut disajikan pada Gambar 6.\n\nketinggian |&gt; \n  mutate(gunung = fct_reorder(gunung, -elevasi_maksimum)) |&gt; \n  ggplot(aes(x = gunung, y = elevasi_maksimum)) + \n  geom_col(\n    aes(fill = elevasi_maksimum),\n    show.legend = FALSE\n  ) + \n  scale_fill_viridis_c() + \n  theme_minimal() + \n  labs(\n    x = \"Gunung\",\n    y = \"Ketinggian (mdpl)\"\n  )\n\n\n\n\n\n\nGambar 6: Ketinggian Gunung Agung, Bromo, Merapi, dan Semeru\n\n\n\n\nBerikutnya, kita akan memperkirakan volume keempat gunung tersebut. Volume yang dimaksud di sini adalah volume potongan tiap gunung pada Gambar 5. Untuk itu, kita hitung ada berapa petak data dalam setiap data gunungnya.\n\ndf_gunung |&gt; \n  group_by(gunung) |&gt; \n  summarise(\n    banyak_petak = n(),\n    .groups = \"drop\"\n  )\n\n# A tibble: 4 × 2\n  gunung banyak_petak\n  &lt;chr&gt;         &lt;int&gt;\n1 Agung        129600\n2 Bromo        129240\n3 Merapi       129600\n4 Semeru       129600\n\n\nSebagian besar, banyak petaknya adalah 129.600 kecuali data untuk Gunung Bromo. Untuk itu, banyak petak pada Gunung Bromo kita samakan saja dengan ketiga gunung lainnya.\nAlas potongan gunung-gunung tersebut memiliki ukuran 0,1 derajat × 0,1 derajat. Karena 0,1 derajat kurang lebih sama dengan 110 km, ukuran alasnya berarti 11 km × 11 km dan luasnya adalah 121 km2 atau 121.000.000 m2. Padahal alas tersebut berisi 129.600 petak. Dengan demikian, luas petak tersebut dapat dihitung seperti berikut.\n\nluas_petak_est &lt;- 121000000 / 129600\nprint(luas_petak_est)\n\n[1] 933.642\n\n\nDengan demikian, kita memeroleh luas per petaknya sekitar 933,642 m2. Sekarang coba kita kembali ke belakang. Ketika kita mengunduh data matriks elevasi dari situs webnya Derek Watkin, di situ terdapat keterangan seperti berikut.\n\nThis interface attempts to ease the pain of downloading 30-meter resolution elevation data from the Shuttle Radar Topography Mission.\n\nYup, petak-petak tersebut ukurannya adalah 30 m × 30 m. Dengan demikian, luas petaknya adalah 900 m2. Perkiraan kita tadi cukup dekat dengan nilai ini.\nVolume potongan keempat gunung tersebut merupakan jumlah dari hasil kali luas setiap petak dan tinggi petak tersebut.\n\\[\n\\text{Volume} = \\sum_{i=1}^{n} L_{i} \\cdot h_{i}\n\\]\ndengan \\(L_{i}\\) dan \\(h_{i}\\) secara berturut-turut adalah luas dan tinggi tiap-tiap petak. Nah, sekarang kita hitung volume keempat gunung tersebut.\n\nvolume &lt;- df_gunung |&gt; \n  mutate(\n    volume_petak = 900 * elevasi\n  ) |&gt; \n  group_by(gunung) |&gt; \n  summarise(\n    volume_m3 = sum(volume_petak),\n    .groups = \"drop\"\n  )\n\nprint(volume)\n\n# A tibble: 4 × 2\n  gunung    volume_m3\n  &lt;chr&gt;         &lt;dbl&gt;\n1 Agung  157764598200\n2 Bromo  256498122600\n3 Merapi 164324547900\n4 Semeru 237914817300\n\n\nKarena kita biasanya lebih mudah membayangkan volume dengan satuan liter, kita dapat mengkonversi satuan volumenya menjadi liter.\n\nvolume &lt;- volume |&gt; \n  mutate(\n    volume_liter = volume_m3 * 1000\n  )\n\nprint(volume)\n\n# A tibble: 4 × 3\n  gunung    volume_m3 volume_liter\n  &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n1 Agung  157764598200      1.58e14\n2 Bromo  256498122600      2.56e14\n3 Merapi 164324547900      1.64e14\n4 Semeru 237914817300      2.38e14\n\n\nPotongan gunung manakah yang paling besar? Potongan gunung Bromo-lah yang paling besar, yaitu sekitar 2,58 × 1014 liter. Selanjutnya kita buat diagram batang yang merepresentasikan volume potongan keempat gunung tersebut. Hasilnya disajikan pada Gambar 7.\n\nvolume |&gt; \n  mutate(\n    gunung = fct_reorder(gunung, -volume_liter)\n  ) |&gt; \n  ggplot(aes(x = gunung, y = volume_liter)) + \n  geom_col(\n    aes(fill = volume_liter),\n    show.legend = FALSE\n  ) + \n  scale_fill_viridis_c() + \n  theme_minimal() + \n  labs(\n    x = \"Gunung\",\n    y = \"Volume (liter)\"\n  )\n\n\n\n\n\n\nGambar 7: Volume potongan Gunung Agung, Bromo, Merapi, dan Semeru"
  },
  {
    "objectID": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-catatan-akhir",
    "href": "pos/2024-08-gunung-agung-bromo-merapi-dan-semeru/index.html#sec-catatan-akhir",
    "title": "Gunung Agung, Bromo, Merapi, dan Semeru",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah membandingkan seberapa tinggi dan besar Gunung Agung, Bromo, Merapi, dan Semeru. Hal itu kita lakukan dengan dua jalan: pengamatan dan perhitungan. Ketika menggunakan cara pengamatan, kita gambarkan representasi keempat gunung tersebut ke dalam bentuk 2D maupun 3D. Hasilnya seperti dapat dilihat pada Gambar 4 dan Gambar 5. Ketika kita menggunakan cara perhitungan, kita gunakan data matriks elevasi keempat gunung tersebut untuk memperkirakan tinggi dan volumenya. Cara ini kita lakukan pada Bagian 4."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "",
    "text": "Pada tahun 2024, aku dan tiga kolega dari University of Auckland, Universitas Pendidikan Indonesia, dan SMA Negeri 7 Yogyakarta merevisi buku teks kami, baik buku siswa maupun buku panduan guru. Dalam edisi revisi buku-buku tersebut, kami mencoba untuk mempromosikan tema Tujuan Pembangunan Berkelanjutan.\nSalah satu aktivitas pembelajaran dalam edisi revisi tersebut adalah pemodelan keanekaragaman spesies tanaman berpohon di Kepulauan Raja Ampat. Dengan aktivitas pembelajaran ini, peserta didik diharapkan dapat menggunakan berbagai macam fungsi matematika untuk melakukan pemodelan serta menginterpretasi dan mengevaluasi model-model yang mereka hasilkan. Tak hanya itu, mereka juga diharapkan menyadari betapa kayanya bumi Kepulauan Raja Ampat.\nDi artikel ini, aku akan bercerita tentang bagaimana menemukan data keanekaragaman hayati di Kepulauan Raja Ampat tersebut. Selain itu, aku juga akan mendemonstrasikan bagaimana mengolah dan memodelkan data tersebut dengan model linear maupun nonlinear."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-menemukan-data",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-menemukan-data",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Petulangan Menemukan Data",
    "text": "Petulangan Menemukan Data\nSalah satu hobiku adalah membaca. Meskipun bidang pekerjaanku adalah Pendidikan Matematika, tak jarang aku “tersesat” dan membaca berbagai bahan bacaan di luar bidang itu. Suatu ketika, aku menemukan sebuah artikel menarik di Ecography. Artikel yang dikarang oleh tim peneliti dari University of Göttingen, Universitas Papua, dan University of South Australia tersebut membahas tentang dampak perbedaan pengambilan sampel terhadap hubungan antara keanekaragaman spesies tanaman berkayu dan luas pulau-pulau kecil di Kepulauan Raja Ampat.\nMenurutku artikel tersebut menarik. Namun, artikel tersebut tidak melampirkan data mentah yang digunakan. Oleh karena itu, aku langsung berkirim surel ke salah satu pengarangnya untuk meminta data mentahnya dan sekalian meminta izin untuk menggunakannya sebagai bahan ajar ke dalam buku-buku kami. Dengan ramah pengarang tersebut menunjukkan sebuah artikel yang memuat data mentah tersebut. Ia juga dengan senang memberikan izin penggunaan data tersebut asalkan dibarengi dengan pemberian atribusi yang tepat.\nData mentah yang aku perlukan letaknya ada di bagian lampiran artikel tersebut. Agar pembahasannya nanti sederhana, kita akan menggunakan data dalam bagian Suppl. material 1: Island Data saja. Kita nanti hanya akan mengolah data yang terkait dengan variabel luas pulau dan banyaknya spesies tanaman berkayu dalam pulau tersebut untuk memodelkan hubungan antara kedua variabel itu.\n\n\n\n\n\n\nCatatan\n\n\n\nSelain hubungan antara luas pulau dan banyaknya spesies, data dalam artikel tersebut juga memungkinkan untuk dilakukan analisis sampai level transek dan subtransek. Analisis tentang transek dan subtransek tersebut pada umumnya digunakan untuk mengidentifikasi kepadatan spesies dalam pulau-pulau yang ada. Analisis pada level transek dan subtransek tersebut tidak dilakukan dalam artikel ini. Jika pembaca ingin mengetahui analisis semacam itu, silakan kunjungi aplikasi Shiny yang telah aku kembangkan. Aplikasi inilah yang digunakan sebagai bahan ajar penunjang dalam buku-buku yang kami revisi."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-jelajah-data",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-jelajah-data",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Menjelajah Data",
    "text": "Menjelajah Data\nPetualangan kita lanjutkan. Karena data sudah ada, sekarang kita siap untuk mengeksplorasinya dengan R. Pertama-tama, kita panggil paket yang diperlukan. Paket {tidyverse} kita gunakan untuk mengimpor, mengolah, dan memvisualisasikan data. Paket {ggtext} kita gunakan untuk menyesuaikan label/teks pada diagram yang akan kita buat nantinya.\n\nlibrary(tidyverse)\nlibrary(ggtext)\n\nAgar datanya nanti mudah kita impor, aku unduh fail data tersebut, kemudian aku hapus bagian yang tidak kita perlukan (seperti keterangan fail dan deskripsi variabelnya) dan aku simpan kembali menjadi fail csv. Fail data yang baru tersebut dapat diakses di tautan ini.\nKita impor data tersebut dengan fungsi read_csv(). Untuk melihat gambaran umum data tersebut, kita dapat menggunakan fungsi glimpse().\n\ndata_pulau &lt;- read_csv(\"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/main/pos/2024-08-keanekaragaman-hayati-raja-ampat/data/oo_444807.csv\")\n\nglimpse(data_pulau)\n\nRows: 60\nColumns: 12\n$ island_ID          &lt;chr&gt; \"GB1\", \"GB2\", \"GB3\", \"GB4\", \"GB5\", \"GB6\", \"GB7\", \"G…\n$ island_coordinates &lt;chr&gt; \"-0.520461, 130.580800\", \"-0.517484, 130.575020\", \"…\n$ island_area        &lt;dbl&gt; 4774.04, 7.29, 2329.91, 8.06, 20.27, 316.83, 1575.2…\n$ island_perimeter   &lt;dbl&gt; 303.14, 10.24, 184.23, 11.33, 16.60, 85.11, 149.77,…\n$ distance_Gam       &lt;dbl&gt; 59.30, 56.65, 172.07, 191.69, 136.06, 381.77, 344.6…\n$ buffer_area_1000m  &lt;dbl&gt; 146.90, 71.06, 45.80, 44.91, 47.01, 33.60, 36.22, 5…\n$ tree_basal_area    &lt;dbl&gt; 17.49, 0.95, 15.86, 0.87, 6.65, 20.04, 14.86, 20.65…\n$ species_number     &lt;dbl&gt; 18, 1, 17, 1, 2, 8, 12, 13, 18, 5, 9, 14, 10, 11, 9…\n$ soil_depth_mean    &lt;dbl&gt; 11.40, 0.00, 3.72, 0.00, 0.00, 3.94, 9.77, 12.74, 0…\n$ leaf_litter_cover  &lt;dbl&gt; 66.4, 0.0, 96.0, 0.0, 0.0, 60.0, 93.0, 78.0, 67.0, …\n$ no_transects       &lt;dbl&gt; 5, 0, 4, 0, 0, 2, 4, 4, 4, 1, 3, 4, 2, 2, 1, 0, 0, …\n$ no_plots           &lt;dbl&gt; 25, 1, 20, 1, 1, 10, 20, 20, 20, 5, 15, 20, 10, 10,…\n\n\nData tersebut memuat 60 baris dan 12 kolom. Dari keduabelas kolom tersebut, kita hanya akan menganalisis dua di antaranya, yaitu island_area (luas pulau dalam m2) dan species_number (banyaknya spesies). Untuk itu, kita pilih kedua variabel tersebut dengan fungsi select(). Kita ganti nama kedua variabel tersebut menjadi luas_pulau dan banyak_spesies dengan fungsi rename().\n\ndata_pulau &lt;- data_pulau |&gt; \n  select(island_area, species_number) |&gt; \n  rename(\n    luas_pulau = island_area,\n    banyak_spesies = species_number\n  )\n\nhead(data_pulau)\n\n# A tibble: 6 × 2\n  luas_pulau banyak_spesies\n       &lt;dbl&gt;          &lt;dbl&gt;\n1    4774.               18\n2       7.29              1\n3    2330.               17\n4       8.06              1\n5      20.3               2\n6     317.                8\n\n\nSekarang kita mendapatkan data_pulau yang lebih sederhana dan rapi. Kita lihat distribusi luas_pulau-nya seperti apa. Perhatikan Gambar 1.\n\ndata_pulau |&gt; \n  ggplot(aes(x = luas_pulau)) + \n  geom_histogram(\n    fill = \"#427D9D\",\n    color = \"white\"\n  ) + \n  theme_minimal() + \n  theme(\n    axis.title.x = element_markdown()\n  ) + \n  labs(\n    x = \"Luas pulau (m^2^)\",\n    y = \"Frekuensi\"\n  )\n\n\n\n\n\n\nGambar 1: Distribusi luas_pulau.\n\n\n\n\nBagaimana dengan distribusi banyak_spesies-nya? Silakan cermati Gambar 2.\n\ndata_pulau |&gt; \n  ggplot(aes(x = banyak_spesies)) + \n  geom_histogram(\n    fill = \"#9BBEC8\",\n    color = \"white\"\n  ) + \n  theme_minimal() + \n  labs(\n    x = \"Banyak spesies\",\n    y = \"Frekuensi\"\n  )\n\n\n\n\n\n\nGambar 2: Distribusi banyak_spesies.\n\n\n\n\nApakah terdapat hubungan antara luas sebuah pulau dengan banyaknya spesies yang tinggal di pulau tersebut? Untuk mengetahuinya, kita buat diagram pencar yang merepresentasikan hubungan antara luas_pulau dan banyak_spesies.\n\ndiagram_pencar &lt;- data_pulau |&gt; \n  ggplot(\n    aes(x = luas_pulau, y = banyak_spesies)\n  ) + \n  geom_point(\n    color = \"#427D9D\",\n    size = 3\n  ) + \n  theme_minimal() + \n  theme(\n    axis.title.x = element_markdown()\n  ) + \n  labs(\n    x = \"Luas pulau (m^2^)\",\n    y = \"Banyak spesies\"\n  )\n\nprint(diagram_pencar)\n\n\n\n\n\n\nGambar 3: Hubungan antara luas_wilayah dan banyak_spesies.\n\n\n\n\nGambar 3 menunjukkan adanya hubungan antara luas_pulau dan banyak_spesies. Semakin luas sebuah pulau, semakin banyak spesies yang tinggal di pulau tersebut. Lalu, bagaimana hubungan tersebut? Pertanyaan ini akan dijawab dengan melakukan pemodelan. Model yang akan kita pakai adalah fungsi linear, pangkat, logaritma, dan Weibull kumulatif. Keempat model tersebut masuk ke dalam dua kategori, yaitu model linear dan nonlinear.\nMengapa model linear digunakan di sini? Padahal titik-titik data pada Gambar 3 jelas-jelas tidak mengikuti pola linear. Model linear dimasukkan di sini untuk memberikan contoh pemodelan yang paling sederhana."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-model-linear",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-model-linear",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Pemodelan Linear",
    "text": "Pemodelan Linear\nModel linear merupakan model yang sederhana dan mudah dilakukan. Untuk melakukan pemodelan linear, kita menggunakan fungsi lm().\n\nmodel_linear &lt;- lm(\n  formula = banyak_spesies ~ luas_pulau,\n  data = data_pulau\n)\n\nprint(model_linear)\n\n\nCall:\nlm(formula = banyak_spesies ~ luas_pulau, data = data_pulau)\n\nCoefficients:\n(Intercept)   luas_pulau  \n   3.662650     0.002549  \n\n\nBerdasarkan pemodelan linear tersebut, kita mendapatkan persamaan dengan konstanta 3,662650 dan koefisien variabel luas_pulau sebesar 0,002549. Visualisasi model linear tersebut disajikan pada Gambar 4!\n\nKodediagram_pencar + \n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x,\n    se = FALSE,\n    color = \"#164863\"\n  ) + \n  geom_richtext(\n    x = 9000,\n    y = 30,\n    label = \"*y* = 3,662650 + 0,002549*x*\",\n    hjust = 1,\n    color = \"#164863\"\n  )\n\n\n\n\n\n\nGambar 4: Model linear untuk hubungan antara luas_wilayah dan banyak_spesies."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-model-nonlinear",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-model-nonlinear",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Pemodelan Nonlinear",
    "text": "Pemodelan Nonlinear\nPada Bagian 3, kita telah memodelkan hubungan antara luas_pulau dan banyak_spesies dengan model linear. Sekarang, kita akan memodelkan hubungan kedua variabel tersebut dengan model nonlinear. Model nonlinear pertama kita adalah fungsi pangkat. Persamaan umum untuk fungsi pangkat ditunjukkan pada Persamaan 1.\n\\[\ny = c x^z\n\\tag{1}\\]\nUntuk melakukan pemodelan nonlinear, kita dapat menggunakan fungsi nls(). Fungsi ini membutuhkan nilai awal untuk \\(c\\) dan \\(z\\) pada Persamaan 1. Agar sederhana, kita pilih nilai-nilai awalnya \\(a = 1\\) dan \\(z = 1\\).\n\nmodel_pangkat &lt;- nls(\n  formula = banyak_spesies ~ a * luas_pulau^z,\n  data = data_pulau,\n  start = c(a = 1, z = 1)\n)\n\nprint(model_pangkat)\n\nNonlinear regression model\n  model: banyak_spesies ~ a * luas_pulau^z\n   data: data_pulau\n     a      z \n0.9239 0.3574 \n residual sum-of-squares: 306.5\n\nNumber of iterations to convergence: 17 \nAchieved convergence tolerance: 5.839e-06\n\n\nDengan demikian, kita mendapatkan \\(a\\approx\\text{0,9239}\\) dan \\(z\\approx\\text{0,3574}\\). Model ini dapat ditunjukkan pada Gambar 5.\n\nKodea_pangkat &lt;- coef(model_pangkat)[\"a\"]\nz_pangkat &lt;- coef(model_pangkat)[\"z\"]\n\ndiagram_pencar + \n  geom_function(\n    fun = function(x) a_pangkat * x^z_pangkat,\n    color = \"#164863\",\n    linewidth = 1\n  ) + \n  geom_richtext(\n    x = 8000,\n    y = 26,\n    label = \"*y* = 0,9239*x*&lt;sup&gt;0,3574&lt;/sup&gt;\",\n    hjust = .5\n  )\n\n\n\n\n\n\nGambar 5: Model fungsi pangkat untuk hubungan antara luas_wilayah dan banyak_spesies.\n\n\n\n\nKita lanjutkan pemodelannya dengan menggunakan model logaritma. Persamaan fungsi logaritma yang kita gunakan ditunjukkan pada Persamaan 2.\n\\[\ny = c + z\\log{x}\n\\tag{2}\\]\nKita menggunakan metode yang serupa dengan sebelumnya. Kita memanfaatkan fungsi nls() dengan nilai-nilai awal \\(c=1\\) dan \\(z=1\\).\n\nmodel_log &lt;- nls(\n  formula = banyak_spesies ~ c + z * log10(luas_pulau),\n  data = data_pulau,\n  start = c(c = 1, z = 1)\n)\n\nprint(model_log)\n\nNonlinear regression model\n  model: banyak_spesies ~ c + z * log10(luas_pulau)\n   data: data_pulau\n     c      z \n-5.347  6.228 \n residual sum-of-squares: 284.6\n\nNumber of iterations to convergence: 1 \nAchieved convergence tolerance: 1.058e-08\n\n\nBerdasarkan pemodelan tersebut, kita mendapatkan \\(c\\approx\\text{-5,347}\\) dan \\(z\\approx\\text{6,228}\\). Untuk melihat visualisasi model ini, silakan perhatikan Gambar 6!\n\nKodec_log &lt;- coef(model_log)[\"c\"]\nz_log &lt;- coef(model_log)[\"z\"]\n\ndiagram_pencar + \n  geom_function(\n    fun = function(x) c_log + z_log * log10(x),\n    color = \"#164863\",\n    linewidth = 1\n  ) + \n  geom_richtext(\n    x = 12000,\n    y = 24,\n    label = \"*y* = -5,347 + 6,228 log(*x*)\",\n    hjust = 1\n  )\n\n\n\n\n\n\nGambar 6: Model fungsi logaritma untuk hubungan antara luas_wilayah dan banyak_spesies.\n\n\n\n\nSekarang kita melakukan pemodelan yang terakhir. Model yang kita gunakan adalah fungsi Weibull kumulatif. Persamaan fungsi ini ditunjukkan pada Persamaan 3.\n\\[\ny = d \\left( 1 - e^{-z x^f} \\right)\n\\tag{3}\\]\nUntuk menggunakan nls(), kita gunakan nilai-nilai awal \\(d=1\\), \\(z = 1\\), dan \\(f = 1\\).\nmodel_weibull &lt;- nls(\n  formula = banyak_spesies ~ d * (1 - exp(-z * luas_pulau^f)),\n  data = data_pulau,\n  start = c(d = 1, z = 1, f = 1)\n)\n\nprint(model_weibull)\nUh oh! Kita mendapatkan pesan error setelah menjalankan perintah-perintah di atas. Pesannya seperti ini.\nError in nls(formula = banyak_spesies ~ d * (1 - exp(-z * luas_pulau^f)),  :\n    singular gradient\nApa yang salah? Kesalahannya terletak pada nilai-nilai awal \\(d\\), \\(z\\), dan \\(f\\) yang kita berikan.\nSalah satu seni dalam menggunakan fungsi nls() adalah penentukan nilai-nilai awalnya. Nilai-nilai awal tersebut sebaiknya dipilih agar mendekati nilai-nilai yang sebenarnya. Untuk melakukannya, kita dapat memanfaatkan alat lain, misalnya kalkulator grafik Desmos.\nDengan menginputkan data yang kita punya, yaitu data_pulau, ke dalam kalkulator grafik Desmos, kita dapat memodelkannya. Tangkapan layar hasil pemodelan tersebut ditunjukkan pada Gambar 7.\n\n\n\n\n\nGambar 7: Pemodelan dengan fungsi Weibull dengan kalkulator grafik Desmos.\n\n\nPemodelan dengan kalkulator grafik Desmos tersebut menghasilkan \\(d\\approx\\text{21,9586}\\), \\(z\\approx\\text{0,0125515}\\), dan \\(f\\approx\\text{0,608648}\\). (Pemodelan tersebut dapat diakses melalui tautan ini.) Kita gunakan nilai-nilai tersebut sebagai nilai-nilai awal untuk nls().\n\nmodel_weibull &lt;- nls(\n  formula = banyak_spesies ~ d * (1 - exp(-z * luas_pulau^f)),\n  data = data_pulau,\n  start = c(d = 21.9586, z = 0.0125515, f = 0.608648)\n)\n\nprint(model_weibull)\n\nNonlinear regression model\n  model: banyak_spesies ~ d * (1 - exp(-z * luas_pulau^f))\n   data: data_pulau\n       d        z        f \n21.95860  0.01255  0.60865 \n residual sum-of-squares: 186.3\n\nNumber of iterations to convergence: 0 \nAchieved convergence tolerance: 6.004e-06\n\n\nUntuk melihat visualisasi hasil pemodelan dengan fungsi Weibull tersebut, silakan perhatikan Gambar 8.\n\nKoded_weibull &lt;- coef(model_weibull)[\"d\"]\nz_weibull &lt;- coef(model_weibull)[\"z\"]\nf_weibull &lt;- coef(model_weibull)[\"f\"]\n\ndiagram_pencar + \n  geom_function(\n    fun = function(x) d_weibull * (1 - exp(-z_weibull * x^f_weibull)),\n    color = \"#164863\",\n    linewidth = 1\n  ) + \n  geom_richtext(\n    x = 12000,\n    y = 24,\n    label = \"*y* = 21,95860(1 - *e*&lt;sup&gt;-0,01255*x*&lt;sup&gt;0,60865&lt;/sup&gt;&lt;/sup&gt;)\",\n    hjust = 1\n  )\n\n\n\n\n\n\nGambar 8: Model fungsi Weibull untuk hubungan antara luas_wilayah dan banyak_spesies."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-evaluasi-model",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#sec-evaluasi-model",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Mengevaluasi Model",
    "text": "Mengevaluasi Model\nPada Bagian 3 dan Bagian 4, kita telah mendapatkan empat model untuk memodelkan hubungan antara luas_pulau dan banyak_spesies. Keempat model tersebut diringkas pada Tabel 1.\n\n\nTabel 1: Model-model untuk luas_pulau vs. banyak_spesies.\n\n\n\n\n\n\n\nModel\nPersamaan\n\n\n\nLinear\n\\(y = \\text{3,662650} + \\text{0,002549}x\\)\n\n\nPangkat\n\\(y = \\text{0,9239}x^\\text{0,3574}\\)\n\n\nLogaritma\n\\(y = -\\text{5,347} + \\text{6,228} \\log{x}\\)\n\n\nWeibull\n\\(\\text{21,95860}\\left(1 - e^{-\\text{0,01255}x^\\text{0,60865}}\\right)\\)\n\n\n\n\n\n\nDari keempat model tersebut, manakah yang paling baik untuk memodelkan hubungan antara luas_pulau dan banyak_spesies? Untuk menjawab ini, kita dapat menggunakan akar kuadrat dari rerata galat kuadrat (root mean square error, RMSE).\nUntuk memahami RMSE tersebut, kita perlu mengetahui apa itu galat dari sebuah model. Galat merupakan selisih antara nilai sebenarnya dengan nilai hasil estimasi dari model. Untuk model linear pada Tabel 1, galat-galatnya direpresentasikan sebagai panjang ruas-ruas garis vertikal pada Gambar 9. Galatnya positif jika titik datanya berada di atas modelnya. Sebaliknya, galatnya negatif jika titik datanya berada di bawah modelnya.\n\nKodeest_spesies &lt;- fitted.values(model_linear)\ngalat_linear &lt;- resid(model_linear)\n\ndata_pulau_linear &lt;- data_pulau |&gt; \n  mutate(\n    est_spesies = est_spesies,\n    galat = galat_linear\n  )\n\ndiagram_pencar + \n  geom_segment(\n    data = data_pulau_linear,\n    aes(x = luas_pulau, y = banyak_spesies, yend = est_spesies),\n    color = \"#9BBEC8\"\n  ) + \n  geom_smooth(\n    method = \"lm\",\n    formula = y ~ x,\n    se = FALSE,\n    color = \"#164863\"\n  ) + \n  geom_richtext(\n    x = 9000,\n    y = 30,\n    label = \"*y* = 3,662650 + 0,002549*x*\",\n    hjust = 1,\n    color = \"#164863\"\n  )\n\n\n\n\n\n\nGambar 9: Galat-galat yang direpresentasikan sebagai panjang ruas-ruas garis vertikal.\n\n\n\n\nUntuk mendapatkan galat-galat dari sebuah model, kita dapat menggunakan fungsi resid() atau residuals(). Dengan demikian, RMSE dari keempat model dalam Tabel 1 dapat ditentukan seperti berikut.\n\nRMSE_linear &lt;- sqrt(mean(resid(model_linear)^2))\nRMSE_pangkat &lt;- sqrt(mean(resid(model_pangkat)^2))\nRMSE_log &lt;- sqrt(mean(resid(model_log)^2))\nRMSE_weibull &lt;- sqrt(mean(resid(model_weibull)^2))\n\nprint(RMSE_linear)\n\n[1] 4.682503\n\nprint(RMSE_pangkat)\n\n[1] 2.260007\n\nprint(RMSE_log)\n\n[1] 2.177911\n\nprint(RMSE_weibull)\n\n[1] 1.762084\n\n\nUntuk lebih mudah dalam membandingkan RMSE keempat model tersebut, kita visualisasikan nilai-nilai RMSE tersebut. Perhatikan Gambar 10!\n\nKodermse &lt;- c(RMSE_linear, RMSE_pangkat, RMSE_log, RMSE_weibull)\nnama_model &lt;- c(\"Linear\", \"Pangkat\", \"Logaritma\", \"Weibull\")\n\ndata_rmse &lt;- data.frame(\n  model = nama_model,\n  rmse = rmse\n)\n\ndata_rmse |&gt; \n  mutate(\n    model = fct_reorder(model, -rmse)\n  ) |&gt; \n  ggplot(aes(x = model, y = rmse)) + \n  geom_col(\n    aes(fill = rmse),\n    show.legend = FALSE\n  ) + \n  scale_fill_gradient(low = \"#9BBEC8\", high = \"#164863\") + \n  theme_minimal() + \n  labs(\n    x = \"Model\",\n    y = \"RMSE\"\n  )\n\n\n\n\n\n\nGambar 10: Nilai RMSE keempat model.\n\n\n\n\nModel yang baik memiliki galat yang lebih kecil. Dengan demikian, semakin kecil RMSE sebuah model, semakin baik model tersebut. Berdasarkan Gambar 10, kita dapat melihat bahwa model Weibull merupakan model yang paling baik dibandingkan ketiga model lainnya."
  },
  {
    "objectID": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#catatan-akhir",
    "href": "pos/2024-08-keanekaragaman-hayati-raja-ampat/index.html#catatan-akhir",
    "title": "Pemodelan Keanekaragaman Hayati di Kepulauan Raja Ampat",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nBanyak sekali set data riil yang dapat dimanfaatkan untuk keperluan pembelajaran Matematika. Artikel ini memperlihatkan bahwa set data tentang keanekaragaman tanaman berpohon di Kepulauan Raja Ampat merupakan salah satunya. Set data seperti ini tidak hanya berpotensi untuk membuat matematika semakin membumi, tetapi juga dapat menyadarkan peserta didik terhadap kekayaan alam Kepulauan Raja Ampat.\nSecara lebih khusus, artikel ini mendemonstrasikan strategi untuk mendapatkan dan mengolah data tersebut hingga siap pakai. Strategi tersebut diceritakan mulai dari bagaimana proses penemuan data tersebut. Proses tersebut diceritakan pada Bagian 1. Setelah itu, data yang diperoleh juga perlu dikenali struktur dan isinya agar memudahkan kita dalam mengolahnya. Hal ini dipaparkan pada Bagian 2.\nPemodelan data juga telah didemonstrasikan pada Bagian 3 dan Bagian 4. Meskipun pemodelan dalam bagian itu dipaparkan secara ringkas, pemaparan tersebut diharapkan dapat memberikan gambaran umum tentang bagaimana memodelkan data, khususnya ketika kita menggunakan R. Terakhir, evaluasi model-model yang diperoleh juga telah didemonstrasikan secara sederhana di Bagian 5."
  },
  {
    "objectID": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html",
    "href": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html",
    "title": "Membuat Statistik Menjadi Dinamis dan Interaktif",
    "section": "",
    "text": "Jelajah data itu seringkali kompleks dan menantang. Apalagi yang kita jelajahi adalah data raya. Apakah penjelajahan data tersebut dapat kita buat menjadi lebih mudah dan menarik? Artikel blog ini akan mendemonstrasikan bagaimana mengembangkan aplikasi Shiny untuk menjelajah data dari pos sebelumnya.\nKita berkenalan dengan Shiny terlebih dahulu. Shiny adalah sebuah cara yang memungkinkan kita untuk membuat aplikasi berbasis web dengan bahasa pemrograman R (atau Python). Shiny ini cocok bagi kamu yang baru awal-awal memelajari R maupun yang sudah lama dan lihai menggunakan bahasa pemrograman itu."
  },
  {
    "objectID": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-mengapa-shiny",
    "href": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-mengapa-shiny",
    "title": "Membuat Statistik Menjadi Dinamis dan Interaktif",
    "section": "Mengapa Perlu Aplikasi Shiny?",
    "text": "Mengapa Perlu Aplikasi Shiny?\nBayangkan kamu adalah seorang analis data. Kamu sedang menganalisis data Gapminder dengan R. Tujuannya adalah untuk melihat hubungan antara PDB (Pendapatan Domestik Bruto) per kapita dan angka harapan hidup berbagai negara. Pertama, kamu panggil dulu paket yang diperlukan. Paket tersebut adalah {tidyverse}.\n\nlibrary(tidyverse)\n\nSetelah itu, kamu impor data yang tersedia secara daring dengan menggunakan fungsi load() dan url(). Hasilnya, kamu mendapatkan data dengan nama gapminder.\n\nload(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\"))\n\nData tersebut memiliki enam variabel, yaitu negara (country), benua (continent), tahun (year), angka harapan hidup (lifeExp), dan PDB per kapita (gdpPercap, dalam dolar internasional). Tak ingin berlama-lama, kamu langsung memvisualisasikan hubungan antara PDB per kapita dan angka harapan hidup dengan diagram pencar. Hasilnya ditunjukkan pada Gambar 1.\n\ngapminder |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp)) + \n  geom_point()\n\n\n\n\n\n\nGambar 1: Hubungan antara PDB per kapita dan angka harapan hidup berbagai negara\n\n\n\n\nSayangnya, Gambar 1 menggambarkan semua titik datanya. Padahal, kamu ingin menggambarkan titik-titik pada tahun tertentu saja. Untuk itu, kamu perlu mengetahui tahun berapa saja yang tersedia dalam data.\n\nunique(gapminder$year)\n\n [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\n\n\nTahunnya ternyata mulai dari 1952 sampai 2007 dengan interval lima tahun. Selanjutnya, kamu ingin menggambar seperti pada Gambar 1 tetapi hanya untuk tahun 2007. Keinginanmu ini terwujud dengan menjalankan baris kode di bawah. Hasilnya tersaji pada Gambar 2.\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp)) + \n  geom_point()\n\n\n\n\n\n\nGambar 2: Hubungan antara PDB per kapita dan angka harapan hidup berbagai negara pada tahun 2007\n\n\n\n\nDalam baris kode di atas, terdapat perintah filter(year == 2007). Kode tersebut berguna untuk memfilter datanya agar nilai variabel year-nya sama dengan 2007.\nSekarang kamu ingin memvisualisasikan lagi data tersebut tetapi untuk tahun 2002. Caranya mudah. Kamu tinggal mengganti 2007 dengan 2002 dalam fungsi filter() di atas. Alternatifnya, kamu dapat membuat sebuah variabel baru, misalnya tahun_int, dan membuat nilainya menjadi 2002. Setelah itu, kamu ganti 2007 dalam fungsi filter() di atas dengan variabel tersebut. Alhasil, kamu mendapatkan diagram pencar seperti yang ditunjukkan Gambar 3.\n\n# Variabel `tahun_int` dan nilainya sama dengan 2002\ntahun_int &lt;- 2002\n\n# Memvisualisasikan data untuk tahun 2002\ngapminder |&gt; \n  filter(year == tahun_int) |&gt; \n  ggplot(aes(x = gdpPercap, y = lifeExp)) + \n  geom_point()\n\n\n\n\n\n\nGambar 3: Hubungan antara PDB per kapita dan angka harapan hidup berbagai negara pada tahun 2002\n\n\n\n\nBagaimana jika kamu ingin membuat visualisasi data untuk tahun 1997? Kamu ganti nilai variabel tahun_int dengan 1997 dan jalankan baris kodenya. Bagaimana untuk tahun-tahun lainnya? Caranya sama:\n\nkamu ganti nilai varibel tahun_int dengan tahun yang kamu mau, dan kemudian\njalankan lagi baris kodenya.\n\nDua langkah tersebut perlu dilakukan agar kamu dapat memvisualisasikan data untuk tahun-tahun tertentu. Adakah cara yang lebih efisien? Adakah cara agar langkah kedua di atas otomatis dijalankan ketika kamu mengganti nilai variabel tahun_int? Tentu saja ada! Caranya adalah dengan menggunakan Shiny.\nShiny menggunakan pemrograman yang reaktif. Artinya, Shiny akan secara otomatis menjalankan baris perintah untuk menghasilkan luaran ketika nilai inputnya diganti. Dalam kasusmu ini, inputnya adalah nilai variabel tahun_int dan luarannya adalah diagram pencar seperti pada Gambar 2 atau Gambar 3. Dengan demikian, Shiny akan langsung membuat diagram pencar seperti itu ketika nilai variabel tahun_int kamu ganti."
  },
  {
    "objectID": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-membuat-app-shiny",
    "href": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-membuat-app-shiny",
    "title": "Membuat Statistik Menjadi Dinamis dan Interaktif",
    "section": "Membuat Aplikasi Shiny",
    "text": "Membuat Aplikasi Shiny\nKamu telah mengenal Shiny. Sekarang kita akan membuat aplikasi Shiny berdasarkan proses analisis data yang dipaparkan pada Bagian 1. Karena kita akan menggunakan paket {shiny}, paket tersebut perlu terpasang di komputermu. Jika belum, kamu perlu memasangnya dengan perintah berikut.\ninstall.packages(\"shiny\")\nAku menyarankanmu untuk membuat aplikasi Shiny dengan RStudio agar lebih mudah. Di RStudio, kamu dapat membuat aplikasi Shiny dengan mengklik File | New File | Shiny Web App… Pada jendela New Shiny Web Application, tuliskan nama aplikasinya dan klik Create. Setelah itu, kamu akan mendapatkan fail app.R yang isinya seperti ini.\n\n\napp.R\n\n#\n# This is a Shiny web application. You can run the application by clicking\n# the 'Run App' button above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"Old Faithful Geyser Data\"),\n\n    # Sidebar with a slider input for number of bins \n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"bins\",\n                        \"Number of bins:\",\n                        min = 1,\n                        max = 50,\n                        value = 30)\n        ),\n\n        # Show a plot of the generated distribution\n        mainPanel(\n           plotOutput(\"distPlot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n\n    output$distPlot &lt;- renderPlot({\n        # generate bins based on input$bins from ui.R\n        x    &lt;- faithful[, 2]\n        bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n        # draw the histogram with the specified number of bins\n        hist(x, breaks = bins, col = 'darkgray', border = 'white',\n             xlab = 'Waiting time to next eruption (in mins)',\n             main = 'Histogram of waiting times')\n    })\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nBaris kode di atas adalah baris kode yang sudah lengkap untuk sebuah aplikasi. Tetapi, aplikasi tersebut tidak sesuai dengan tujuanmu, yaitu memvisualisasikan hubungan antara PDB per kapita dan angka harapan hidup. Untuk itu, hapus semua baris kode di atas dan ganti dengan baris kode seperti pada Daftar 1 berikut.\n\n\nDaftar 1: Baris kode di dalam app.R\n\n\n\napp.R\n\nlibrary(shiny)\nlibrary(tidyverse)\nload(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\"))\n\nui &lt;- fluidPage(\n  sliderInput(\n    inputId = \"tahun\",\n    label = \"Tahun\",\n    min = 1952,\n    max = 2007,\n    value = 2007,\n    step = 5\n  ),\n  plotOutput(\"diagram_pencar\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$diagram_pencar &lt;- renderPlot({\n    tahun_int &lt;- input$tahun\n    \n    gapminder |&gt; \n      filter(year == tahun_int) |&gt; \n      ggplot(aes(x = gdpPercap, y = lifeExp)) + \n      geom_point()\n    \n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\nAplikasi app.R tersebut memuat baris kode yang melakukan empat hal sebagai berikut.\n\nBaris kode tersebut memanggil paket {shiny} dan {tidyverse} melalui perintah library(shiny) dan library(tidyverse). Selain itu, baris kode tersebut juga mengimpor data gapminder dengan perintah load(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\")).\nBaris kode tersebut membuat antarmuka (ui): laman yang menjadi tempat berinteraksinya pengguna. Ada tiga fungsi yang digunakan untuk membuat antarmuka tersebut, yaitu fluidPage(), sliderInput(), dan plotOutput(). Lebih lengkapnya akan dijelaskan pada Bagian 2.1.\nBaris kode tersebut menentukan perilaku dari aplikasi tersebut dengan fungsi server. Pembahasan lebih lanjut dapat dilihat pada Bagian 2.2.\nBaris kode yang terakhir, yaitu shinyApp(ui = ui, server = server), berfungsi untuk membuat aplikasi Shiny berdasarkan antarmuka ui dan fungsi server dan kemudian menjalankannya.\n\nApabila kamu sudah penasaran dengan aplikasi Shiny tersebut, kamu dapat menjalankannya. Untuk melakukannya di RStudio, klik tombol Run App yang terletak di bagian kanan-atas dokumen. Perhatikan Gambar 4!\n\n\n\n\n\nGambar 4: Tombol Run App yang dapat ditemukan di bagian kanan-atas dokumen\n\n\nSetelah kamu mengklik tombol tersebut, beberapa saat kamu dapat melihat aplikasi tersebut. Tampilannya ditunjukkan pada Gambar 5.\n\n\n\n\n\nGambar 5: Tampilan aplikasi Shiny\n\n\nKamu dapat berinteraksi dengan aplikasi tersebut. Silakan geser-geser slidernya (bagian kiri-atas aplikasi dengan label “Tahun”) untuk mengubah tahunnya. Ketika tahun tersebut kamu ganti, kamu dapat melihat tampilan diagram pencarnya juga menyesuaikan. Untuk menutup aplikasi tersebut, klik tombol Close yang terletak di sebelah kanan-atas.\nAntarmuka Aplikasi Shiny\nSalah satu bagian baris kode aplikasi Shiny adalah kode antarmukanya. Pada baris kode Daftar 1, pendefinisian antarmukanya ada di ui. Terdapat tiga fungsi yang digunakan, yaitu fluidPage(), sliderInput(), dan plotOutput().\n\nfluidPage() merupakan fungsi tata letak. Fungsi ini mengatur tata letak dari tampilan aplikasi Shiny kita.\nsliderInput() merupakan salah satu kontrol input. Fungsi ini memungkinkan pengguna untuk berinteraksi dengan aplikasi kita. Dengan menggeser-geser slidernya, pengguna menyediakan input bagi aplikasi kita. Terdapat enam argumen yang kita isikan dalam fungsi tersebut. Argumen inputId = \"tahun\" memberikan identitas terhadap slider tersebut. Identitas ini selanjutnya digunakan lagi dalam fungsi server nantinya. Argumen label=\"Tahun\" berfungsi untuk memberikan label terhadap slider tersebut. Label ini ditampilkan dalam antarmuka aplikasi kita. Argumen min = 1952 , max = 2007, dan step = 5 memberikan nilai-nilai yang mungkin untuk inputnya, yaitu bilangan mulai dari 1952 sampai 2007 dengan interval 5. Terakhir, value = 2007 memberikan nilai awal untuk slider tersebut.\nplotOutput() merupakan salah satu kontrol luaran aplikasi Shiny. Fungsi ini memberitahu Shiny tempat meletakkan luaran plot yang memiliki identitas diagram_pencar.\nDapur Aplikasi Shiny\nBagian 2.1 telah menunjukkan adanya input dan luaran dalam aplikasi Shiny kita. Dari input menjadi luaran, terdapat proses komputasi yang dilakukan di dapur Shiny. Proses ini kita tentukan di dalam fungsi server.\nDi dalam fungsi server, kita memberikan resep kepada Shiny untuk melakukan komputasi. Ruas kiri dari operator &lt;-, yaitu output$diagram_pencar, mengindikasikan bahwa kita memberikan resep untuk luaran dengan identitas diagram_pencar.\nRuas kanan operator &lt;- merupakan fungsi render. Fungsi render ini bermacam-macam jenisnya, tergantung dari luarannya. Karena di antarmuka kita akan membuat plot dengan plotOutput, kita perlu menggunakan fungsi renderPlot() di sini.\nLogika di dalam fungsi renderPlot() sama dengan logika yang kita gunakan pada Bagian 1, tetapi dengan sedikit penambahan. Penambahannya adalah pada tahun_int &lt;- input$tahun. Kode ini berfungsi untuk memberikan nilai sebesar input$tahun kepada variabel tahun_int. Nilai input$tahun tersebut tergantung dari nilai yang diberikan oleh pengguna terhadap slider dengan identitas tahun pada antarmuka.\nAlur kerja aplikasi Shiny kita ringkasnya seperti ini. Pertama, pengguna melihat antarmuka aplikasi kita. Di situ dia dapat menggeser slider dengan identitas tahun untuk mengganti-ganti nilanya. Nilai ini kemudian dikirim ke dapur Shiny dalam rupa input$tahun untuk diolah di dalam fungsi render, yaitu renderPlot(). Olahan tersebut menghasilkan luaran yang disebut dengan output$diagram_pencar. Luaran ini kemudian dikirimkan lagi ke antarmuka agar dapat dilihat oleh pengguna. Di mana posisinya? Posisinya terletak di mana plotOutput(\"diagram_pencar\") berada."
  },
  {
    "objectID": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-sentuhan-akhir",
    "href": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-sentuhan-akhir",
    "title": "Membuat Statistik Menjadi Dinamis dan Interaktif",
    "section": "Sentuhan Akhir",
    "text": "Sentuhan Akhir\nAplikasi Shiny kita masih sederhana dan seperlunya. Kita dapat memperindah aplikasi tersebut. Beberapa hal yang dapat kita lakukan antara lain\n\nmenambahkan judul ke dalam antarmukanya,\nmengatur slidernya agar menampilkan bilangan yang tidak memuat pemisah ribuan, dan\nmemperbaiki diagram pencar yang disajikan agar tampilannya sama dengan diagram pencar pada pos sebelumnya, serta mengatur agar batasan jendelanya konsisten dari tahun ke tahun.\n\nKetiga hal tersebut dapat kita penuhi dengan baris kode seperti pada Daftar 2 berikut.\n\n\nDaftar 2: Baris kode di dalam app.R\n\n\n\napp.R\n\nlibrary(shiny)\nlibrary(tidyverse)\nload(url(\"https://github.com/jennybc/gapminder/raw/main/data/gapminder.rdata\"))\n\nui &lt;- fluidPage(\n  titlePanel(\"PDB per Kapita vs. Angka Harapan Hidup\"),\n  sliderInput(\n    inputId = \"tahun\",\n    label = \"Tahun\",\n    min = 1952,\n    max = 2007,\n    value = 2007,\n    step = 5,\n    sep = \"\"\n  ),\n  plotOutput(\"diagram_pencar\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$diagram_pencar &lt;- renderPlot({\n    tahun_int &lt;- input$tahun\n    \n    gapminder |&gt; \n      filter(year == tahun_int) |&gt; \n      ggplot(\n        aes(x = gdpPercap, y = lifeExp)\n      ) + \n      geom_point(\n        aes(color = continent, size = pop),\n        alpha = .6\n      ) + \n      scale_size(\n        range = c(5, 30),\n        guide = \"none\"\n      ) + \n      scale_color_viridis_d(name = \"Benua\") + \n      theme_minimal(base_size = 18) + \n      theme(\n        legend.position = \"bottom\",\n        plot.title = element_text(face = \"bold\")\n      ) + \n      xlim(c(200, 60000)) + \n      ylim(c(20, 90)) + \n      labs(\n        x = \"PDB per kapita\",\n        y = \"Angka harapan hidup\",\n        caption = \"Data: Jenny Bryan dkk. / Github\"\n      )\n    \n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\nBagaimana tampilan aplikasi Shiny kita sekarang? Tampilannya ditunjukkan pada Gambar 6.\n\n\n\n\n\nGambar 6: Tampilan aplikasi Shiny setelah dilakukan sentuhan akhir"
  },
  {
    "objectID": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-catatan-akhir",
    "href": "pos/2024-08-statistik-dinamis-dan-interaktif/index.html#sec-catatan-akhir",
    "title": "Membuat Statistik Menjadi Dinamis dan Interaktif",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah mengenal Shiny. Kita secara bersama-sama juga telah membuat aplikasi Shiny sederhana pada Bagian 2 dan memberikan sentuhan akhir pada Bagian 3. Aplikasi tersebut dapat menampilkan visualisasi data secara interaktif. Dengan cara demikian, harapannya statistik tidak hanya menjadi konsumsi statistikawan tetapi juga orang awam.\nApa selanjutnya? Jika kamu tertarik untuk mengembangkan aplikasi Shiny, kamu dapat belajar dari contoh-contohnya. Contoh tersebut dapat kamu lihat di laman galeri Shiny untuk R. Selain itu, kamu juga dapat menjelajah beberapa aplikasi Shiny yang telah aku kembangkan. Have a shiny day!"
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html",
    "href": "pos/2025-01-pendapatan-musik/index.html",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "",
    "text": "Aku menulis paragraf ini diringi dengan salah satu lagu hits Sheila On 7, Dan… Tak hanya karena lagu itu enak didengar tetapi juga lagu itu menggiringku untuk bernostalgia ke masa kejayaan kaset. Aku masih ingat betul bagaimana dulu aku merengek minta diantar ke kota untuk berbelanja kaset orisinal album Sheila On 7. Sesampai di rumah aku mainkan kaset itu berulang-ulang, khususnya pada lagu pertama side B itu. Beberapa hari kemudian, kasetnya sudah ngelokor tak karuan.\nSekarang aku jadi bertanya-tanya, apakah kamu paham apa yang aku ceritakan di atas? Dugaanku, hanya sedikit yang memahaminya—khususnya tentang kaset dan fenomena ngelokor-nya. Paling tidak, dugaanku itu sejalan dengan temuanku ketika tersesat di laman pangkalan data pendapatan industri musik di Amerika Serika (AS). Di laman itu, aku mendapati sebuah diagram interaktif nan apik. Silakan amati diagram itu pada Gambar 1.\nMeskipun kurang begitu jelas, dari Gambar 1 kita dapat melihat bahwa setelah tahun 2000 pendapatan industri musik dari format kaset dan sejenisnya terus menurun. Bahkan, tak ada lagi pendapatan yang sumbernya dari penjualan kaset dan sejenisnya setelah tahun 2008. Tapi, stop! Kita hentikan sampai di sini interpretasi datanya. Kita apresiasi bagaimana data tersebut dipresentasikan.\nDiagram tersebut memberikan contoh penggunaan diagram batang yang efektif, meskipun sumbu horizontalnya menyatakan waktu.1 Pemilihan warnanya secara efektif menunjukkan tren dalam data. Misalnya, kita dapat melihat pada Gambar 1 bahwa dari kiri ke kanan warna biru semakin mengecil ketika warna oranye semakin membesar. Hal ini menunjukkan pendapatan industri musik di AS dari format kaset dan sejenisnya semakin menurun seiring adanya format CD.\nTak hanya itu. Jika kamu mengunjungi situs web RIAA, kamu dapat berinteraksi dengan diagram tersebut. Kamu dapat memilih pendapatan seperti apa yang ditampilkan—apakah yang disesuaikan dengan inflasi ataukah tidak. Kamu dapat mengatur batasan tahun untuk data yang disajikan. Kamu juga dapat memilih format-format apa saja yang perlu dipresentasikan dalam diagram. Terakhir, kamu dapat menyorot dan mengklik setiap batangnya untuk melihat informasi yang disajikan batang tersebut.\nBisakah kita membuat visualisasi data seperti itu? Tentu bisa! Kita akan membuat visualisasi data itu dengan menggunakan pemrograman R, khususnya dengan paket {ggplot2} dan {plotly}, dan Observable JS. Untuk melakukan visualisasi data di R, terlebih dahulu kita panggil paket-paket yang kita perlukan.\nlibrary(tidyverse) # Paket {ggplot2} masuk dalam {tidyverse}\nlibrary(plotly)"
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-mempersiapkan-dan-menjelajah-data",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-mempersiapkan-dan-menjelajah-data",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Mempersiapkan dan Menjelajah Data",
    "text": "Mempersiapkan dan Menjelajah Data\nKita siapkan datanya terlebih dahulu. Data tersebut dapat kita peroleh dari situs web RIAA. Data dari situs itu yang sudah aku rapikan dapat diakses di GitHub. Mari kita impor data tersebut dengan read_csv().\n\nurl_fail &lt;- \"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/refs/heads/main/pos/2025-01-pendapatan-musik/aset/pendapatan_as_riaa.csv\"\n\npendapatan_as_riaa &lt;- read_csv(\n  file = url_fail,\n  show_col_types = FALSE\n)\n\nprint(pendapatan_as_riaa)\n\n# A tibble: 508 × 5\n   format grup  tahun      pendapatan pendapatan_infl\n   &lt;chr&gt;  &lt;chr&gt; &lt;date&gt;          &lt;dbl&gt;           &lt;dbl&gt;\n 1 CD     Disc  1983-01-01       17.2            52.6\n 2 CD     Disc  1984-01-01      103.            303. \n 3 CD     Disc  1985-01-01      390.           1103  \n 4 CD     Disc  1986-01-01      930.           2586. \n 5 CD     Disc  1987-01-01     1594.           4274. \n 6 CD     Disc  1988-01-01     2090.           5383. \n 7 CD     Disc  1989-01-01     2588.           6359. \n 8 CD     Disc  1990-01-01     3452.           8047. \n 9 CD     Disc  1991-01-01     4338.           9704. \n10 CD     Disc  1992-01-01     5326.          11568  \n# ℹ 498 more rows\n\n\nKita mendapatkan sebuah tibble pendapatan_as_riaa yang memiliki lima variabel dan 508 baris. Variabel-variabel tersebut adalah format, grup, dan tahun, serta dua ukuran pendapatan: pendapatan yang tidak disesuaikan dengan inflasi (pendapatan) dan yang disesuaikan dengan inflasi (pendapatan_infl). Pendapatan tersebut semuanya dalam juta dolar AS.\nUntuk mengakrabkan diri dengan data tersebut, mari kita lihat lebih jauh dalam data itu. Apa saja format dan grup dalam data tersebut? Mari kita selidiki!\n\npendapatan_as_riaa$format |&gt; \n  unique()\n\n [1] \"CD\"                                 \"CD Single\"                         \n [3] \"8 - Track\"                          \"Cassette\"                          \n [5] \"Cassette Single\"                    \"DVD Audio\"                         \n [7] \"Download Album\"                     \"Download Music Video\"              \n [9] \"Download Single\"                    \"Kiosk\"                             \n[11] \"LP/EP\"                              \"Limited Tier Paid Subscription\"    \n[13] \"Music Video (Physical)\"             \"On-Demand Streaming (Ad-Supported)\"\n[15] \"Other Ad-Supported Streaming\"       \"Other Digital\"                     \n[17] \"Other Physical\"                     \"Other Tapes\"                       \n[19] \"Paid Subscription\"                  \"Ringtones & Ringbacks\"             \n[21] \"SACD\"                               \"SoundExchange Distributions\"       \n[23] \"Synchronization\"                    \"Vinyl Single\"                      \n\npendapatan_as_riaa$grup |&gt; \n  unique()\n\n[1] \"Disc\"      \"Tape\"      \"Other\"     \"Download\"  \"Vinyl\"     \"Streaming\"\n[7] NA         \n\n\nKita selidiki juga pengkategorian format ke dalam grup. Kita dapat melakukannya dengan kode berikut.\n\npendapatan_as_riaa |&gt; \n  select(grup, format) |&gt; \n  group_by(grup, format) |&gt; \n  unique() |&gt; \n  ungroup() |&gt; \n  arrange(grup, format) |&gt; \n  print(n = 24)\n\n# A tibble: 24 × 2\n   grup      format                            \n   &lt;chr&gt;     &lt;chr&gt;                             \n 1 Disc      CD                                \n 2 Disc      CD Single                         \n 3 Disc      SACD                              \n 4 Download  Download Album                    \n 5 Download  Download Music Video              \n 6 Download  Download Single                   \n 7 Download  Other Digital                     \n 8 Download  Ringtones & Ringbacks             \n 9 Other     DVD Audio                         \n10 Other     Kiosk                             \n11 Other     Music Video (Physical)            \n12 Other     Synchronization                   \n13 Streaming Limited Tier Paid Subscription    \n14 Streaming On-Demand Streaming (Ad-Supported)\n15 Streaming Other Ad-Supported Streaming      \n16 Streaming Paid Subscription                 \n17 Streaming SoundExchange Distributions       \n18 Tape      8 - Track                         \n19 Tape      Cassette                          \n20 Tape      Cassette Single                   \n21 Tape      Other Tapes                       \n22 Vinyl     LP/EP                             \n23 Vinyl     Vinyl Single                      \n24 &lt;NA&gt;      Other Physical                    \n\n\nBagaimana dengan rentangan tahun-nya? Dengan menjalankan kode berikut, kita tahu bahwa tahun-nya merentang dari 1973 sampai 2023.\n\npendapatan_as_riaa$tahun |&gt; \n  unique() |&gt; \n  sort()\n\n [1] \"1973-01-01\" \"1974-01-01\" \"1975-01-01\" \"1976-01-01\" \"1977-01-01\"\n [6] \"1978-01-01\" \"1979-01-01\" \"1980-01-01\" \"1981-01-01\" \"1982-01-01\"\n[11] \"1983-01-01\" \"1984-01-01\" \"1985-01-01\" \"1986-01-01\" \"1987-01-01\"\n[16] \"1988-01-01\" \"1989-01-01\" \"1990-01-01\" \"1991-01-01\" \"1992-01-01\"\n[21] \"1993-01-01\" \"1994-01-01\" \"1995-01-01\" \"1996-01-01\" \"1997-01-01\"\n[26] \"1998-01-01\" \"1999-01-01\" \"2000-01-01\" \"2001-01-01\" \"2002-01-01\"\n[31] \"2003-01-01\" \"2004-01-01\" \"2005-01-01\" \"2006-01-01\" \"2007-01-01\"\n[36] \"2008-01-01\" \"2009-01-01\" \"2010-01-01\" \"2011-01-01\" \"2012-01-01\"\n[41] \"2013-01-01\" \"2014-01-01\" \"2015-01-01\" \"2016-01-01\" \"2017-01-01\"\n[46] \"2018-01-01\" \"2019-01-01\" \"2020-01-01\" \"2021-01-01\" \"2022-01-01\"\n[51] \"2023-01-01\"\n\n\nUntuk mengkonfirmasi apa yang kukatakan di awal, yaitu pendapatan dari format kaset dan sejenisnya terus menurun setelah tahun 2000, mari kita lihat dari data pendapatan_as_riaa.\n\npendapatan_as_riaa |&gt; \n  filter(\n    grup == \"Tape\",\n    tahun &gt; as.Date(\"2000-01-01\")\n  ) |&gt; \n  group_by(grup, tahun) |&gt; \n  summarise(\n    total_pendapatan = sum(pendapatan, na.rm = TRUE),\n    total_pendapatan_infl = sum(pendapatan_infl, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# A tibble: 8 × 4\n  grup  tahun      total_pendapatan total_pendapatan_infl\n  &lt;chr&gt; &lt;date&gt;                &lt;dbl&gt;                 &lt;dbl&gt;\n1 Tape  2001-01-01            358.                  616. \n2 Tape  2002-01-01            208.                  353. \n3 Tape  2003-01-01            108.                  179  \n4 Tape  2004-01-01             23.7                  38.2\n5 Tape  2005-01-01             13.1                  20.4\n6 Tape  2006-01-01              3.7                   5.6\n7 Tape  2007-01-01              3                     4.4\n8 Tape  2008-01-01              0.9                   1.3\n\n\nTerkonfirmasi! Pendapatan dari kaset dan sejenisnya terus merosot setelah tahun 2000. Bahkan, pendapatan dari format tersebut menghilang mulai tahun 2009."
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-visualisasi-data-dengan-ggplot2",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-visualisasi-data-dengan-ggplot2",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Memvisualisasikan Data dengan {ggplot2}",
    "text": "Memvisualisasikan Data dengan {ggplot2}\nKita telah akrab dengan data pendapatan_as_riaa. Sekarang waktunya untuk memvisualisasikannya. Untuk mendapatan diagram seperti pada Gambar 1, kita gunakan geom_col() dengan position = \"stack\" dan stat = \"identity\".\n\npendapatan_as_riaa |&gt; \n  ggplot(\n    aes(x = tahun, y = pendapatan_infl, fill = format)\n  ) + \n  geom_col()\n\n\n\n\n\n\nGambar 2: Versi awal visualisasi data pendapatan industri musik di AS dengan {ggplot2}\n\n\n\n\nUntuk awalan, tidak terlalu buruk diagramnya. Tapi kita perlu memodifikasi beberapa hal dari diagram batang pada Gambar 2.\n\nKita definisikan warna-warna diagram batangnya.\nKita atur legendanya agar terletak di bawah dan terdiri dari empat kolom.\nKita atur urutan level pada variabel format agar keterbacaannya membaik.\nKita tambahkan judul, anak judul, dan takarir ke dalam diagram, serta kita perbaiki judul sumbu vertikal dan horizontalnya.\n\nKita jalankan rencana pertama dan ketiga terlebih dahulu dengan membuat objek urutan_format dan pemetaan_format_warna.\n\n# Urutan level pada variabel `format`\nurutan_format &lt;- c(\n  \"LP/EP\", \"Vinyl Single\", \"8 - Track\",\n  \"Cassette\", \"Cassette Single\", \"Other Tapes\",\n  \"Kiosk\", \"CD\", \"CD Single\",\n  \"SACD\", \"DVD Audio\", \"Music Video (Physical)\",\n  \"Download Album\", \"Download Single\", \"Ringtones & Ringbacks\",\n  \"Download Music Video\", \"Other Digital\", \"Synchronization\",\n  \"Paid Subscription\", \"On-Demand Streaming (Ad-Supported)\",\n  \"Other Ad-Supported Streaming\",\n  \"SoundExchange Distributions\",\n  \"Limited Tier Paid Subscription\"\n)\n\n# Pemetaan setiap level pada `format` dengan warna\npemetaan_format_warna &lt;- c(\n  \"LP/EP\" = \"#2A5784\",\n  \"Vinyl Single\" = \"#43719F\",\n  \"8 - Track\" = \"#5B8DB8\",\n  \"Cassette\" = \"#7AAAD0\",\n  \"Cassette Single\" = \"#9BC7E4\",\n  \"Other Tapes\" = \"#BADDF1\",\n  \"Kiosk\" = \"#E1575A\",\n  \"CD\" = \"#EE7423\",\n  \"CD Single\" = \"#F59D3D\",\n  \"SACD\" = \"#FFC686\",\n  \"DVD Audio\" = \"#9D7760\",\n  \"Music Video (Physical)\" = \"#F1CF63\",\n  \"Download Album\" = \"#7C4D79\",\n  \"Download Single\" = \"#9B6A97\",\n  \"Ringtones & Ringbacks\" = \"#BE89AC\",\n  \"Download Music Video\" = \"#D5A5C4\",\n  \"Other Digital\" = \"#EFC9E6\",\n  \"Synchronization\" = \"#BBB1AC\",\n  \"Paid Subscription\" = \"#24693D\",\n  \"On-Demand Streaming (Ad-Supported)\" = \"#398949\",\n  \"Other Ad-Supported Streaming\" = \"#61AA57\",\n  \"SoundExchange Distributions\" = \"#7DC470\",\n  \"Limited Tier Paid Subscription\" = \"#B4E0A7\"\n)\n\nKita jalankan rencana selanjutnya. Untuk melakukannya, kita jalankan kode berikut ini. Hasilnya ditunjukkan pada Gambar 3.\n\nplot_musik &lt;- pendapatan_as_riaa |&gt; \n  mutate(\n    format = factor(\n      format,\n      levels = urutan_format\n    )\n  ) |&gt; \n  ggplot(\n    aes(x = tahun, y = pendapatan_infl, fill = format)\n  ) + \n  geom_bar(\n    position = \"stack\",\n    stat = \"identity\"\n  ) + \n  scale_fill_manual(\n    name = \"Format\",\n    values = pemetaan_format_warna\n  ) + \n  guides(\n    fill = guide_legend(ncol = 4)\n  ) + \n  theme_minimal() + \n  theme(\n    axis.title.x = element_blank(),\n    legend.position = \"bottom\",\n    legend.title = element_blank(),\n    legend.key.spacing.y = unit(.025, \"cm\"),\n    plot.title = element_text(\n      face = \"bold\"\n    )\n  ) + \n  labs(\n    title = \"Pendapatan Industri Musik di AS Berdasarkan Format\",\n    subtitle = \"Disesuaikan dengan Inflasi, Nilai Dolar Tahun 2023\",\n    y = \"Pendapatan\\n(juta dolar AS)\",\n    caption = \"Data: Recording Industry Association of America (RIAA)\"\n  )\n\nprint(plot_musik)\n\n\n\n\n\n\nGambar 3: Visualisasi data dengan {ggplot2} setelah dilakukan beberapa modifikasi\n\n\n\n\nDiagram batang pada Gambar 3 sudah mirip dengan yang ditunjukkan pada Gambar 1. Diagram tersebut telah efektif menyampaikan informasi tentang pendapatan industri musik berdasarkan formatnya."
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-menambahkan-interaktivitas-dengan-plotly",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-menambahkan-interaktivitas-dengan-plotly",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Menambahkan Interaktivitas dengan {plotly}",
    "text": "Menambahkan Interaktivitas dengan {plotly}\nDiagram batang pada Gambar 3 memang sudah efektif dalam menyampaikan informasi pendapatan industri musik di AS berdasarkan formatnya. Meskipun demikian, kita kesulitan dalam mencari informasi yang sifatnya detail. Misalnya, dari gambar tersebut apakah kamu dapat mengetahui besarnya pendapatan dari format download album pada tahun 2010? Sulit, bukan?\nUntuk mengatasi masalah tersebut, kita dapat menambahkan interaktivitas ke dalam grafik tersebut dengan {plotly}. Untungnya paket ini dapat kita terapkan terhadap objek ggplot sebelumnya dengan fungsi ggplotly().\n\nggplotly(\n  p = plot_musik\n)\n\n\n\n\n\n\nGambar 4: Diagram batang menjadi interaktif dengan {plotly}\n\n\n\nKita dapat menyorot batang-batang pada Gambar 4 untuk melihat informasi detailnya. Misalnya, kita dapat mengarahkan kursor ke batang berwarna ungu tua pada tahun 2010. Di situ kita dapat melihat bahwa besarnya pendapatan industri musik dari format download album pada tahun itu adalah 1219,1 juta dolar AS.\nSelain itu, kita dapat mengklik satu atau lebih item legenda untuk menghilangkan data yang bersangkutan dari diagram. Kita juga dapat mengklik dua kali item legenda untuk mengisolasinya. Fitur-fitur interaktivitas ini memudahkan kita dalam membaca dan menginterpretasi data."
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-memvisualisasikan-data-dengan-observable-js",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-memvisualisasikan-data-dengan-observable-js",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Memvisualisasikan Data dengan Observable JS",
    "text": "Memvisualisasikan Data dengan Observable JS\nPada Bagian 2 dan Bagian 3 kita telah memvisualisasikan data pendapatan industri musik dengan menggunakan pemrograman R. Sekarang, kita akan memvisualisasikannya dengan Observable JS, khususnya Plot.\nPertama, kita impor data dengan menggunakan d3.csv(). Kita masukkan alamat url data kita ke dalam fungsi tersebut. Kita gunakan fungsi d3.autoType untuk mengkonversi variabel-variabel dalam data kita ke dalam Date dan numerik secara otomatis. Kita simpan data tersebut dengan nama pendapatanMusik.\n\ncsvUrl = \"https://raw.githubusercontent.com/jelajahstatid/jelajahstatid.github.io/refs/heads/main/pos/2025-01-pendapatan-musik/aset/pendapatan_as_riaa.csv\"\n\n\n\n\n\n\n\npendapatanMusik = d3.csv(csvUrl, d3.autoType)\n\n\n\n\n\n\nSetelah itu, kita visualisasikan data tersebut dengan menggunakan tiga objek geometris: barY, ruleY, dan axisX. Objek geometris barY kita gunakan untuk membuat diagram batang vertikal dengan y: \"pendapatan_infl\", x: \"tahun\", fill: \"format\". Kita atur agar persegi panjang tersebut interaktif dengan menambahkan tip: true. Objek geometris ruleY kita gunakan untuk membuat garis horizontal yang memotong sumbu-\\(y\\) di \\(y = 0\\). Garis itu adalah sumbu-\\(x\\). Terakhir, kita atur agar tik-tik pada sumbu-\\(x\\) dibuat dengan selang lima tahunan. Pengaturan ini kita lakukan pada objek geometris axisX.\nKita dapat mengatur legenda warnanya pada color. Kita atur legend: true untuk menampilkan legendanya dan columns: 4 untuk mengatur banyaknya kolom dalam penyajian item-item legenda tersebut. Kita juga dapat melakukan pengaturan lebih lanjut terhadap x, y, caption, dan subtitle. Hasilnya disajikan pada Gambar 5.\n\n\n\nPlot.plot({\n  x: {label: \"Tahun\"},\n  y: {\n    grid: true,\n    label: \"Pendapatan (juta dolar AS)\"\n  },\n  color: {\n    legend: true,\n    columns: 4\n},\n  marks: [\n    Plot.barY(pendapatanMusik,{\n      y: \"pendapatan_infl\",\n      x: \"tahun\",\n      fill: \"format\",\n      order: null,\n      tip: true\n    }),\n    Plot.ruleY([0]),\n    Plot.axisX({ticks: \"5 years\"})\n  ],\n  caption: \"Data: Recording Industry Association of America (RIAA)\",\n  subtitle: \"Disesuaikan dengan Inflasi, Nilai Dolar Tahun 2023\"\n})\n\n\n\n\n\n\n\n\nGambar 5: Diagram batang yang dibuat dengan Observable Plot\n\n\nAlright! Kita mendapatkan Gambar 5 yang secara fungsi serupa dengan Gambar 4. Selanjutnya kita akan memodifikasi diagram tersebut dalam hal tampilan dan interaktivitasnya. Untuk tampilan, kita akan mengatur warnanya agar sama dengan diagram pada Gambar 3 dan Gambar 4. Kita juga akan menambahkan interaktivitas pada diagram tersebut dengan menambahkan beberapa input."
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-interaktivitas-input-observable",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-interaktivitas-input-observable",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Menambahkan Interaktivitas dengan Input Observable",
    "text": "Menambahkan Interaktivitas dengan Input Observable\nKita tambahkan interaktivitas terhadap Gambar 5 dengan beberapa input Observable. Ada empat input yang dapat kita tambahkan. Deskripsi keempat input tersebut adalah sebagai berikut.\n\nInput pendapatan. Input ini menyediakan pilihan bagi pengguna untuk memilih jenis pendapatan yang divisualisasikan—apakah yang disesuaikan dengan inflasi atau yang tidak.\nInput format. Input ini memberikan keleluasaan bagi pengguna untuk memilih format-format apa yang akan divisualisasikan.\nInput rentang tahun. Input ini dapat digunakan pengguna untuk memilih rentang tahun terhadap data yang divisualisasikan. Untuk melakukannya, kita sediakan dua input. Kedua input ini digunakan sebagai batas tahun pertama dan kedua.\n\nSetelah penambahan input-input tersebut, diagram batang interaktifnya disajikan pada Gambar 6.\nKodeviewof pendapatanTerpilih = Inputs.radio(\n  new Map([\n    [\"Tidak disesuaikan dengan inflasi\", \"pendapatan\"],\n    [\"Disesuaikan dengan inflasi\", \"pendapatan_infl\"]\n  ]),\n  {label: \"Pendapatan\", value: \"pendapatan_infl\"}\n)\nviewof formatTerpilih = Inputs.select(daftarFormat, {\n  multiple: true, \n  label: \"Format\", \n  value: daftarFormat\n})\nviewof tahun1 = Inputs.range([1973, 2023], {value: 1973, step: 1, label: \"Tahun (batas 1)\"})\nviewof tahun2 = Inputs.range([1973, 2023], {value: 2023, step: 1, label: \"Tahun (batas 2)\"})\nKodePlot.plot({\n  x: {label: \"Tahun\"},\n  y: {\n    grid: true,\n    label: \"Pendapatan (juta dolar AS)\"\n  },\n  color: {\n    legend: true,\n    label: \"Format\",\n    columns: 4,\n    domain: formatTerpilih,\n    range: warnaTerpilih\n  },\n  style: {width: \"100%\"},\n  marks: [\n    Plot.barY(dataTerpilih,\n      {y: pendapatanTerpilih, x: \"tahun\", fill: \"format\", tip: true} \n    ),\n    Plot.ruleY([0]),\n    Plot.axisX({ticks: \"5 years\"})\n  ],\n  caption: \"Data: Recording Industry Association of America (RIAA)\",\n  subtitle: anakJudul\n})\nKodeInputs.table(dataTerpilih, {\n  sort: \"tahun\",\n  columns: [\n    \"format\",\n    \"tahun\",\n    pendapatanTerpilih\n  ],\n  maxWidth: \"100%\"\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot\nData\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGambar 6: Diagram batang dan tabel interaktif yang dibuat dengan menggunakan Observable JS\n\n\nVoila! Kita mendapatkan diagram batang interaktif seperti pada situs webnya RIAA. Bagaimana membuat diagram batang seperti yang ditunjukkan pada Gambar 6? Well, kode lengkapnya dapat kamu lihat dan pelajari di catatan ini.\n\nKodedataTerpilih = pendapatanMusik.filter(function (pendapatan) {\n  return formatTerpilih.includes(pendapatan.format) &&\n    tahunMin &lt;= pendapatan.tahun &&\n    tahunMaks &gt;= pendapatan.tahun;\n})\n\n\n\n\n\n\n\nKodetahun1Date = new Date(`${tahun1}`)\ntahun2Date = new Date(`${tahun2}`)\ntahunMin = new Date(Math.min(tahun1Date, tahun2Date))\ntahunMaks = new Date(Math.max(tahun1Date, tahun2Date))\nanakJudul = pendapatanTerpilih === \"pendapatan\" \n  ? null \n  : pendapatanTerpilih === \"pendapatan_infl\" \n    ? \"Disesuaikan dengan Inflasi, Nilai Dolar Tahun 2023\" \n    : null\nwarnaTerpilih = daftarFormat\n  .map((f, i) =&gt; (formatTerpilih.includes(f) ? warnaFormat[i] : null))\n  .filter((color) =&gt; color !== null)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKodedaftarFormat = [\"LP/EP\", \"Vinyl Single\", \"8 - Track\", \"Cassette\", \"Cassette Single\",\n             \"Other Tapes\", \"Kiosk\", \"CD\", \"CD Single\", \"SACD\", \"DVD Audio\",\n             \"Music Video (Physical)\", \"Download Album\", \"Download Single\",\n             \"Ringtones & Ringbacks\", \"Download Music Video\", \"Other Digital\",\n             \"Synchronization\", \"Paid Subscription\", \"On-Demand Streaming (Ad-Supported)\",\n             \"Other Ad-Supported Streaming\", \"SoundExchange Distributions\",\n             \"Limited Tier Paid Subscription\"]\n\n\n\n\n\n\n\nKodewarnaFormat = [\"#2A5784\", \"#43719F\", \"#5B8DB8\", \"#7AAAD0\", \"#9BC7E4\", \"#BADDF1\", \n            \"#E1575A\", \"#EE7423\", \"#F59D3D\", \"#FFC686\", \"#9D7760\", \"#F1CF63\", \n            \"#7C4D79\", \"#9B6A97\", \"#BE89AC\", \"#D5A5C4\", \"#EFC9E6\", \"#BBB1AC\", \n            \"#24693D\", \"#398949\", \"#61AA57\", \"#7DC470\", \"#B4E0A7\"]"
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#sec-catatan-akhir",
    "href": "pos/2025-01-pendapatan-musik/index.html#sec-catatan-akhir",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah memvisualisasikan data pendapatan industri musik dengan beragam cara. Pada Bagian 2 dan Bagian 3, kita melakukan visualisasi dengan pemrograman R. Bagian-bagian itu mendemonstrasikan bagaimana membuat diagram dengan menggunakan {ggplot2} dan {plotly}. Kedua paket tersebut sangat membantu untuk melakukan visualisasi data, baik statis maupun dinamis.\nPada Bagian 4, kita menggunakan Observable Plot untuk membuat diagram yang serupa. Pada Bagian 5, kita lengkapi diagram tersebut dengan beberapa input untuk membuat diagramnya semakin dinamis. Teknik visualisasi data seperti ini sangat berguna jika kita ingin mempresentasikan data dengan media daring.\nApa selanjutnya? Teknik visualisasi yang didemonstrasikan dalam artikel ini tentu dapat dikembangkan lagi. Misalnya, jika kamu ingin berfokus untuk membuat animasi, kamu dapat menggunakan {gganimate}. Kamu ingin menyelam lebih dalam tentang interaktivitas dengan R? Kamu dapat mencoba {shiny}. Terakhir, jika kamu ingin belajar lebih lanjut tentang visualisasi data dengan Observable JS, kamu patut mencoba D3."
  },
  {
    "objectID": "pos/2025-01-pendapatan-musik/index.html#footnotes",
    "href": "pos/2025-01-pendapatan-musik/index.html#footnotes",
    "title": "Visualisasi Data Pendapatan Industri Musik",
    "section": "Catatan Kaki",
    "text": "Catatan Kaki\n\nPada umumnya, diagram garis dipilih untuk menyajikan data yang menyatakan tren (sumbu horizontalnya menyatakan waktu).↩︎"
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html",
    "title": "Klasterisasi K-Rerata",
    "section": "",
    "text": "Ada banyak metode untuk memanipulasi sebuah gambar. Salah satunya ditunjukkan pada Gambar 1. Apa perbedaan gambar sebelah kiri dan kanan pada gambar tersebut?\nYup! Gambar sebelah kiri memiliki warna yang lebih bervariasi daripada yang kanan. Faktanya, gambar di sebelah kiri memiliki hampir 40 ribu warna sedangkan yang sebelah kanan hanya empat warna saja. Bagaimana cara melakukannya?\nTentu ada banyak cara untuk melakukannya. Akan tetapi, salah satunya adalah dengan menggunakan klasterisasi \\(k\\)-rerata. Untuk itu, kita akan belajar teknik klasterisasi tersebut. Kita awali dengan (a) latar belakang perlunya klasterisasi, kemudian (b) kita belajar bagaimana algoritmanya bekerja, dan akhirnya (c) kita aplikasikan algoritma tersebut untuk membagi data menjadi beberapa klaster. Jangan khawatir, penerapan algoritmanya nanti kita lakukan secara langkah demi langkah. Kita lakukan semuanya dengan menggunakan pemrograman R. Untuk itu, kita buka paket-paket yang diperlukan.\nKodelibrary(tidyverse)\nlibrary(cowplot)"
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-paradoks-simpson",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-paradoks-simpson",
    "title": "Klasterisasi K-Rerata",
    "section": "Paradoks Simpson",
    "text": "Paradoks Simpson\nBayangkan kamu ingin menemukan model untuk datamu, misalnya contoh_data. Biasanya, kamu perlu memvisualisasikan data tersebut untuk melihat polanya. Diagram pencar data tersebut disajikan pada Gambar 2.\n\n\n\n\n\n\n\nGambar 2: Diagram pencar contoh_data\n\n\n\n\nBerdasarkan Gambar 2, kamu kemungkinan besar menduga bahwa hubungan antara x dan y dalam data tersebut mengikuti model linear dengan korelasi positif: semakin besar nilai x, semakin besar juga nilai y. Dengan demikian, kamu akan mendapatkan model seperti yang ditunjukkan pada Gambar 3.\n\n\n\n\n\n\n\nGambar 3: Model linear untuk variabel-variabel x dan y dalam contoh_data\n\n\n\n\nAkan tetapi, setelah dicermati kembali, tampaknya contoh_data tersebut terbagi menjadi beberapa klaster. Berdasarkan pengamatan terhadap Gambar 3 saja, kita dapat melihat bahwa data tersebut memiliki lima klaster. Setelah mempertimbangkan klaster-klaster tersebut, kita mendapatkan model linear yang sama sekali berbeda. Perhatikan Gambar 4!\n\n\n\n\n\n\n\nGambar 4: Model linear untuk variabel-variabel x dan y setelah mempertimbangkan klaster-klaster dalam contoh_data\n\n\n\n\nFenomena yang baru saja kita alami tersebut dinamakan paradoks Simpson. Kita mendapatkan korelasi yang positif ketika kita tidak mempertimbangkan klaster, dan korelasinya negatif ketika kita mempertimbangkan klaster. Oleh karena itu, penting bagi kita untuk mencermati data secara lebih hati-hati, khususnya jika dalam data tersebut memuat beberapa klaster.\nInformasi tentang klaster-klaster tersebut mungkin sudah ada dalam data. Akan tetapi, informasi tersebut juga mungkin belum ada. Jika klaster-klaster tersebut belum ada, kita dapat melakukan analisis klaster dengan menggunakan klasterisasi \\(k\\)-rerata (atau \\(k\\)-means clustering). Bagaimana caranya? Mari kita bahas di bagian berikutnya, Bagian 2.\n\n\n\n\n\n\nJika kamu ingin menemukan ide mendasar algoritma \\(k\\)-rerata secara terbimbing, silakan kunjungi media interaktif di tautan berikut. Media interaktif itu akan memandumu menemukan algoritma tersebut secara mandiri."
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-klasterisasi-k-rerata",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-klasterisasi-k-rerata",
    "title": "Klasterisasi K-Rerata",
    "section": "Klasterisasi \\(K\\)-Rerata",
    "text": "Klasterisasi \\(K\\)-Rerata\nKlasterisasi \\(k\\)-rerata merupakan algoritma pemelajaran mesin (machine learning) tanpa pengawasan yang membagi data tak berlabel menjadi \\(k\\) klaster yang berbeda dan tak saling tumpang tindih. Sebelum dilakukan klasterisasi ini, banyaknya klaster \\(k\\) perlu ditentukan terlebih dahulu. Algoritma klasterisasi ini adalah sebagai berikut.\n\nInisialisasi: Pertama, kita pilih banyaknya klaster, yaitu \\(k\\). Setelah itu, algoritmanya akan memposisikan \\(k\\) titik secara acak sebagai pusat klaster (centroid) yang pertama.\nPenugasan: Setiap titik data dipasangkan ke pusat klaster terdekat. Proses ini menghasilkan \\(k\\) klaster awal.\nPembaruan: Setelah semua titik masuk ke dalam klaster, algoritmanya kemudian menghitung kembali koordinat tiap-tiap pusat klasternya. Pusat klaster tersebut merupakan rerata dari semua titik dalam klaster tersebut.\nUlangi: Langkah 2 dan 3 diulangi kembali. Ketika pusat klaster berpindah, setiap titik datanya dipasangkan kembali dengan pusat klaster baru yang terdekat, kemudian pusat setiap klasternya dihitung kembali. Proses ini diulang secara terus menerus sampai pusat klasternya tidak berpindah secara signifikan atau banyak maksimum iterasinya tercapai.\n\nPenasaran dengan bagaimana algoritma tersebut bekerja? Pada bagian berikutnya, Bagian 3, kita akan menerapkan algoritma tersebut kepada Old Faithful Geyser."
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-penerapan-algoritma-k-rerata",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-penerapan-algoritma-k-rerata",
    "title": "Klasterisasi K-Rerata",
    "section": "Penerapan Algoritma \\(K\\)-Rerata",
    "text": "Penerapan Algoritma \\(K\\)-Rerata\nKita terapkan algoritma \\(k\\)-rerata kepada data Old Faithful Geyser. Data ini sudah ada dalam R dengan nama faithful. Data ini memuat 272 baris dan dua variabel. Variabel waiting merupakan selang waktu antara dimulainya dua erupsi yang berurutan, sedangkan variabel eruptions merupakan lamanya erupsi yang kedua. Mari kita panggil data ini lihat beberapa barisnya dengan kode berikut.\n\nKodedata(\"faithful\")\n\nhead(faithful)\n\n  eruptions waiting\n1     3.600      79\n2     1.800      54\n3     3.333      74\n4     2.283      62\n5     4.533      85\n6     2.883      55\n\n\nKita dapat mengenal data faithful tersebut secara lebih dekat dengan membuat diagram pencarnya. Perhatikan Gambar 5!\n\nKodefaithful |&gt; \n  ggplot(aes(x = eruptions, y = waiting)) + \n  geom_point() + \n  theme_minimal()\n\n\n\n\n\n\nGambar 5: Diagram pencar hubungan antara eruptions dan waiting dalam data faithful\n\n\n\n\nBerdasarkan Gambar 5, kita dapat melihat bahwa tampaknya data faithful memiliki dua klaster. Oleh karena itu, kita akan pilih \\(k=2\\). Sebelum kita menerapkan algoritma \\(k\\)-rerata, terlebih dahulu kita normalbakukan variabel-variabel dalam data faithful tersebut. Mengapa demikian?\nKlasterisasi \\(k\\)-rerata menggunakan jarak untuk menentukan klaster tiap-tiap titik datanya. Jika variabel-variabelnya memiliki skala yang berbeda (variabel eruptions merentang dari 1.6 sampai 5.1 sedangkan waiting merentang dari 43 sampai 96), variabel yang jangkauannya lebih besar tentu memiliki dampak besar terhadap perhitungan jaraknya. Hal ini akan menyebabkan hasil klasterisasinya tidak akurat.\nOleh karena itu, kita normalbakukan variabel-variabel eruptions dan waiting untuk membuat variabel-variabel baru, yaitu eruptions_std dan waiting_std. Untuk melihat hasilnya, kita dapat tampilkan beberapa baris pertamanya.\n\nKodefaithful &lt;- faithful |&gt; \n  mutate(\n    eruptions_std = scale(eruptions),\n    waiting_std = scale(waiting)\n  )\n\nhead(faithful)\n\n  eruptions waiting eruptions_std waiting_std\n1     3.600      79    0.09831763   0.5960248\n2     1.800      54   -1.47873278  -1.2428901\n3     3.333      74   -0.13561152   0.2282418\n4     2.283      62   -1.05555759  -0.6544374\n5     4.533      85    0.91575542   1.0373644\n6     2.883      55   -0.52987412  -1.1693335\n\n\nOkay! Data faithful telah siap dihidangkan untuk klasterisasi \\(k\\)-rerata dengan \\(k=2\\). Tak usah berlama-lama, mari kita mulai ke iterasi yang pertama.\nIterasi 1\nKita telah menentukan \\(k=2\\), sehingga algoritma tersebut selanjutnya menentukan dua titik secara acak sebagai pusat klaster-klaster awalnya. Untuk alasan demonstrasi, kita tentukan dua titik tersebut adalah \\(\\left( -1.4, 1 \\right)\\) dan \\(\\left( 1.4, -1 \\right)\\). Berikutnya, kita tentukan jarak setiap titik ke pusat klaster-klaster awal tersebut. Titik-titik yang lebih dekat ke \\(\\left( -1.4, 1 \\right)\\) berarti masuk ke “Klaster 1”, sedangkan titik-titik yang lebih dekat ke \\(\\left( 1.4, -1 \\right)\\) berarti masuk ke “Klaster 2”.\nUntuk data dengan dua variabel dan \\(k=2\\), penentuan klaster ini juga dapat dilakukan dengan menggunakan garis yang tegak lurus dengan ruas garis yang menghubungkan dua pusat klaster tersebut dan membagi ruas garis tersebut menjadi dua sama panjang. Titik-titik data yang berada pada sisi yang sama dengan pusat klaster pertama masuk ke “Klaster 1”, sedangkan sisanya masuk ke “Klaster 2”.\n\nKodefaithful_1_1 &lt;- faithful |&gt; \n  select(eruptions_std, waiting_std) |&gt; \n  mutate(\n    d1 = (eruptions_std - (-1.4))^2 + (waiting_std - 1)^2,\n    d2 = (eruptions_std - 1.4)^2 + (waiting_std - (-1))^2,\n    d = if_else(d1 &lt;= d2, d1, d2),\n    klaster = if_else(d1 &lt;= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_1_1)\n\n  eruptions_std waiting_std       d1       d2        d   klaster\n1    0.09831763   0.5960248 2.408152 4.241672 2.408152 Klaster 1\n2   -1.47873278  -1.2428901 5.036755 8.346098 5.036755 Klaster 1\n3   -0.13561152   0.2282418 2.194289 3.866681 2.194289 Klaster 1\n4   -1.05555759  -0.6544374 2.855804 6.149177 2.855804 Klaster 1\n5    0.91575542   1.0373644 5.364119 4.385346 4.385346 Klaster 2\n6   -0.52987412  -1.1693335 5.463127 3.753088 3.753088 Klaster 2\n\n\nAgar dua klaster yang terbentuk dapat terlihat dengan jelas, mari kita visualisaskan titik-titik datanya, beserta dengan garis yang membagi titik-titik tersebut menjadi dua klaster. Perhatikan Gambar 6!\n\nKodeplot_1_1 &lt;- faithful_1_1 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = tibble(\n      x = c(-1.4, 1.4),\n      y = c(1, -1),\n      klaster = c(\"Klaster 1\", \"Klaster 2\")\n    ),\n    aes(x, y),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = tibble(\n      x = c(-1.4, 1.4),\n      y = c(1, -1),\n      klaster = c(\"Klaster 1\", \"Klaster 2\")\n    ),\n    aes(x, y, color = klaster),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = 7/5,\n    intercept = 0,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_1_1\n\n\n\n\n\n\nGambar 6: Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi pertama (Iterasi 1-1)\n\n\n\n\nLangkah kedua di iterasi pertama adalah menentukan pusat masing-masing klaster dengan cara menentukan reratanya.\n\nKodepusat_klaster_1_2 &lt;- faithful_1_1 |&gt; \n  group_by(klaster) |&gt; \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_1_2\n\n# A tibble: 2 × 3\n  klaster        x      y\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n1 Klaster 1 -0.730 -0.449\n2 Klaster 2  0.678  0.418\n\n\nSelanjutnya, kita plot pusat klaster-klaster yang baru tersebut ke diagram pencar sebelumnya, menggantikan pusat-pusat klaster yang lama. Hasilnya disajikan pada Gambar 7.\n\nKode# Menyiapkan data `faithful_1_2`\nfaithful_1_2 &lt;- faithful_1_1 |&gt; \n  select(eruptions_std, waiting_std, klaster) |&gt; \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_1_2[[1,2]])^2 + (waiting_std - pusat_klaster_1_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_1_2[[2,2]])^2 + (waiting_std - pusat_klaster_1_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 1-2\nplot_1_2 &lt;- faithful_1_2 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_1_2\n\n\n\n\n\n\nGambar 7: Pusat dua klaster pada langkah kedua dalam iterasi pertama (Iterasi 1-2)\n\n\n\n\nIterasi pertama telah selesai dilakukan. Sekarang kita lanjut ke Bagian 3.2.\nIterasi 2\nKita masuk ke iterasi yang kedua. Pada langkah pertama, kita gunakan pusat klaster-klaster sebelumnya untuk memasukkan titik-titik datanya ke klasternya masing-masing.\n\nKodefaithful_2_1 &lt;- faithful_1_2 |&gt; \n  select(-d, -klaster) |&gt; \n  mutate(\n    d = if_else(d1 &lt;= d2, d1, d2),\n    klaster = if_else(d1 &lt;= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_2_1)\n\n  eruptions_std waiting_std        d1        d2         d   klaster\n1    0.09831763   0.5960248 1.7796010 0.3683804 0.3683804 Klaster 2\n2   -1.47873278  -1.2428901 1.1897322 7.4106840 1.1897322 Klaster 1\n3   -0.13561152   0.2282418 0.8128978 0.6985503 0.6985503 Klaster 2\n4   -1.05555759  -0.6544374 0.1478379 4.1560559 0.1478379 Klaster 1\n5    0.91575542   1.0373644 4.9200217 0.4404101 0.4404101 Klaster 2\n6   -0.52987412  -1.1693335 0.5583201 3.9784302 0.5583201 Klaster 1\n\n\nKita visualisasikan titik-titik data dalam faithful beserta dengan klaster-klaster yang telah dihasilkan. Perhatikan Gambar 8!\n\nKodeplot_2_1 &lt;- faithful_2_1 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 2,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_1_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.624589,\n    intercept = -0.058,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_2_1\n\n\n\n\n\n\nGambar 8: Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi kedua (Iterasi 2-1)\n\n\n\n\nBerikutnya, kita tentukan pusat klaster-klaster yang baru. Caranya sama, yaitu kita tentukan rerata semua titik pada masing-masing klaster.\n\nKodepusat_klaster_2_2 &lt;- \n  faithful_2_1 |&gt; \n  group_by(klaster) |&gt; \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_2_2\n\n# A tibble: 2 × 3\n  klaster        x      y\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n1 Klaster 1 -1.21  -1.16 \n2 Klaster 2  0.729  0.698\n\n\nApa selanjutnya? Kita plot pusat-pusat klaster yang baru beserta dengan titik-titik datanya. Hasilnya disajikan pada Gambar 9.\n\nKode# Mempersiapkan `faithful_2_2`\nfaithful_2_2 &lt;- faithful_2_1 |&gt; \n  select(eruptions_std, waiting_std, klaster) |&gt; \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_2_2[[1,2]])^2 + (waiting_std - pusat_klaster_2_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_2_2[[2,2]])^2 + (waiting_std - pusat_klaster_2_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 2-2\nplot_2_2 &lt;- faithful_2_2 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_2_2\n\n\n\n\n\n\nGambar 9: Pusat-pusat klaster pada langkah kedua dalam iterasi kedua (Iterasi 2-2)\n\n\n\n\nMari kita lanjut ke iterasi berikutnya, Bagian 3.3.\nIterasi 3\nPada langkah pertama di iterasi ketiga, kita pasangkan setiap titik ke dalam klasternya masing-masing berdasarkan jaraknya terhadap pusat klaster-klaster yang baru.\n\nKodefaithful_3_1 &lt;- faithful_2_2 |&gt; \n  select(-d, -klaster) |&gt; \n  mutate(\n    d = if_else(d1 &lt;= d2, d1, d2),\n    klaster = if_else(d1 &lt;= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_3_1)\n\n  eruptions_std waiting_std         d1        d2          d   klaster\n1    0.09831763   0.5960248 4.81663204 0.4075842 0.40758421 Klaster 2\n2   -1.47873278  -1.2428901 0.07632207 8.6381936 0.07632207 Klaster 1\n3   -0.13561152   0.2282418 3.09872776 0.9672434 0.96724344 Klaster 2\n4   -1.05555759  -0.6544374 0.28368178 5.0114795 0.28368178 Klaster 1\n5    0.91575542   1.0373644 9.37813119 0.1503982 0.15039817 Klaster 2\n6   -0.52987412  -1.1693335 0.46850713 5.0695722 0.46850713 Klaster 1\n\n\nSelanjutnya kita plot titik-titik yang telah masuk ke dalam klasternya masing-masing dengan menggunakan diagram pencar. Perhatikan Gambar 10!\n\nKodeplot_3_1 &lt;- faithful_3_1 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_2_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.0436,\n    intercept = -0.486595,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_3_1\n\n\n\n\n\n\nGambar 10: Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi ketiga (Iterasi 3-1)\n\n\n\n\nPada langkah kedua, kita tentukan pusat-pusat klaster yang baru. Caranya adalah sebagai berikut.\n\nKodepusat_klaster_3_2 &lt;- faithful_3_1 |&gt; \n  group_by(klaster) |&gt; \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std)\n  )\n\npusat_klaster_3_2\n\n# A tibble: 2 × 3\n  klaster        x      y\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n1 Klaster 1 -1.25  -1.19 \n2 Klaster 2  0.715  0.680\n\n\nKita plot pusat klaster-klaster yang baru tersebut bersama dengan titik-titik data sebelumnya. Perhatikan Gambar 11!\n\nKode# Mempersiapkan `faithful_3_2`\nfaithful_3_2 &lt;- faithful_3_1 |&gt; \n  select(eruptions_std, waiting_std, klaster) |&gt; \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_3_2[[1,2]])^2 + (waiting_std - pusat_klaster_3_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_3_2[[2,2]])^2 + (waiting_std - pusat_klaster_3_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 3-2\nplot_3_2 &lt;- faithful_3_2 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_3_2\n\n\n\n\n\n\nGambar 11: Pusat-pusat klaster pada langkah kedua dalam iterasi ketiga (Iterasi 2-2)\n\n\n\n\nKita telah menyelesaikan langkah kedua dalam iterasi ketiga. Sekarang, mari kita lanjut ke iterasi berikutnya!\nIterasi 4\nApa langkah pertama di iterasi keempat ini? Ya! Kita masukkan setiap titik ke dalam klasternya berdasarkan jaraknya ke pusat klaster-klaster yang terakhir.\n\nKodefaithful_4_1 &lt;- faithful_3_2 |&gt; \n  select(-d, -klaster) |&gt; \n  mutate(\n    d = if_else(d1 &lt;= d2, d1, d2),\n    klaster = if_else(d1 &lt;= d2, \"Klaster 1\", \"Klaster 2\")\n  )\n\nhead(faithful_4_1)\n\n  eruptions_std waiting_std         d1        d2          d   klaster\n1    0.09831763   0.5960248 4.99975759 0.3869199 0.38691994 Klaster 2\n2   -1.47873278  -1.2428901 0.05581732 8.5091284 0.05581732 Klaster 1\n3   -0.13561152   0.2282418 3.24674404 0.9271753 0.92717528 Klaster 2\n4   -1.05555759  -0.6544374 0.32272192 4.9148263 0.32272192 Klaster 1\n5    0.91575542   1.0373644 9.64038624 0.1680127 0.16801271 Klaster 2\n6   -0.52987412  -1.1693335 0.51720760 4.9695885 0.51720760 Klaster 1\n\n\nSekarang setiap titik telah memiliki klasternya masing-masing. Kita plot titik-titik tersebut ke dalam diagram pencar. Perhatikan Gambar 12!\n\nKodeplot_4_1 &lt;- faithful_4_1 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_3_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5\n  ) + \n  geom_abline(\n    slope = -1.0508,\n    intercept = -0.534564,\n    color = \"#00BA38\"\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_4_1\n\n\n\n\n\n\nGambar 12: Klaster-klaster yang terbentuk pada langkah pertama dalam iterasi keempat (Iterasi 4-1)\n\n\n\n\nKita lanjut ke langkah kedua. Di langkah kedua ini, kita cari pusat klaster-klasternya yang baru.\n\npusat_klaster_4_2 &lt;- faithful_4_1 |&gt; \n  group_by(klaster) |&gt; \n  summarise(\n    x = mean(eruptions_std),\n    y = mean(waiting_std),\n    .groups = \"drop\"\n  )\n\npusat_klaster_4_2\n\n# A tibble: 2 × 3\n  klaster        x      y\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n1 Klaster 1 -1.26  -1.20 \n2 Klaster 2  0.708  0.675\n\n\nBerikutnya, kita plot pusat-pusat klaster yang baru tersebut bersama dengan titik-titik datanya. Perhatikan gambar berikut!\n\nKode# Mempersiapkan `faithful_4_2`\nfaithful_4_2 &lt;- faithful_4_1 |&gt; \n  select(eruptions_std, waiting_std, klaster) |&gt; \n  mutate(\n    d1 = (eruptions_std - pusat_klaster_4_2[[1,2]])^2 + (waiting_std - pusat_klaster_4_2[[1,3]])^2,\n    d2 = (eruptions_std - pusat_klaster_4_2[[2,2]])^2 + (waiting_std - pusat_klaster_4_2[[2,3]])^2,\n    d = if_else(klaster == \"Klaster 1\", d1, d2)\n  )\n\n# Plot Iterasi 4-2\nplot_4_2 &lt;- faithful_4_2 |&gt; \n  ggplot() + \n  geom_point(\n    aes(\n      x = eruptions_std,\n      y = waiting_std,\n      color = klaster\n    )\n  ) + \n  geom_point(\n    data = pusat_klaster_4_2,\n    aes(\n      x = x,\n      y = y\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 3,\n    color = \"white\"\n  ) + \n  geom_point(\n    data = pusat_klaster_4_2,\n    aes(\n      x = x,\n      y = y,\n      color = klaster\n    ),\n    shape = 4,\n    size = 5,\n    stroke = 1.5,\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\nplot_4_2\n\n\n\n\n\n\nGambar 13: Pusat-pusat klaster pada langkah kedua dalam iterasi keempat (Iterasi 4-2)\n\n\n\n\nKilas Balik\nSampai di sini, kita telah melakukan empat kali iterasi. Apakah kita perlu melakukan iterasi lagi? Ataukah iterasinya sudah cukup? Untuk menjawab pertanyaan-pertanyaan tersebut, kita dapat menggunakan \\(WCSS\\) (Within-Cluster Sum of Squares) atau jumlah kuadrat jarak setiap titik ke pusat klasternya. Dengan demikian, \\(WCSS\\) ditentukan dengan Persamaan 1.\n\\[\nWCSS=\\sum_{j=1}^{k}\\sum_{x_{i}\\in C_{j}}^{}\\left\\| x_{i}-p_{j}\\right\\|^2\n\\tag{1}\\]\n\n\\(C_{j}\\) adalah klaster ke-\\(j\\).\n\\(x_{i}\\) adalah sebuah titik data dalam klaster \\(C_{j}\\).\n\\(p_{j}\\) adalah pusat klaster (centroid) dari \\(C_{j}\\).\n\\(\\left\\| x_{i} - p_{j} \\right\\|^2\\) adalah kuadrat jarak antara titik data dan pusat klasternya.\n\nDengan rumus ini, kita dapat menentukan \\(WCSS\\) pada langkah pertama dalam iterasi pertama sebagai berikut.\n\nKodewcss_1_1 &lt;- faithful_1_1 |&gt; \n  summarise(\n    wcss = sum(d)\n  )\n\nwcss_1_1\n\n      wcss\n1 1046.952\n\n\nDengan cara yang serupa, kita dapat menentukan \\(WCSS\\) untuk langkah pertama dan kedua dalam semua iterasi. Kita simpan nilai-nilai \\(WCSS\\) tersebut ke dalam wcss_df.\n\nKodedaftar_faithful &lt;- list(\n  \"1_1\" = faithful_1_1,\n  \"1_2\" = faithful_1_2,\n  \"2_1\" = faithful_2_1,\n  \"2_2\" = faithful_2_2,\n  \"3_1\" = faithful_3_1,\n  \"3_2\" = faithful_3_2,\n  \"4_1\" = faithful_4_1,\n  \"4_2\" = faithful_4_2\n)\n\nwcss_df &lt;- map_dfr(\n  daftar_faithful,\n  ~ summarise(.x, wcss = sum(d)),\n  .id = \"faithful\"\n) |&gt; \n  mutate(\n    iterasi = seq(from = 0.5, to = 4, by = 0.5),\n    group = as_factor(rep(c(\"M\", \"E\"), 4))\n  )\n\nwcss_df\n\n  faithful       wcss iterasi group\n1      1_1 1046.95159     0.5     M\n2      1_2  356.18666     1.0     E\n3      2_1  170.24221     1.5     M\n4      2_2   80.67025     2.0     E\n5      3_1   79.61314     2.5     M\n6      3_2   79.34288     3.0     E\n7      4_1   79.31314     3.5     M\n8      4_2   79.28340     4.0     E\n\n\nKita telah memiliki untuk setiap langkahnya dalam wcss_df. Sekarang, kita dapat melihat tren nilai \\(WCSS\\) tersebut. Perhatikan Gambar 14!\n\nKodewcss_df |&gt; \n  ggplot(aes(x = iterasi, y = wcss)) + \n  geom_line(\n    col = \"#00BA38\",\n    linewidth = 1\n  ) + \n  geom_point(\n    aes(col = group),\n    shape = 1,\n    size = 3,\n    stroke = 1.5\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\nGambar 14: Tren nilai WCSS dari langkah pertama iterasi pertama sampai langkah kedua iterasi keempat\n\n\n\n\nBerdasarkan Gambar 14, kita dapat melihat bahwa nilai \\(WCSS\\) sudah konvergen pada iterasi kedua. Bahkan, dari iterasi ketiga sampai keempat, perubahan anggota kluster sudah tidak signifikan. Oleh karena itu, iterasinya kita cukupkan sampai iterasi keempat. Untuk melihat kembali apa yang telah kita lakukan mulai iterasi pertama sampai keempat, perhatikan Gambar 15!\n\n\n\n\n\n\n\nGambar 15: Empat iterasi klasterasisasi k-rerata terhadap data faithful yang dinormalbakukan."
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-klasterisasi-k-rerata-dengan-fungsi-kmeans",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-klasterisasi-k-rerata-dengan-fungsi-kmeans",
    "title": "Klasterisasi K-Rerata",
    "section": "Klasterisasi \\(K\\)-Rerata dengan Fungsi kmeans()\n",
    "text": "Klasterisasi \\(K\\)-Rerata dengan Fungsi kmeans()\n\nPada Bagian 3, kita telah melakukan klasterisasi \\(k\\)-rerata langkah demi langkah, dari iterasi pertama sampai keempat. Banyak hal yang telah kita lakukan. Apakah ada fungsi di R yang dapat melakukan klasterisasi \\(k\\)-rerata secara otomatis dan cepat? Tentu saja ada! Fungsi itu adalah kmeans().\nUntuk membagi data kita sebelumnya, yaitu faithful, menjadi \\(k=2\\) klaster, kita gunakan kode seperti pada Daftar 1.\n\n\n\nDaftar 1: Klusterasi krerata dengan kmeans()\n\nKode# Menyiapkan dataframe untuk `kmeans()`\nfaithful_std &lt;- faithful |&gt; \n  select(eruptions_std, waiting_std)\n\n# Menerapkan `kmeans()`\nhasil_krerata &lt;- kmeans(x = faithful_std, centers = 2)\n\n\n\n\n\nHasil klasterisasi \\(k\\)-rerata yang telah kita lakukan pada Daftar 1 disimpan dalam sebuah objek dengan nama hasil_krerata. Terdapat beberapa nilai yang dapat kita lihat dari hasil_krerata tersebut, di antaranya adalah cluster (sebuah vektor bilangan bulat dari 1 sampai \\(k\\) yang mengindikasikan klaster-klaster setiap titiknya), centers (matriks pusat klaster-klaster yang terbentuk), totss (total dari jumlah kuadrat), withinss (vektor dari jumlah kuadrat dalam setiap klasternya), tot.withinss (total dari jumlah kuadrat dalam setiap klasternya, yaitu sum(withinss), atau \\(WCSS\\)), betweenss (jumlah kuadrat antarklasternya, yaitu totss-tot.withinss), size (banyaknya titik dalam setiap klaster), dan iter (banyaknya iterasi).\nSekarang kita masukkan informasi klaster dalam hasil_krerata tersebut (yaitu hasil_kerata$cluster) ke dalam data faithful dan kita lihat hasilnya.\n\nKode# Memasukkan klaster yang dihasilkan ke dalam `faithful`\nfaithful &lt;- faithful |&gt; \n  mutate(\n    klaster = hasil_krerata$cluster\n  )\n\nhead(faithful)\n\n  eruptions waiting eruptions_std waiting_std klaster\n1     3.600      79    0.09831763   0.5960248       2\n2     1.800      54   -1.47873278  -1.2428901       1\n3     3.333      74   -0.13561152   0.2282418       2\n4     2.283      62   -1.05555759  -0.6544374       1\n5     4.533      85    0.91575542   1.0373644       2\n6     2.883      55   -0.52987412  -1.1693335       1\n\n\nIngin tahu bagaimana visualisasi hasilnya? Mari kita plot diagram pencar data faithful. Perhatikan Gambar 16!\n\nKodefaithful |&gt; \n  mutate(\n    klaster = as_factor(3 - klaster)\n  ) |&gt; \n  ggplot(\n    aes(x = eruptions_std, y = waiting_std, color = klaster)\n  ) + \n  geom_point() + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\nGambar 16: Klaster-klaster dalam data faithful hasil klasterisasi k-rerata dengan fungsi kmeans()\n\n\n\n\nApakah Gambar 16 sama dengan Gambar 13? Ternyata sama hasilnya."
  },
  {
    "objectID": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-catatan-akhir",
    "href": "pos/2025-09-klasterisasi-k-rerata/index.html#sec-catatan-akhir",
    "title": "Klasterisasi K-Rerata",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah mempelajari klasterisasi \\(k\\)-rerata. Mengapa kita perlu mempelajari metode ini? Jawabannya telah kita pelajari pada Bagian 1. Setelah itu, bagaimana kerja algoritma \\(k\\)-rerata juga telah kita bahas di Bagian 2. Langkah-langkah rinci algoritma tersebut telah diilustrasikan pada Bagian 3. Tak hanya itu, Bagian 4 juga memberikan jalan cepat dengan fungsi kmeans().\nSekarang, kita kembali ke permasalahan awal. Bagian awal artikel ini menyebutkan bahwa klasterisasi \\(k\\)-means dapat digunakan untuk memanipulasi gambar sehingga menghasilkan Gambar 1. Bagaimana caranya? Tutorial selengkapnya dapat ditemukan pada pos berikutnya!"
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html",
    "title": "Klasterisasi Warna Foto",
    "section": "",
    "text": "Apa yang kamu lihat dari sebuah foto? Mungkin kamu melihat kenangan yang tersimpan. Mungkin kamu juga ingin menggali pesan yang tersirat. Oke, mari kita melihat sebuah foto atau gambar dari sudut pandang yang berbeda! Kita dapat melihat sebuah gambar sebagai matriks.\nPerhatikan Gambar 1! Apa yang dilihat oleh orang dalam meme pada Gambar 1? Karena terlalu kecil, mari kita memperbesarnya dan menaruhnya ke bidang koordinat Kartesius. Kita lakukan hal itu dengan pemrograman R. Untuk itu, kita panggil paket-paket yang kita perlukan seperti pada Daftar 1.\nDaftar 1: Memuat paket-paket yang diperlukan\n\nKodelibrary(magick)\nlibrary(tidyverse)\nlibrary(scatterplot3d)\nlibrary(scales)\nlibrary(cowplot)\nPaket-paketnya telah siap. Kita lanjut memperbesar gambar yang dilihat oleh orang dalam meme tersebut dan memposisikannya dalam bidang koordinat Kartesius. Perhatikan Gambar 2!\nGambar 2: Gambar epsilon berukuran 8 piksel × 8 piksel pada bidang koordinat Kartesius\nSekarang, apa yang kamu amati dari Gambar 2? Ternyata itu adalah simbol epsilon. Meskipun tampak kabur, piksel-piksel epsilon tersebut tampak jelas. Setiap piksel berkorespondensi dengan satu warna. Warna tersebut dapat dinyatakan ke dalam tiga warna dasarnya, yaitu RGB (red, green, dan blue). Dengan demikian, kita dapat menyatakan gambar tersebut sebagai tiga matriks warna dasar: \\(R\\), \\(G\\), dan \\(B\\).\n[1] \"Matriks R\"\n\n\n       1   2   3   4   5   6   7   8\n[1,] 171 177 181 183 183 181 177 172\n[2,] 177 183 156  53 117  67 138 177\n[3,] 181 189  90  73 201 129 128 182\n[4,] 183 192 163  58 140 174 192 184\n[5,] 183 148  30 133 208 201 192 184\n[6,] 181  91  23 197 149  49 189 182\n[7,] 177 153  50 119  77 122 183 177\n[8,] 172 177 182 184 184 182 177 172\n\n\n[1] \"Matriks G\"\n\n\n       1   2   3   4   5   6   7   8\n[1,] 200 204 207 209 208 207 204 201\n[2,] 204 208 184  98 151 110 170 204\n[3,] 207 212 129 114 220 161 161 208\n[4,] 209 214 188 101 169 198 214 209\n[5,] 209 177  78 163 225 220 214 209\n[6,] 207 130  73 217 177  94 212 208\n[7,] 204 183  96 153 118 156 208 204\n[8,] 201 204 208 209 209 208 204 201\n\n\n[1] \"Matriks B\"\n\n\n       1   2   3   4   5   6   7   8\n[1,] 209 212 215 216 216 215 212 209\n[2,] 212 216 195 121 166 131 183 212\n[3,] 215 219 148 135 225 174 175 215\n[4,] 216 220 198 124 182 206 220 216\n[5,] 216 189 104 177 229 225 220 216\n[6,] 215 148 100 222 188 118 219 215\n[7,] 212 194 119 168 138 171 216 212\n[8,] 209 212 215 216 216 215 212 209\nOkay, kita telah dapat melihat sebuah gambar dengan menggunakan matriks-matriks \\(R\\), \\(G\\), dan \\(B\\). Kita dapat memasangkan nilai-nilai yang bersesuaian dari matriks tersebut sebagai triplet. Misalnya, komponen pada baris pertama dan kolom pertama dalam matriks-matriks \\(R\\), \\(G\\), dan \\(B\\), secara berturut-turut adalah 171, 200, dan 209. Dengan demikian, kita mendapatkan satu triplet \\(\\left( 171,200,209 \\right)\\). Dengan cara ini, kita juga dapat membuat 63 triplet lainnya.\nSekarang kita memiliki 64 triplet. Semua triplet yang merepresentasikan warna tersebut dapat kita plot dalam ruang dimensi tiga. Hasilnya ditunjukkan pada Gambar 3.\nGambar 3: Titik-titik dalam ruang yang merepresentasikan warna dalam gambar epsilon\nNah, sekarang kita dapat melihat sebuah gambar atau foto dengan menggunakan matriks, yaitu tiga matriks warna dasarnya. Dari tiga matriks tersebut, kita dapat mengkonstruksi titik-titik yang merepresentasikan warna tersebut ke dalam ruang dimensi tiga. Kita gunakan perspektif seperti ini untuk memanipulasi sebuah foto sehingga variasi warnanya tereduksi. Tujuan kita berikutnya adalah untuk membuat foto Gambar 4 (a) menjadi Gambar 4 (b). Hal ini telah dijanjikan pada pos sebelumnya.\nBagaimana cara mencapai tujuan tersebut? Mari kita bahas gambaran umumnya terlebih dahulu pada bagian berikutnya."
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-ide-dasar",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-ide-dasar",
    "title": "Klasterisasi Warna Foto",
    "section": "Ide Dasar",
    "text": "Ide Dasar\nUntuk menyerhanakan warna foto pada Gambar 4 (a), kita gunakan perspektif yang telah dibahas pada bagian sebelumnya. Setelah itu, kita terapkan klasterisasi \\(k\\)-rerata terhadap titik-titik warna yang dihasilkan. Secara umum, tahapan-tahapan utama yang nanti kita lakukan adalah sebagai berikut.\n\nMengekstrak data warna R, G, dan B dari foto.\nKlasterisasi \\(k\\)-rerata terhadap data warna.\nMengganti setiap warna pada foto asli dengan pusat klasternya.\n\nDengan cara seperti itu, kita akan mendapatkan sebuah foto yang hanya memuat \\(k\\) warna. Warna-warna itu diperoleh dari pusat klaster-klaster yang terbentuk. Tak perlu berlama-lama, mari kita mulai tahapan pertamanya."
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-mengekstrak-data-warna",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-mengekstrak-data-warna",
    "title": "Klasterisasi Warna Foto",
    "section": "Mengekstrak Data Warna",
    "text": "Mengekstrak Data Warna\nTahapan pertamanya adalah mengestrak data warna dari sebuah foto. Foto awal yang kita gunakan adalah foto pada Gambar 4 (a). Untuk melakukannya, kita gunakan kode pada Daftar 2.\n\n\n\nDaftar 2: Membuat data warna dari foto\n\nKode# Memuat dan menskala gambar\nfoto_ku &lt;- image_read(\n  \"aset/karuna_donau.png\"\n) |&gt; \n  image_scale(\"256x256!\")\n\n# Ekstrak data mentah piksel\ndata_mentah_foto &lt;- image_data(foto_ku)\n\n# Ukuran foto\nlebar_foto  &lt;- dim(data_mentah_foto)[2]\ntinggi_foto &lt;- dim(data_mentah_foto)[3]\n\n# Konversi ke data frame dan membalik koordinat y\nrgb_foto_df &lt;- as.data.frame.table(data_mentah_foto, responseName = \"nilai\") |&gt;\n  mutate(\n    kanal = as.integer(Var1),\n    koord_x = as.integer(Var2),\n    koord_y = as.integer(Var3),\n    nilai   = as.integer(nilai)\n  ) |&gt;\n  select(kanal, koord_x, koord_y, nilai) |&gt;\n  pivot_wider(\n    names_from = kanal,\n    values_from = nilai,\n    names_prefix = \"ch\"\n  ) |&gt;\n  transmute(\n    koord_x,\n    koord_y = tinggi_foto - koord_y + 1,\n    R = ch1,\n    G = ch2,\n    B = ch3,\n    R_norm = R / 255,\n    G_norm = G / 255,\n    B_norm = B / 255,\n    warna_hex = rgb(R_norm, G_norm, B_norm)\n  )\n head(rgb_foto_df)\n\n\n\n\n\n# A tibble: 6 × 9\n  koord_x koord_y     R     G     B R_norm G_norm B_norm warna_hex\n    &lt;int&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    \n1       1     256   117   171   233  0.459  0.671  0.914 #75ABE9  \n2       2     256   117   173   234  0.459  0.678  0.918 #75ADEA  \n3       3     256   116   172   233  0.455  0.675  0.914 #74ACE9  \n4       4     256   116   172   233  0.455  0.675  0.914 #74ACE9  \n5       5     256   115   170   234  0.451  0.667  0.918 #73AAEA  \n6       6     256   120   171   234  0.471  0.671  0.918 #78ABEA  \n\n\nDari kode di atas, kita mendapatkan data warna rgb_foto_df. Data tersebut memuat koordinat piksel-pikselnya (koord_x dan koord_y), warna dasar setiap pikselnya (R, G, dan B), dan warna-warna dasar tersebut yang telah diskala agar minimumnya 0 dan maksimumnya 1 (R_norm, G_norm, dan B_norm). Selain itu, kita juga membuat kolom warna_hex untuk merangkum informasi warna pada kolom-kolom R, G, dan B.\nMari kita selami rgb_foto_df lebih mendalam. Untuk itu, kita gambarkan diagram pencar untuk variabel-variabel warnanya, yaitu R, G, dan B. Perhatikan Gambar 5!\n\n\n\n\n\n\n\nGambar 5: Titik-titik dalam ruang yang merepresentasikan warna dalam foto"
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-klasterisasi-k-rerata",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-klasterisasi-k-rerata",
    "title": "Klasterisasi Warna Foto",
    "section": "Klasterisasi \\(K\\)-Rerata",
    "text": "Klasterisasi \\(K\\)-Rerata\nSelanjutnya, kita lakukan klasterisasi terhadap rgb_foto_df dengan menggunakan variabel-variabel R_norm, G_norm, dan B_norm. Untuk melakukannya, kita menggunakan fungsi kmeans(). Fungsi ini menggunakan input sebuah matriks. Oleh karena itu, terlebih dahulu kita membuat matriks tersebut. Matriks tersebut memuat tiga kolom, yaitu R_norm, G_norm, dan B_norm. Perhatikan Daftar 3!\n\n\n\nDaftar 3: Membuat matriks\n\nKodematriks_foto &lt;- rgb_foto_df |&gt; \n  select(R_norm, G_norm, B_norm) |&gt; \n  as.matrix()\n\n\n\n\n\nKita telah memperoleh matriks_foto. Kita siap untuk melakukan klasterisasi \\(k\\)-rerata dengan fungsi kmeans(). Perhatikan Daftar 4.\n\n\n\nDaftar 4: Klasterisasi k-rerata terhadap matriks_foto\n\nKodeset.seed(123)\n\n# Pilih nilai k\nk &lt;- 4\n\n# Lakukan klasterisasi k-rerata\nhasil_krerata &lt;- kmeans(\n  x = matriks_foto,\n  centers = k\n)\n\n\n\n\n\nHasil klasterisasi tersebut kita simpan sebagai sebuah objek dengan nama hasil_krerata. Terdapat informasi penting yang terkandung dalam hasil_krerata, yaitu cluster (klaster) dan centers (pusat setiap klaster). Kedua informasi tersebut berguna untuk mengidentifikasi klaster-klaster warnanya dan menyederhanakan warna-warnanya dengan pusat klasternya.\nSekarang, kita membuat rgb_foto_klaster_df yang memuat informasi klaster dan pusatnya tersebut dalam kolom-kolom klaster dan pusat_hex. Perhatikan Daftar 5. Untuk melihat beberapa baris awalnya, kita terapkan head() pada data tersebut.\n\n\n\nDaftar 5: Membuat data yang memuat informasi klaster dan warna pusat klaster\n\nKodergb_foto_klaster_df &lt;- rgb_foto_df |&gt; \n  mutate(\n    klaster = hasil_krerata$cluster,\n    pusat_R = hasil_krerata$centers[klaster, \"R_norm\"],\n    pusat_G = hasil_krerata$centers[klaster, \"G_norm\"],\n    pusat_B = hasil_krerata$centers[klaster, \"B_norm\"]\n  ) |&gt; \n  mutate(\n    pusat_hex = rgb(pusat_R, pusat_G, pusat_B)\n  ) |&gt; \n  select(koord_x, koord_y, R, G, B, warna_hex, klaster, pusat_hex)\n\nhead(rgb_foto_klaster_df)\n\n\n\n\n\n# A tibble: 6 × 8\n  koord_x koord_y     R     G     B warna_hex klaster pusat_hex\n    &lt;int&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;    \n1       1     256   117   171   233 #75ABE9         3 #84B4DE  \n2       2     256   117   173   234 #75ADEA         3 #84B4DE  \n3       3     256   116   172   233 #74ACE9         3 #84B4DE  \n4       4     256   116   172   233 #74ACE9         3 #84B4DE  \n5       5     256   115   170   234 #73AAEA         3 #84B4DE  \n6       6     256   120   171   234 #78ABEA         3 #84B4DE  \n\n\nDari data yang telah kita buat di atas, kita dapat memvisualisasikan warna-warna yang masuk ke dalam setiap klasternya. Perhatikan Gambar 6!\n\n\n\n\n\n\n\n\n\n(a) Klaster 1\n\n\n\n\n\n\n\n\n\n(b) Klaster 2\n\n\n\n\n\n\n\n\n\n\n\n(c) Klaster 3\n\n\n\n\n\n\n\n\n\n(d) Klaster 4\n\n\n\n\n\n\nGambar 6: Klaster dan warna-warna anggotanya"
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-menyederhanakan-warna",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-menyederhanakan-warna",
    "title": "Klasterisasi Warna Foto",
    "section": "Menyederhanakan Warna",
    "text": "Menyederhanakan Warna\nTiba saatnya kita menyederhanakan warna. Caranya adalah dengan mengganti setiap warna dengan pusat klasternya. Mari kita lihat kembali rgb_foto_klaster_df. Data ini hanya memuat \\(k=4\\) warna, seperti yang ditunjukkan pada luaran Daftar 6 berikut.\n\n\n\nDaftar 6: Melihat warna pusat klaster unik dan banyaknya\n\nKodergb_foto_klaster_df |&gt; \n  group_by(pusat_hex) |&gt; \n  summarise(\n    n = n()\n  )\n\n\n\n\n\n# A tibble: 4 × 2\n  pusat_hex     n\n  &lt;chr&gt;     &lt;int&gt;\n1 #47403B   27742\n2 #5E7481   12175\n3 #84B4DE   19353\n4 #D0B78E    6266\n\n\nKita dapat melihat kembali titik-titik warnanya ke dalam ruang dimensi tiga agar dapat mengamati hasil klasterisasi warnanya. Perhatikan Gambar 7!\n\n\n\n\n\n\n\nGambar 7: Titik-titik dalam ruang yang merepresentasikan warna dalam foto setelah klasterisasi\n\n\n\n\nSekarang, kita gambarkan kembali piksel-piksel dalam rgb_foto_klaster_df pada bidang koordinat Kartesius dengan kode pada Daftar 7. Hasilnya ditunjukkan pada Gambar 8.\n\n\n\nDaftar 7: Memplot piksel-piksel foto dengan pereduksian warna\n\nKodergb_foto_klaster_df |&gt; \n  ggplot(\n    aes(x = koord_x, y = koord_y, fill = pusat_hex)\n  ) +\n  geom_tile() +\n  scale_fill_identity() +\n  coord_equal() +\n  theme_minimal() + \n  theme(\n    axis.title = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nGambar 8: Penyederhanaan foto asli yang awalnya memiliki hampir 40 ribu warna menjadi \\(k=4\\).\n\n\n\n\nSampai di sini kita telah berhasil mereduksi variasi warna dari sebuah foto. Teknik yang telah kita lakukan tersebut tentu juga dapat diterapkan dengan \\(k\\) yang berbeda. Misalnya, kita juga dapat melakukannya dengan \\(k\\) = 16 dan 2. Hasilnya disajikan pada Gambar 9.\n\n\n\n\n\n\n\n\n\n(a) Foto asli\n\n\n\n\n\n\n\n\n\n(b) Klasterisasi dengan k = 16\n\n\n\n\n\n\n\n\n\n\n\n(c) Klasterisasi dengan k = 4\n\n\n\n\n\n\n\n\n\n(d) Klasterisasi dengan k = 2\n\n\n\n\n\n\nGambar 9: Perbandingan foto asli dan hasil reduksi warnanya dengan klasterisasi k-rerata\n\n\nMungkin kamu penasaran bagaimana komposisi warna dalam foto yang variasi warnanya sudah berkurang tersebut. Mari kita selidiki dan hasilnya disajikan pada Gambar 10.\n\n\n\n\n\n\n\n\n\n\n(a) Foto dengan k = 2\n\n\n\n\n\n\n\n\n\n(b) Foto dengan k = 4\n\n\n\n\n\n\n\n\n\n\n\n(c) Foto dengan k = 16\n\n\n\n\n\n\nGambar 10: Komposisi warna pada foto"
  },
  {
    "objectID": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-catatan-akhir",
    "href": "pos/2025-10-klasterisasi-warna-foto/index.html#sec-catatan-akhir",
    "title": "Klasterisasi Warna Foto",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah mereduksi variasi warna dalam sebuah foto dengan menggunakan klasterisasi \\(k\\)-rerata. Untuk melakukannya, kita perlu mengetahui bagaimana sebuah foto atau gambar dapat direpresentasikan dengan matriks-matriks warna dasarnya. Setelah itu, kita ekstrak data warna piksel-piksel dalam gambar tersebut. Hal ini kita lakukan pada Bagian 2. Setelah kita mendapatkan data warna tersebut, kita gunakan data tersebut untuk melakukan klasterisasi \\(k\\)-rerata (lihat Bagian 3). Di akhir, kita ubah warna tiap-tiap pikselnya dengan warna pusat klasternya. Dengan cara ini, kita mendapatkan gambar yang hanya tersusun dari \\(k\\) warna. Hasil akhirnya dapat dilihat pada Gambar 9.\nSebagai catatan, kita menggunakan klasterisasi \\(k\\)-rerata terhadap titik-titik warna yang dinyatakan ke dalam RGB. Algoritma \\(k\\)-rerata tersebut mengandalkan jarak untuk membuat klaster-klaster. Akan tetapi, persepsi kita terhadap warna tidaklah linear di RGB. Dalam RGB, dua warna mungkin memiliki jarak yang dekat, tetapi secara intuitif kita menilai warna tersebut jauh berbeda. Sebaliknya, mungkin ada dua warna yang jauh secara numerik dalam ruang RGB, tetapi bagi kita dua warna itu dekat secara intuitif. Oleh karena itu, kita dapat memilih format warna yang lebih sesuai dengan persepsi kita, misalnya Lab. Silakan gunakan metode yang kamu pelajari di artikel ini, tetapi dengan menggunakan ruang warna Lab."
  },
  {
    "objectID": "pos/2025-10-simulasi-monte-carlo/index.html",
    "href": "pos/2025-10-simulasi-monte-carlo/index.html",
    "title": "Simulasi Monte Carlo",
    "section": "",
    "text": "Bayangkan kamu bermain sebuah gim. Dalam gim tersebut, kamu memiliki selembar kertas bergaris dan lidi. Panjang lidi tersebut sama dengan jarak antargaris pada kertas itu. Jika lidi tersebut dilemparkan secara acak ke kertas tersebut, kamu perlu menebak apakah lidi tersebut mengenai garis atau tidak. Jika tebakanmu benar, kamu menang. Tebakan mana yang kamu pilih?\nGim itu adalah bentuk adaptasi dari sebuah masalah paling awal yang diajukan dan diselesaikan di Peluang Geometris, masalah jarum Buffon. Masalah ini menarik karena melibatkan peluang dan geometri. Dengan demikian, kita akan memvisualisasikan masalah ini secara geometris untuk dapat melihat berapa peluangnya. Untuk melakukannya, kita menggunakan simulasi Monte Carlo."
  },
  {
    "objectID": "pos/2025-10-simulasi-monte-carlo/index.html#sec-simulasi-monte-carlo",
    "href": "pos/2025-10-simulasi-monte-carlo/index.html#sec-simulasi-monte-carlo",
    "title": "Simulasi Monte Carlo",
    "section": "Simulasi Monte Carlo",
    "text": "Simulasi Monte Carlo\nSimulasi Monte Carlo, atau sering dikenal dengan metode Monte Carlo, merupakan sebuah teknik matematis yang digunakan untuk memperkirakan kemungkinan luaran dari kejadian yang tak pasti. Dengan demikian, kita dapat menggunakan simulasi ini terhadap masalah jarum Buffon. Tujuannya beberapa hal, yaitu untuk:\n\nmembandingkan banyaknya jarum yang memotong garis dan yang tidak dalam sebuah eksperimen;\nmenggunakan Hukum Bilangan Besar dan peluang empiris untuk memperkirakan peluang kejadian mendapatkan jarum yang memotong garis;\nmemperkirakan nilai pi (\\(\\pi\\)).\n\nSelanjutnya, mari kita melakukan tujuan-tujuan tersebut pada bagian berikutnya."
  },
  {
    "objectID": "pos/2025-10-simulasi-monte-carlo/index.html#sec-simulasi-masalah-jarum-buffon",
    "href": "pos/2025-10-simulasi-monte-carlo/index.html#sec-simulasi-masalah-jarum-buffon",
    "title": "Simulasi Monte Carlo",
    "section": "Simulasi Masalah Jarum Buffon",
    "text": "Simulasi Masalah Jarum Buffon\nKita menggunakan pemrograman R untuk mensimulasikan masalah jarum Buffon. Untuk melakukannya, kita memanfaatkan empat paket, yaitu {tidyverse}, {scales}, {gganimate}, dan {magick}. Mari terlebih dahulu kita memanggil keempat paket tersebut.\n\n\nKode\n1library(tidyverse)\n2library(scales)\n3library(gganimate)\n4library(magick)\n\n\n\n1\n\nKita menggunakan {tidyverse} untuk mempersiapkan data dalam mensimulasikan masalah jarum Buffon.\n\n2\n\nPaket {scales} kita pakai untuk mengatur skala diagram-diagram yang akan kita buat.\n\n3\n\nPaket {gganimate} kita gunakan untuk menganimasikan simulasi masalah jarum Buffon.\n\n4\n\nKita memanfaatkan {magick} untuk menggabungkan gambar-gambar animasi ke dalam sebuah gambar animasi yang tersinkron.\n\n\n\n\n\nDeskripsi Masalah\nMasalah jarum Buffon kurang lebih deskripsinya adalah sebagai berikut.\n\nPerhatikan selembar kertas bergaris-garis sejajar yang jarak antargaris berdekatannya \\(d\\) satuan dan sebuah jarum yang panjangnya \\(l\\), dengan \\(l = d\\). Jika kita melemparkan jarum tersebut pada kertas itu secara acak, berapakah peluang jarum tersebut memotong garis pada kertas itu?\n\nTanpa mengurangi generalisasi, kita dapat mengasumsikan bahwa garis-garis pada kertas itu adalah garis-garis yang horizontal dan jarak antargaris berdekatannya \\(d=1\\) satuan. Dengan demikian, panjang jarumnya \\(l = d = 1\\). Asumsi seperti ini akan memudahkan kita untuk mensimulasikan masalah tersebut.\nTerdapat dua elemen penting dalam memvisualisasikan masalah jarum Buffon tersebut, yaitu kertas bergaris dan jarumnya. Kedua elemen tersebut dapat kita visualisasikan dengan {ggplot2}, yang merupakan bagian dari {tidyverse}. Selanjutnya, kita bahas kedua elemen tersebut pada Bagian 2.2 dan Bagian 2.3.\n\n\nSelembar Kertas\nKita memilih kertas yang berukuran 10 × 10. Karena kertas ini bergaris-garis horizontal dan jarak antargaris berdekatannya 1 satuan, kita dapat memvisualisasikannya dengan menggunakan kode pada Daftar 1.\n\n\n\n\nDaftar 1: Kode untuk membuat kertas bergaris\n\n\n\nKode\nkertas &lt;- ggplot() + \n1  geom_hline(\n    yintercept = 0:10,\n    color = \"gray80\",\n    linewidth = .5\n  ) + \n2  coord_equal(\n    xlim = c(0, 10),\n    ylim = c(0, 10)\n  ) + \n3  scale_x_continuous(\n    breaks = 0:10\n  ) + \n4  scale_y_continuous(\n    breaks = 0:10\n  ) + \n5  theme_bw() +\n6  theme(\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(.5, .5, .5, .5), \"cm\")\n  )\n\n\n\n\n\n\n1\n\nMenggunakan geom_hline() untuk membuat garis-garis horizontal yang memotong sumbu-\\(y\\) di 0, 1, 2, …, 10 (yintercept = 0:10), berwarna abu-abu (color = \"gray80\"), dan tebalnya 0,5 (linewidth = .5).\n\n2\n\nMengatur agar skala-\\(x\\) dan \\(y\\) sama, serta jendela diagramnya menampilkan \\(0 \\leq x \\leq 10\\) dan \\(0\\leq y \\leq 10\\).\n\n3\n\nMengatur agar skala pada sumbu-\\(x\\) menampilkan 0, 1, 2, …, 10.\n\n4\n\nMengatur agar skala pada sumbu-\\(y\\) menampilkan 0, 1, 2, …, 10.\n\n5\n\nMemilih tema untuk diagram, yaitu yang kita pilih adalah theme_bw().\n\n6\n\nMengatur tema secara lebih lanjut: (1) tidak menampilkan judul pada semua sumbu (axis.title = element_blank()), tidak menampilkan kisi-kisi, baik horizontal maupun vertikal (panel.grid = element_blank()), dan mengatur pias atas, kanan, bawah, dan kiri (plot.margin = unit(c(.5, .5, .5, .5), \"cm\")).\n\n\n\n\nSelembar kertas yang telah kita buat ditunjukkan pada Gambar 1.\n\n\nKode\nkertas\n\n\n\n\n\n\n\n\nGambar 1: Kertas bergaris horizontal berukuran 10 × 10 yang jarak antargarisnya 1 satuan\n\n\n\n\n\n\n\nSebuah Jarum\nBagaimana kita dapat membuat jarumnya? Kita dapat memvisualisasikan jarum dalam masalah ini dengan menggunakan ruas garis yang ujung-ujungnya adalah titik-titik \\(\\left( x_{1}, y_{1} \\right)\\) dan \\(\\left( x_{2}, y_{2} \\right)\\), perhatikan Gambar 2.\n\n\n\n\n\n\nGambar 2: Sebuah jarum yang direpresentasikan dengan sebuah ruas garis\n\n\n\nKoordinat kedua ujung ruas garis tersebut saling berkaitan karena jarak keduanya haruslah \\(l=1\\) satuan. Jika \\(\\theta\\) adalah besar sebuah sudut yang dibentuk oleh sebuah sinar garis horizontal ke kanan yang pangkalnya \\(\\left(x_{1},y_{1}\\right)\\) dan ruas garis tersebut, koordinat \\(\\left( x_{2}, y_{2} \\right)\\) dapat ditentukan dengan menggunakan Persamaan 1.\n\\[\n\\begin{matrix}\nx_{2}=x_{1}+1\\cdot\\cos\\left(\\theta\\right)\\\\\ny_{2}=y_{1}+1\\cdot\\sin\\left(\\theta\\right)\n\\end{matrix}\n\\tag{1}\\]\ndengan \\(0 \\leq \\theta \\leq 2\\pi\\). Berdasarkan Persamaan 1, kita memerlukan tiga nilai, yaitu \\(x_{1}\\), \\(y_{1}\\), dan \\(\\theta\\), untuk membuat sebuah jarum pada kertas. Sebagai contoh, untuk \\(x_{1}=6\\), \\(y_{1}=\\text{5,5}\\), dan \\(\\theta=\\frac{4}{3}\\pi\\), jarumnya dapat dibuat dengan menggunakan kode pada Daftar 2.\n\n\n\n\nDaftar 2: Membuat sebuah jarum dengan \\(x_{1}=6\\), \\(y_{1}=\\text{5,5}\\), dan \\(\\theta=\\frac{4}{3}\\pi\\)\n\n\n\nKode\n1x_1 &lt;- 6\ny_1 &lt;- 5.5\nt_heta &lt;- 4 / 3 * pi\n\n2x_2 &lt;- x_1 + 1 * cos(t_heta)\ny_2 &lt;- y_1 + 1 * sin(t_heta)\n\ncontoh_jarum &lt;- ggplot() + \n  geom_hline(\n    yintercept = 0:10,\n    color = \"gray80\",\n    linewidth = .5\n  ) + \n3  annotate(\n    geom = \"segment\",\n    x = x_1, xend = x_2,\n    y = y_1, yend = y_2,\n    color = \"#4269d0\",\n    linewidth = 1.5\n  ) + \n  coord_equal(\n    xlim = c(0, 10),\n    ylim = c(0, 10)\n  ) + \n  scale_x_continuous(\n    breaks = 0:10\n  ) + \n  scale_y_continuous(\n    breaks = 0:10\n  ) + \n  theme_bw() + \n  theme(\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(.5, .5, .5, .5), \"cm\")\n  )\n\n\n\n\n\n\n1\n\nMendefinisikan nilai-nilai yang diketahui, yaitu x_1, y_1, dan t_heta.\n\n2\n\nMenghitung nilai-nilai x_2 dan y_2 berdasarkan Persamaan 1.\n\n3\n\nMenggunakan annotate() untuk membuat representasi sebuah jarum sebagai sebuah ruas garis (geom = \"segment\"), yang ujung-ujungnya di \\(\\left( x_{1}, y_{1} \\right)\\) dan \\(\\left( x_{2}, y_{2} \\right)\\) (x = x_1, xend = x_2, y = y_1, yend = y_2), berwarna biru (color = \"#4269d0\"), dan tebalnya 1,5 (linewidth = 1.5). Kita membuat ruas garis dengan annotate() karena ruas garis tersebut tidak tergantung dari data, tetapi kita sediakan nilai-nilai untuk x, y, xend, dan yend secara manual.\n\n\n\n\nJarum yang dihasilkan dari kode pada Daftar 2 ditunjukkan pada Gambar 3.\n\n\nKode\ncontoh_jarum\n\n\n\n\n\n\n\n\nGambar 3: Sebuah jarum dengan \\(x_{1}=6\\), \\(y_{1}=\\text{5,5}\\), dan \\(\\theta=\\frac{4}{3}\\pi\\)\n\n\n\n\n\nGambar 3 memperlihatkan secara jelas bahwa jarumnya memotong sebuah garis. Namun bagaimana kita dapat mengetahui apakah sembarang jarum yang diketahui \\(x_{1}\\), \\(y_{1}\\), dan \\(\\theta\\)-nya memotong garis atau tidak? Untuk menjawab pertanyaan ini, perhatikan Gambar 4.\n\n\n\n\n\n\nGambar 4: Jarum-jarum yang memotong garis dan yang tidak\n\n\n\nBerdasarkan Gambar 4, kita dapat melihat bahwa jarum yang memotong garis pada kertas nilai \\(h\\)-nya lebih besar dari jarak vertikal antara titik tengah jarum tersebut dan garis terdekatnya, yaitu \\(d_{h}\\). Padahal, \\(h=\\frac{1}{2}\\cdot\\sin\\left(\\theta_{l}\\right)\\) degan \\(\\theta_{l}\\) adalah sudut lancip yang dibentuk oleh jarum dan garis horizontal.\nPerhatikan juga bahwa garis-garis pada kertas yang kita buat pada Daftar 1 memiliki koordinat-\\(y\\) yang merupakan bilangan bulat. Dengan demikian, kita mendapatkan \\(d_{h}=\\text{min}\\left(\\left | y_{t}-\\left \\lfloor y_{t}\\right \\rfloor\\right |,\\left | y_{t}-\\left \\lceil y_{t}\\right \\rceil\\right |\\right)\\) dengan \\(y_{t}\\) adalah koordinat-\\(y\\) titik tengah jarum tersebut. Dengan demikian, sebuah jarum yang memotong garis memenuhi kondisi pada Persamaan 2.\n\\[\n\\frac{1}{2}\\sin\\left(\\theta_{l}\\right)\\geq \\text{min}\\left(\\left | y_{t}-\\left \\lfloor y_{t}\\right \\rfloor\\right |,\\left | y_{t}-\\left \\lceil y_{t}\\right \\rceil\\right |\\right)\n\\tag{2}\\]\nKita gunakan kondisi tersebut terhadap jarum pada Gambar 3 untuk menentukan apakah jarum tersebut memotong garis atau tidak (walaupun faktanya kita telah mengetahuinya).\n\n\n\n\nDaftar 3: Menguji kondisi apakah jarumnya memotong garis\n\n\n1y_t &lt;- (y_1 + (y_1 + sin(t_heta))) / 2\n2theta_l &lt;- abs(t_heta %% pi - pi/2)\n3h &lt;- 1 / 2 * sin(theta_l)\n4d_h &lt;- min(\n  abs(y_t - floor(y_t)),\n  abs(y_t - ceiling(y_t))\n)\n\n5potong_garis &lt;- if_else(\n  h &gt;= d_h, \"Memotong\", \"Tak memotong\"\n)\n\n6potong_garis\n\n\n\n\n\n1\n\nMenghitung koordinat-\\(y\\) titik tengah jarum, dan nilainya dinamai dengan y_t.\n\n2\n\nMenentukan sudut lancip \\(\\theta_{l}\\) dan hasilnya kita namai dengan theta_l.\n\n3\n\nMenghitung nilai \\(h\\).\n\n4\n\nMenghitung nilai \\(d_{h}\\) dan hasilnya dinamai dengan d_h.\n\n5\n\nMendefinisikan kondisi yang telah dibahas sebelumnya, dan hasilnya dinamai dengan potong_garis.\n\n6\n\nMencetak nilai potong_garis.\n\n\n\n\n[1] \"Memotong\"\n\n\nKita telah berhasil menggunakan kondisi di atas untuk menentukan apakah jarum pada Gambar 3 memotong garis atau tidak. Hasilnya sesuai dengan pengamatan kita tentu saja.\n\n\nEksperimen Jarum Buffon\nSampai di sini kita telah dapat membuat selembar kertas dan sebuah jarum. Kita juga telah mengetahui kondisi jarum tersebut untuk memotong garis pada kertas. Sekarang kita akan memvisualisasikan sebuah eksperimen pelemparan jarum sebanyak \\(n\\) kali, atau selanjutnya kita sebut sebagai eksperimen jarum Buffon. Misalnya, kita memilih \\(n = 100\\) kali. Setiap pelemparan tersebut kita perlu menyediakan tiga nilai, yaitu \\(x_{1}\\), \\(y_{1}\\), dan \\(\\theta\\), secara acak. Dalam R, kita dapat menggunakan fungsi runif(). Fungsi ini akan memberikan satu atau lebih nilai acak dari distribusi seragam dengan nilai minimum dan maksimum yang diberikan.\nKita buat sebuah data dengan nama data_eksperimen untuk memuat hasil eksperimen jarum Buffon sebanyak \\(n=100\\) percobaan. Untuk melakukannya, kita gunakan kode pada Daftar 4.\n\n\n\n\nDaftar 4: Membuat data_eksperimen yang memuat luaran setiap percobaan dalam eksperimen\n\n\n1set.seed(1234)\n2palet_warna &lt;- c(\n  \"#4269d0\",\"#efb118\",\n  \"#ff725c\",\"#6cc5b0\",\n  \"#3ca951\",\"#ff8ab7\",\n  \"#a463f2\",\"#97bbf5\",\n  \"#9c6b4e\",\"#9498a0\"\n)\n\ndata_eksperimen &lt;- tibble(\n3  x1 = runif(100, min = 1, max = 9),\n  y1 = runif(100, min = 1, max = 9),\n  theta = runif(100, min = 0, max = 2 * pi)\n) |&gt; \n4  mutate(\n    percobaan = row_number(),\n    x2 = x1 + 1 * cos(theta),\n    y2 = y1 + 1 * sin(theta),\n    warna = palet_warna[(percobaan %% 10) + 1]\n  )\n\n\n\n\n\n1\n\nMengatur benih pengacakan agar hasilnya dapat diproduksi kembali.\n\n2\n\nMembuat palet warna sebagai warna setiap jarumnya.\n\n3\n\nMenyediakan bilangan-bilangan x1, y1, dan theta secara acak.\n\n4\n\nMenghitung x2 dan y2, serta membuat variabel percobaan untuk memberikan identitas terhadap setiap percobaannya dan warna untuk memberikan warna terhadap setiap jarum yang dihasilkan.\n\n\n\n\nKita dapat melihat gambaran umum data_eksperimen dengan fungsi glimpse().\n\n\nKode\nglimpse(data_eksperimen)\n\n\nRows: 100\nColumns: 7\n$ x1        &lt;dbl&gt; 1.909627, 5.978395, 5.874198, 5.987036, 7.887323, 6.122485, …\n$ y1        &lt;dbl&gt; 1.283654, 5.520609, 3.242062, 2.633571, 2.069911, 3.605455, …\n$ theta     &lt;dbl&gt; 4.1516438, 3.3197799, 1.9948725, 4.8245782, 3.3068938, 4.601…\n$ percobaan &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ x2        &lt;dbl&gt; 1.3778099, 4.9942286, 5.4627189, 6.0989896, 6.9009542, 6.011…\n$ y2        &lt;dbl&gt; 0.4367948, 5.3433631, 4.1534815, 1.6398571, 1.9053618, 2.611…\n$ warna     &lt;chr&gt; \"#efb118\", \"#ff725c\", \"#6cc5b0\", \"#3ca951\", \"#ff8ab7\", \"#a46…\n\n\nKita telah memiliki data_eksperimen yang memiliki tujuh variabel dan 100 baris. Baris-baris tersebut menggambarkan hasil percobaannya.\nSelanjutnya, kita akan menentukan apakah setiap percobaan dalam data_eksperimen menghasilkan jarum yang memotong garis atau tidak. Untuk melakukannya, kita menerapkan ide pada Daftar 3 untuk membuat variabel baru, yaitu potong, dalam data tersebut. Perhatikan Daftar 5!\n\n\n\n\nDaftar 5: Menambahkan informasi apakah jarumnya memotong garis atau tidak\n\n\ndata_eksperimen &lt;- data_eksperimen |&gt; \n1  mutate(\n    yt = (y1 + y2) / 2,\n    theta_l = abs(theta %% pi - pi/2),\n    h = 1 / 2 * sin(theta_l),\n    d_h = pmin(\n      abs(yt - floor(yt)),\n      abs(yt - ceiling(yt))\n    ),\n2    potong = if_else(\n      h &gt;= d_h,\n      \"Memotong\",\n      \"Tak memotong\"\n    )\n  )\n\n\n\n\n\n1\n\nMenggunakan ide pada Daftar 3 dengan menambahkan variabel-variabel yt, theta_l, h, d_h dan potong ke dalam data_eksperimen.\n\n2\n\nVariabel potong akan bernilai “Memotong” jika h &gt;= d_h. Jika sebaliknya, variabel ini akan bernilai “Tak memotong”.\n\n\n\n\nKita cek apakah data_eksperimen saat ini telah memuat informasi jarumnya memotong garis atau tidak.\n\n\nKode\nglimpse(data_eksperimen)\n\n\nRows: 100\nColumns: 12\n$ x1        &lt;dbl&gt; 1.909627, 5.978395, 5.874198, 5.987036, 7.887323, 6.122485, …\n$ y1        &lt;dbl&gt; 1.283654, 5.520609, 3.242062, 2.633571, 2.069911, 3.605455, …\n$ theta     &lt;dbl&gt; 4.1516438, 3.3197799, 1.9948725, 4.8245782, 3.3068938, 4.601…\n$ percobaan &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 1…\n$ x2        &lt;dbl&gt; 1.3778099, 4.9942286, 5.4627189, 6.0989896, 6.9009542, 6.011…\n$ y2        &lt;dbl&gt; 0.4367948, 5.3433631, 4.1534815, 1.6398571, 1.9053618, 2.611…\n$ warna     &lt;chr&gt; \"#efb118\", \"#ff725c\", \"#6cc5b0\", \"#3ca951\", \"#ff8ab7\", \"#a46…\n$ yt        &lt;dbl&gt; 0.8602243, 5.4319860, 3.6977718, 2.1367138, 1.9876365, 3.108…\n$ theta_l   &lt;dbl&gt; 0.56074517, 1.39260910, 0.42407619, 0.11218922, 1.40549519, …\n$ h         &lt;dbl&gt; 0.26590870, 0.49208331, 0.20573949, 0.05597701, 0.49318442, …\n$ d_h       &lt;dbl&gt; 0.13977571, 0.43198600, 0.30222817, 0.13671384, 0.01236349, …\n$ potong    &lt;chr&gt; \"Memotong\", \"Memotong\", \"Tak memotong\", \"Tak memotong\", \"Mem…\n\n\nData yang kita miliki telah memuat informasi yang kita perlukan. Kita dapat melakukan analisis sederhana terhadap data_eksperimen tersebut. Misalnya, kita dapat melihat berapa jarum yang memotong garis dan yang tidak dengan kode pada Daftar 6.\n\n\n\n\nDaftar 6: Menghitung banyak jarum yang memotong garis dan yang tidak\n\n\n\nKode\ndata_eksperimen |&gt; \n  group_by(potong) |&gt; \n  summarise(\n    frekuensi = n()\n  )\n\n\n\n\n\n# A tibble: 2 × 2\n  potong       frekuensi\n  &lt;chr&gt;            &lt;int&gt;\n1 Memotong            60\n2 Tak memotong        40\n\n\n\n\nVisualisasi Hasil Eksperimen\nKita dapat memvisualisasikan hasil 100 percobaan dalam data_eksperimen. Dengan menggunakan x1, y1, x2, dan y2, kita dapat menggambarkan jarum yang dihasilkan oleh setiap percobaan. Kita dapat melakukannya dengan kode pada Daftar 7.\n\n\n\n\nDaftar 7: Memvisualisasikan setiap luaran dalam eksperimen\n\n\n\nKode\nhasil_eksperimen &lt;- data_eksperimen |&gt; \n  ggplot() + \n  geom_hline(\n    yintercept = 0:10,\n    color = \"gray80\",\n    linewidth = 0.5\n  ) + \n1  geom_segment(\n    aes(\n      x = x1, y = y1,\n      xend = x2, yend = y2,\n      color = warna\n    ),\n    linewidth = 1.5\n  ) + \n  coord_equal(\n    xlim = c(0, 10),\n    ylim = c(0, 10)\n  ) + \n  scale_x_continuous(\n    breaks = 0:10\n  ) + \n  scale_y_continuous(\n    breaks = 0:10\n  ) + \n2  scale_color_identity() +\n  theme_bw() + \n  theme(\n    legend.position = \"none\",\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(.5, .5, .5, .5), \"cm\")\n  )\n\n\n\n\n\n\n1\n\nBerbeda dengan yang kita lakukan pada Daftar 2, kita sekarang menggunakan geom_segment() untuk membuat ruas-ruas garis. Hal ini dikarenakan kita membuat ruas-ruas garis tersebut berdasarkan setiap baris dalam data_eksperimen.\n\n2\n\nKita menggunakan scale_color_identity() karena kita ingin agar pemetaan kita pada geom_segment() tentang warna, yaitu color = warna, bernilai persis sama dengan nilai variabel warna-nya (tanpa melalui penskalaan).\n\n\n\n\nVisualisasi luaran 100 percobaan eksperimen jarum Buffon yang dihasilkan dari Daftar 7, ditunjukkan pada Gambar 5.\n\n\nKode\nhasil_eksperimen\n\n\n\n\n\n\n\n\nGambar 5: Hasil pelemparan secara acak 100 jarum pada selembar kertas\n\n\n\n\n\nSebelumnya kita telah mengetahui berapa banyak jarum yang memotong garis dan yang tidak. Kita juga dapat mengetahui persentasenya juga. Kedua informasi ini dapat kita visualisasikan, seperti yang disajikan pada Gambar 6!\n\nKode\ndata_eksperimen |&gt; \n  ggplot(aes(x = potong, fill = potong)) + \n  geom_bar() + \n  scale_fill_manual(\n    values = c(\n      \"Memotong\" = \"#4269d0\",\n      \"Tak memotong\" = \"#ff725c\"\n    )\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"none\",\n    axis.title.x = element_blank()\n  ) + \n  labs(\n    y = \"Frekuensi\"\n  )\n\ndata_eksperimen |&gt; \n  mutate(\n    potong = factor(potong, levels = c(\"Tak memotong\", \"Memotong\"))\n  ) |&gt; \n  ggplot(aes(x = 1, fill = potong)) + \n  geom_bar(position = \"fill\") + \n  scale_y_continuous(\n    labels = percent_format(),\n    breaks = seq(from = 0, to = 1, by = .1)\n  ) + \n  scale_fill_manual(\n    values = c(\n      \"Tak memotong\" = \"#ff725c\",\n      \"Memotong\" = \"#4269d0\"\n    ),\n    name = \"Hasil percobaan\",\n    breaks = c(\"Memotong\", \"Tak memotong\")\n  ) + \n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\",\n    axis.title.x = element_blank(),\n    axis.text.x = element_blank()\n  ) + \n  labs(\n    y = \"Frekuensi relatif\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Frekuensi hasil setiap percobaan: Memotong dan Tak memotong\n\n\n\n\n\n\n\n\n\n\n\n(b) Frekuensi relatif hasil setiap percobaan\n\n\n\n\n\n\n\nGambar 6: Hasil eksperimen jarum Buffon\n\n\n\nBerdasarkan Gambar 6 (b), kita dapat mengetahui bahwa peluang empiris jarumnya memotong garis adalah 60% atau 0,6. Bagaimana dengan peluang empirisnya pada percobaan pertama, kedua, ketiga, dan seterusnya sampai ke-100? Untuk itu, kita hitung terlebih dahulu peluang empirisnya untuk setiap percobaannya dengan menggunakan kode pada Daftar 8.\n\n\n\n\nDaftar 8: Menghitung peluang empiris untuk setiap percobaan\n\n\ndata_eksperimen &lt;- data_eksperimen |&gt; \n1  mutate(\n    potong_numerik = if_else(\n      potong == \"Memotong\", 1, 0\n    ),\n2    peluang_empiris = cumsum(potong_numerik) / percobaan\n  )\n\nglimpse(data_eksperimen)\n\n\n\n\n\n1\n\nKita tambahkan variabel potong_numerik yang nilainya 1 jika variabel potong bernilai “Memotong”, dan nilainya 0 jika potong bernilai “Tak memotong”.\n\n2\n\nKita hitung peluang empiris memperoleh jarum yang memotong garis.\n\n\n\n\nRows: 100\nColumns: 14\n$ x1              &lt;dbl&gt; 1.909627, 5.978395, 5.874198, 5.987036, 7.887323, 6.12…\n$ y1              &lt;dbl&gt; 1.283654, 5.520609, 3.242062, 2.633571, 2.069911, 3.60…\n$ theta           &lt;dbl&gt; 4.1516438, 3.3197799, 1.9948725, 4.8245782, 3.3068938,…\n$ percobaan       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ x2              &lt;dbl&gt; 1.3778099, 4.9942286, 5.4627189, 6.0989896, 6.9009542,…\n$ y2              &lt;dbl&gt; 0.4367948, 5.3433631, 4.1534815, 1.6398571, 1.9053618,…\n$ warna           &lt;chr&gt; \"#efb118\", \"#ff725c\", \"#6cc5b0\", \"#3ca951\", \"#ff8ab7\",…\n$ yt              &lt;dbl&gt; 0.8602243, 5.4319860, 3.6977718, 2.1367138, 1.9876365,…\n$ theta_l         &lt;dbl&gt; 0.56074517, 1.39260910, 0.42407619, 0.11218922, 1.4054…\n$ h               &lt;dbl&gt; 0.26590870, 0.49208331, 0.20573949, 0.05597701, 0.4931…\n$ d_h             &lt;dbl&gt; 0.13977571, 0.43198600, 0.30222817, 0.13671384, 0.0123…\n$ potong          &lt;chr&gt; \"Memotong\", \"Memotong\", \"Tak memotong\", \"Tak memotong\"…\n$ potong_numerik  &lt;dbl&gt; 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, …\n$ peluang_empiris &lt;dbl&gt; 1.0000000, 1.0000000, 0.6666667, 0.5000000, 0.6000000,…\n\n\nSekarang, kita dapat memvisualisaikan perubahan peluang empirisnya dari satu percobaan ke percobaan lainnya. Visualisasi semacam ini akan lebih membantu jika kita juga menambahkan peluang teoretisnya. Peluang teoretis tersebut adalah \\(\\frac{2}{\\pi}\\). Nanti kamu dapat melihat pembahasan tentang peluang teoretis ini pada Catatan 1. Kita gunakan informasi tersebut untuk membuat kode visualisasinya, seperti yang ditunjukkan pada Daftar 9.\n\n\n\n\nDaftar 9: Membuat visualisasi tren peluang empiris\n\n\n\nKode\ntren_p_empiris &lt;- data_eksperimen |&gt; \n  ggplot(\n1    aes(x = percobaan, y = peluang_empiris)\n  ) + \n2  geom_hline(\n    yintercept = 2 / pi,\n    linetype = \"dashed\",\n    color = \"gray50\"\n  ) + \n3  geom_line(\n    color = \"gray80\",\n    linewidth = 1\n  ) + \n4  geom_point(\n    aes(color = warna)\n  ) + \n5  coord_cartesian(\n    ylim = c(0, 1)\n  ) + \n  scale_color_identity() + \n  theme_minimal() + \n  labs(\n    x = \"Percobaan\",\n    y = \"Peluang empiris\"\n  )\n\n\n\n\n\n\n1\n\nKita atur pemetaan variabel-variabel dalam data ke grafik yang akan kita buat, yaitu x = percobaan, y = peluang_empiris.\n\n2\n\nKita gunakan geom_hline() untuk membuat garis horizontal yang merepresentasikan peluang teoretisnya, yaitu yintercept = 2 / pi.\n\n3\n\nKita gunakan geom_line() untuk membuat diagram garis yang berwarna color = \"gray80\" dan tebalnya linewidth = 1.\n\n4\n\nKita gunakan geom_point() untuk membuat titik-titik yang merepresentasikan peluang empiris setiap percobaannya. Titik-titik ini kita atur agar warnanya color = warna agar sesuai dengan warna jarum-jarumnya.\n\n5\n\nKita atur agar sumbu-\\(y\\)-nya menampilkan skala semua kemungkinan peluang empirisnya, yaitu mulai dari 0 sampai 1, dengan menginputkan argumen `ylim = c(0, 1) terhadap coord_cartesian().\n\n\n\n\nUntuk melihat hasil Daftar 9, silakan perhatikan Gambar 7!\n\n\nKode\ntren_p_empiris\n\n\n\n\n\n\n\n\nGambar 7: Tren peluang empiris\n\n\n\n\n\nKita juga dapat memvisualisasikan apakah setiap percobaan dalam eksperimen tersebut menghasilkan jarum yang memotong garis atau tidak dengan menggunakan Persamaan 2. Caranya, kita merepresentasikan setiap percobaan dalam eksperimen tersebut dengan titik \\(\\left(\\theta_{l},d_{h}\\right)\\). Jika titik tersebut di bawah kurva \\(y=\\frac{1}{2}\\sin\\left(x\\right)\\), percobaannya menghasilkan jarum yang memotong garis. Kita gunakan ide seperti ini untuk membuat kode visualisasi pada Daftar 10.\n\n\n\n\nDaftar 10: Memvisualisasikan hasil setiap percobaan dalam eksperimen\n\n\n\nKode\n1data_kurva_sin &lt;- tibble(\n  x = seq(0, pi / 2, length.out = 400)\n) |&gt; \n  mutate(y = 0.5 * sin(x))\n\nhasil_percobaan &lt;- data_eksperimen |&gt; \n  ggplot(\n2    aes(x = theta_l, y = d_h)\n  ) +\n3  geom_line(\n    data = data_kurva_sin,\n    aes(x = x, y = y),\n    color = \"#efb118\",\n    linewidth = 1,\n    inherit.aes = FALSE\n  ) + \n4  geom_point(\n    aes(color = potong),\n    size = 3\n  ) +\n5  scale_color_manual(\n    values = c(\n      \"Memotong\" = \"#4269d0\",\n      \"Tak memotong\" = \"#ff725c\"\n    ),\n    name = \"Hasil percobaan\"\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\"\n  ) + \n  labs(\n    x = expression(theta[l]),\n    y = expression(d[h])\n  )\n\n\n\n\n\n\n1\n\nKita siapkan data_kurva_sin untuk selanjutnya digunakan untuk membuat kurva \\(y=\\frac{1}{2} \\sin \\left( x \\right)\\).\n\n2\n\nKita atur pemetaan data dan diagramnya, yaitu x = theta_l, y = d_h.\n\n3\n\nKita menggunakan geom_line() untuk membuat kurva sinus dengan menggunakan data_kurva_sin.\n\n4\n\nKita merepresentasikan setiap percobaannya dengan titik dan menggunakan pemetaan yang kita definisikan pada nomor 2.\n\n5\n\nKita mengatur warna titik-titik yang merepresentasikan jarum yang “Memotong” dan “Tak memotong”.\n\n\n\n\nDari kode pada Daftar 10, kita mendapatkan visualisasi yang disajikan pada Gambar 8.\n\n\nKode\nhasil_percobaan\n\n\n\n\n\n\n\n\nGambar 8: Hasil setiap percobaan dalam eksperimen\n\n\n\n\n\n\n\n\n\n\n\nCatatan 1: Peluang Teoretis\n\n\n\nGambar 8 sangat intuitif untuk menentukan peluang teoretis kejadian mendapatkan jarum yang memotong garis pada kertas. Tentu untuk kasus kita di sini adalah \\(l=1=d\\) karena gambar tersebut diperoleh dari asumsi tersebut.\nPerhatikan lagi Gambar 8. Apa yang terjadi jika eksperimen yang kita lakukan memuat tak hingga percobaan? Di bawah kurva \\(y=\\frac{1}{2}\\sin\\left(x\\right)\\) akan penuh dengan titik-titik biru, yang merepresentasikan kejadian mendapatkan jarum yang memotong garis. Secara lebih spesifik, sebanyak tak hingga titik biru tersebut akan mengisi daerah di bawah \\(y=\\frac{1}{2}\\sin\\left(x\\right)\\) dan di atas \\(y=0\\), serta di kanan \\(x=0\\) dan di kiri \\(x=\\frac{\\pi}{2}\\).\nPadahal, semua kemungkinan posisi titik-titik dalam eksperimen tersebut adalah daerah di dalam persegi panjang yang dibatasi oleh \\(y=\\frac{1}{2}\\), \\(y = 0\\), \\(x=0\\), dan \\(x=\\frac{\\pi}{2}\\). Dengan demikian, peluang teoretis mendapatkan kejadian jarum yang melewati garis sama dengan membagi luas daerah yang mungkin ditempati oleh titik-titik biru dengan luas daerah persegi panjang tersebut. Secara matematis, hal ini dapat dihitung seperti berikut.\n\\[\n\\begin{aligned}P &= \\frac{\\displaystyle \\int_{0}^{\\frac{\\pi}{2}} \\frac{1}{2} \\sin(x)\\,dx}{\\displaystyle \\frac{\\pi}{2} \\cdot \\frac{1}{2}} \\\\[6pt]  &= \\frac{2}{\\pi} \\left[ -\\cos(x) \\right]_{0}^{\\frac{\\pi}{2}} \\\\[6pt]  &= \\frac{2}{\\pi} \\bigl( -\\cos(\\tfrac{\\pi}{2}) + \\cos(0) \\bigr) \\\\[6pt]  &= \\frac{2}{\\pi}\\end{aligned}\n\\]\nDari perhitungan tersebut kita menemukan bahwa peluang teoretisnya adalah \\(\\frac{2}{\\pi}\\). Untuk kasus-kasus lainnya, yaitu untuk sembarang \\(l\\) dan \\(d\\), kamu dapat mencari ide dari laman Wikipedia atau Wolfram Mathworld, misalnya."
  },
  {
    "objectID": "pos/2025-10-simulasi-monte-carlo/index.html#sec-membuat-simulasi-menjadi-lebih-hidup",
    "href": "pos/2025-10-simulasi-monte-carlo/index.html#sec-membuat-simulasi-menjadi-lebih-hidup",
    "title": "Simulasi Monte Carlo",
    "section": "Membuat Simulasi Menjadi Lebih Hidup",
    "text": "Membuat Simulasi Menjadi Lebih Hidup\nPada Bagian 2 kita telah memahami masalah jarum Buffon dengan simulasi Monte Carlo dan memvisualisasikan hasil eksperimennya. Kita dapat menjadikan simulasi masalah tersebut menjadi lebih hidup dengan menggunakan animasi. Teknik penggunaan animasi ini juga telah kita bahas pada pos sebelumnya. Selain itu, kita juga akan menambah banyak percobaannya menjadi \\(n=1000\\) kali.\nPertama yang kita lakukan adalah mempersiapkan datanya. Untuk melakukannya, kita menggunakan alur kerja yang serupa dengan yang telah kita lakukan dari Daftar 4, Daftar 5, sampai Daftar 8. Kita rangkum alur kerja tersebut untuk membuat fungsi eksperimen_buffon() pada Daftar 11.\n\n\n\n\nDaftar 11: Membuat data eksperimen pelemparan jarum secara acak\n\n\n\nKode\neksperimen_buffon &lt;- function(n = 100) {\n  set.seed(1234)\n  palet_warna &lt;- c(\n  \"#4269d0\",\"#efb118\",\n  \"#ff725c\",\"#6cc5b0\",\n  \"#3ca951\",\"#ff8ab7\",\n  \"#a463f2\",\"#97bbf5\",\n  \"#9c6b4e\",\"#9498a0\"\n)   \n  tibble(\n    x1 = runif(n, 1, 9),\n    y1 = runif(n, 1, 9),\n    theta = runif(n, 0, 2 * pi),\n    percobaan = 1:n\n  ) |&gt; \n    mutate(\n      x2 = x1 + 1 * cos(theta),\n      y2 = y1 + 1 * sin(theta),\n      warna = palet_warna[(percobaan %% length(palet_warna)) + 1],\n      yt = (y1 + y2) / 2,\n      theta_l = abs(theta %% pi - pi/2),\n      h = 1 / 2 * sin(theta_l),\n      d_h = pmin(\n        abs(yt - floor(yt)),\n        abs(yt - ceiling(yt))\n      ),\n      potong = if_else(\n        h &gt;= d_h, \"Memotong\", \"Tak memotong\"\n      ),\n      potong_numerik = if_else(\n      potong == \"Memotong\", 1, 0\n    ),\n    peluang_empiris = cumsum(potong_numerik) / percobaan\n    )\n}\n\n\n\n\n\nFungsi eksperimen_buffon() dapat kita gunakan untuk membuat data hasil eksperimen masalah jarum Buffon dengan input n, yaitu banyaknya percobaan dalam eksperimen tersebut. Dengan demikian, jika kita ingin membuat data_eksperimen yang memuat \\(n=1000\\) percobaan, kita manfaatkan fungsi tersebut seperti pada Daftar 12.\n\n\n\n\nDaftar 12: Membuat data_eksperimen dengan 1000 percobaan\n\n\n\nKode\ndata_eksperimen &lt;- eksperimen_buffon(1000)\n\n\n\n\n\nUntuk melihat secara sekilas hasil eksperimen yang dimuat dalam data_eksperimen tersebut, kita dapat menggunakan glimpse().\n\n\nKode\nglimpse(data_eksperimen)\n\n\nRows: 1,000\nColumns: 14\n$ x1              &lt;dbl&gt; 1.909627, 5.978395, 5.874198, 5.987036, 7.887323, 6.12…\n$ y1              &lt;dbl&gt; 7.701071, 4.899730, 1.882696, 3.810904, 7.088504, 4.11…\n$ theta           &lt;dbl&gt; 0.7165175, 1.2076797, 3.8859660, 3.7640007, 0.3888313,…\n$ percobaan       &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,…\n$ x2              &lt;dbl&gt; 2.6637247, 6.3335846, 5.1386852, 5.1745586, 8.8126758,…\n$ y2              &lt;dbl&gt; 8.3578339, 5.8345244, 1.2051850, 3.2279108, 7.4676115,…\n$ warna           &lt;chr&gt; \"#efb118\", \"#ff725c\", \"#6cc5b0\", \"#3ca951\", \"#ff8ab7\",…\n$ yt              &lt;dbl&gt; 8.029453, 5.367127, 1.543940, 3.519407, 7.278058, 3.64…\n$ theta_l         &lt;dbl&gt; 0.854278785, 0.363116599, 0.826423019, 0.948388257, 1.…\n$ h               &lt;dbl&gt; 0.3770487226, 0.1775946664, 0.3677563190, 0.4062384624…\n$ d_h             &lt;dbl&gt; 0.02945260, 0.36712720, 0.45605951, 0.48059253, 0.2780…\n$ potong          &lt;chr&gt; \"Memotong\", \"Tak memotong\", \"Tak memotong\", \"Tak memot…\n$ potong_numerik  &lt;dbl&gt; 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, …\n$ peluang_empiris &lt;dbl&gt; 1.0000000, 0.5000000, 0.3333333, 0.2500000, 0.4000000,…\n\n\nBerdasarkan luaran di atas, kita dapat melihat bahwa data_eksperimen tersebut memiliki 14 variabel, mulai dari x1, y1, theta, sampai peluang_empiris. Data tersebut juga memuat 1000 baris yang setiap barisnya merupakan hasil percobaan dalam eksperimen. Dengan demikian, kita mendapatkan data_eksperimen yang kita kehendaki.\n\nAnimasi Eksperimen Jarum Buffon\nData eksperimen 1000 percobaan telah siap. Berikutnya, kita akan membuat visualisasi seperti pada Gambar 5, tetapi dengan menggunakan animasi. Dalam animasi tersebut, kita buat agar jarumnya tampak jatuh ke kertas secara bergiliran. Kita lakukan hal ini dengan kode pada Daftar 13.\n\n\n\n\nDaftar 13: Menganimasikan jarum yang jatuh ke kertas\n\n\n\nKode\nplot_anim_jarum &lt;- data_eksperimen |&gt; \n  ggplot() + \n  geom_hline(\n    yintercept = 0:10,\n    color = \"gray80\",\n    linewidth = 0.5\n  ) + \n  geom_segment(\n    aes(\n      x = x1, y = y1,\n      xend = x2, yend = y2,\n      group = percobaan,\n      color = warna\n    ),\n    linewidth = 1.5\n  ) + \n  coord_equal(\n    xlim = c(0, 10),\n    ylim = c(0, 10)\n  ) + \n  scale_x_continuous(\n    breaks = 0:10\n  ) + \n  scale_y_continuous(\n    breaks = 0:10\n  ) + \n  scale_color_identity() + \n  theme_bw() + \n  theme(\n    legend.position = \"none\",\n    axis.title = element_blank(),\n    panel.grid = element_blank(),\n    plot.margin = unit(c(.5, .5, .5, .5), \"cm\")\n  ) + \n  transition_reveal(along = percobaan)\n\n\n\n\n\nSekarang kita telah memiliki objek plot_anim_jarum. Objek tersebut merupakan objek gganim yang menyajikan animasi eksperimen pelemparan jarum ke kertas. Apabila kita perhatikan kode pada Daftar 13 hampir sama persis dengan kode pada Daftar 7 untuk membuat Gambar 5. Perbedaannya hanya pada penambahan group = percobaan pada pemetaan variabel dalam geom_segment() dan transition_reveal().\nFungsi transition_reveal() merupakan fungsi dari {gganimate} yang digunakan untuk membuat animasi yang menampilkan data secara bertahap berdasarkan urutan sebuah variabel. Agar animasinya memunculkan hasil percobaan 1; 1 dan 2; 1, 2, dan 3; dan seterusnya, kita perlu menambahkan argumen along = percobaan untuk membuat animasi tersebut dimunculkan berdasarkan nilai variabel percobaan.\nSelain itu, kita juga perlu menambahkan group = percobaan untuk memberitahu ggplot() agar setiap data jarum dalam satu percobaan adalah satu kelompok data sendiri. Hal ini untuk mencegah ggplot() agar tidak menyambungkan satu jarum dari suatu percobaan dengan jarum dari percobaan lainnya.\nIngin tahu bagaimana animasinya? Untuk mengetahuinya, kita cetak objek plot_anim_jarum. Hasilnya disajikan pada Gambar 9.\n\n\nKode\nplot_anim_jarum\n\n\n\n\n\n\n\n\nGambar 9: Animasi yang mengilustrasikan eksperimen masalah jarum Buffon yang memuat 1000 percobaan\n\n\n\n\n\nVoilà! Kita telah berhasil menganimasikan eksperimen 1000 percobaan jarum Buffon.\n\n\nAnimasi Peluang Empiris\nKita dapat menganimasikan bagaimana perubahan peluang empiris eksperimen jarum Buffon, dari satu percobaan ke percobaan lainnya. Dengan kata lain, kita akan menganimasikan Gambar 7.\nUntuk melakukannya, kita tambahkan transition_reveal(along = percobaan) terhadap kode yang membuat Gambar 7, yaitu Daftar 9. Dengan demikian, kode untuk membuat animasi tersebut ditunjukkan pada Daftar 14.\n\n\n\n\nDaftar 14: Membuat animasi tren peluang empiris\n\n\n\nKode\nplot_anim_p_empiris &lt;- data_eksperimen |&gt; \n  ggplot(aes(x = percobaan, y = peluang_empiris)) + \n  geom_hline(\n    yintercept = 2 / pi,\n    linetype = \"dashed\",\n    color = \"gray50\"\n  ) + \n  geom_line(\n    color = \"gray80\",\n    linewidth = 1\n  ) + \n  geom_point(\n    aes(color = warna, group = percobaan)\n  ) + \n  coord_cartesian(\n    ylim = c(0, 1)\n  ) + \n  scale_color_identity() + \n  theme_minimal() + \n  labs(\n    x = \"Percobaan\",\n    y = \"Peluang empiris\"\n  ) + \n  transition_reveal(\n    along = percobaan\n  )\n\n\n\n\n\nKita telah membuat objek gganim plot_anim_p_empiris. Bagaimana animasi yang terbentuk? Perhatikan Gambar 10!\n\n\nKode\nplot_anim_p_empiris\n\n\n\n\n\n\n\n\nGambar 10: Ilustrasi perubahan peluang empiris dari satu percobaan ke percobaan berikutnya\n\n\n\n\n\n\n\nAnimasi Estimasi Nilai \\(\\pi\\)\nGambar 10 menunjukkan bahwa semakin besar percobaannya, nilai peluang empirisnya semakin mendekati nilai peluang teoretisnya, yaitu \\(\\frac{2}{\\pi}\\). Jika \\(P_{\\text{empiris}}\\) menotasikan nilai peluang empiris tersebut, kita mendapatkan Persamaan 3.\n\\[\nP_{\\text{empiris}} \\approx \\frac{2}{\\pi}\n\\tag{3}\\]\nAtau dengan kata lain, kita juga dapat menyatakan Persamaan 3 menjadi Persamaan 4.\n\\[\n\\pi \\approx \\frac{2}{P_{\\text{empiris}}}\n\\tag{4}\\]\nNah, oleh karena itu kita dapat menggunakan nilai variabel dalam p_empiris dalam data_eksperimen untuk mendekati nilai \\(\\pi\\). Kita lakukan hal ini dengan kode pada Daftar 15.\n\n\n\n\nDaftar 15: Membuat estimasi nilai \\(\\pi\\) dalam data_eksperimen\n\n\n\nKode\ndata_eksperimen &lt;- data_eksperimen |&gt; \n  mutate(\n    estimasi_pi = 2 / peluang_empiris\n  )\n\n\n\n\n\nSekarang kita membuat animasi yang serupa dengan Gambar 10, tetapi yang akan kita plot adalah nilai-nilai variabel estimasi_pi. Kita melakukannya dengan kode pada Daftar 16.\n\n\n\n\nDaftar 16: Membuat animasi estimasi nilai \\(\\pi\\)\n\n\n\nKode\nplot_anim_mendekati_pi &lt;- data_eksperimen |&gt; \n  ggplot(aes(x = percobaan, y = estimasi_pi)) + \n  geom_hline(\n    yintercept = pi,\n    linetype = \"dashed\",\n    color = \"gray50\"\n  ) + \n  geom_line(\n    color = \"gray80\",\n    linewidth = 1\n  ) + \n  geom_point(\n    aes(color = warna, group = percobaan)\n  ) + \n  scale_color_identity() + \n  theme_minimal() + \n  labs(\n    x = \"Percobaan\",\n    y = \"Estimasi pi\"\n  ) + \n  transition_reveal(\n    along = percobaan\n  )\n\n\n\n\n\nGambar 11 mengilustrasikan bagaimana eksperimen jarum Buffon dapat digunakan untuk mengestimasi nilai \\(\\pi\\).\n\n\nKode\nplot_anim_mendekati_pi\n\n\n\n\n\n\n\n\nGambar 11: Eksperimen jarum Buffon untuk mendekati nilai \\(\\pi\\)\n\n\n\n\n\nBerdasarkan hasil eksperimen jarum Buffon yang terdata dalam data_eksperimen, kita dapat melihat estimasi nilai \\(\\pi\\)-nya pada percobaan yang terakhir, yaitu percobaan ke-1000. Berapa nilai estimasinya? Mari kita menggunakan Daftar 17 dan lihat luarannya.\n\n\n\n\nDaftar 17: Menampilkan nilai estimasi_pi pada percobaan yang ke-1000\n\n\n\nKode\nest_pi &lt;- data_eksperimen$estimasi_pi[1000]\nest_pi\n\n\n\n\n\n[1] 3.184713\n\n\nTernyata, kita mendapatkan nilai estimasinya sekitar 3,1847. Nilai estimasi ini tentu akan semakin dekat ke nilai \\(\\pi\\) yang sebenarnya jika banyaknya percobaannya semakin besar.\n\n\nAnimasi Hasil Setiap Percobaan\nHasil setiap percobaan dalam eksperimen jarum Buffon juga dapat kita animasikan. Hal ini serupa dengan Gambar 8. Dengan cara yang serupa dengan pembuatan animasi-animasi sebelumnya, kita dapat melakukannya dengan kode pada Daftar 18.\n\n\n\n\nDaftar 18: Membuat animasi hasil setiap percobaan\n\n\n\nKode\nplot_anim_hasil_percobaan &lt;- data_eksperimen |&gt; \n  ggplot(aes(x = theta_l, y = d_h)) +\n  geom_line(\n    data = data_kurva_sin,\n    aes(x = x, y = y),\n    color = \"#efb118\",\n    linewidth = 1,\n    inherit.aes = FALSE\n  ) + \n  geom_point(\n    aes(\n      color = potong,\n      group = percobaan\n    ),\n    size = 3\n  ) +\n  scale_color_manual(\n    values = c(\n      \"Memotong\" = \"#4269d0\",\n      \"Tak memotong\" = \"#ff725c\"\n    ),\n    name = \"Hasil percobaan\"\n  ) +\n  theme_minimal() + \n  theme(\n    legend.position = \"bottom\"\n  ) + \n  labs(\n    x = expression(theta[l]),\n    y = expression(d[h])\n  ) + \n  transition_reveal(\n    along = percobaan\n  )\n\n\n\n\n\nUntuk melihat hasilnya, kita dapat mencetak objek gganim plot_anim_hasil_percobaan yang dihasilkan pada Daftar 18. Hasil animasinya disajikan pada Gambar 12.\n\n\nKode\nplot_anim_hasil_percobaan\n\n\n\n\n\n\n\n\nGambar 12: Animasi hasil setiap percobaan dalam eksperimen jarum Buffon\n\n\n\n\n\n\n\nGabungan Animasi\nSeringkali gabungan animasi memberikan informasi yang lebih kaya daripada animasi tunggal. Misalnya, bagaimana menurutmu jika kita dapat mengatur agar animasi pada Gambar 9 dan Gambar 10 berdampingan? Selain kita dapat melihat eksperimen jarum Buffon, secara simultan kita juga dapat mengamati tren peluang empirisnya. Itulah yang akan kita lakukan. Untuk melakukannya, kita dapat menggunakan kode pada Daftar 19.\n\n\n\nDaftar 19: Menyandingkan animasi eksperimen jarum Buffon dan peluang empirisnya\n\n\n# Membuat animasi eksperimen jarum Buffon\ngif_anim_jarum &lt;- animate(\n  plot_anim_jarum,\n  width = 360,\n  height = 360,\n  nframes = 200,\n  fps = 10\n)\n\n# Membuat animasi tren peluang empiris\ngif_anim_p_empiris &lt;- animate(\n  plot_anim_p_empiris,\n  width = 360,\n  height = 360,\n  nframes = 200,\n  fps = 10\n)\n\n# Membaca animasi sebagai kumpulan frame gambar\nmgif_anim_jarum &lt;- image_read(gif_anim_jarum)\nmgif_anim_p_empiris &lt;- image_read(gif_anim_p_empiris)\n\n# Menggabungkan frame pertama dari kedua animasi secara berdampingan\ngif_buffon_p_empiris &lt;- image_append(\n  c(mgif_anim_jarum[1], mgif_anim_p_empiris[1])\n)\n\n# Menggabungkan semua frame berikutnya satu per satu\nfor(i in 2:200){\n  kombinasi &lt;- image_append(\n    c(mgif_anim_jarum[i], mgif_anim_p_empiris[i])\n  )\n  gif_buffon_p_empiris &lt;- c(\n    gif_buffon_p_empiris,\n    kombinasi\n  )\n}\n\n# Menyimpan hasil gabungan sebagai satu fail gif\nanim_save(\n  filename = \"gif_buffon_p_empiris.gif\",\n  animation = gif_buffon_p_empiris\n)\n\n\n\nKode pada Daftar 19 menghasilkan animasi yang berupa gambar gif. Animasi tersebut ditunjukkan pada Gambar 13.\n\n\n\n\n\n\nGambar 13: Ilustrasi eksperimen jarum Buffon dan peluang empirisnya\n\n\n\nDengan cara yang serupa, kita juga dapat menyandingkan animasi yang disajikan pada Gambar 9 dan Gambar 11. Animasi tersebut ditunjukkan pada Gambar 14.\n\n\n\n\n\n\nGambar 14: Ilustrasi eksperimen jarum Buffon untuk mendekati nilai pi\n\n\n\nKita juga dapat menyandingkan animasi yang disajikan pada Gambar 9 dan Gambar 12. Animasi tersebut ditunjukkan pada Gambar 15.\n\n\n\n\n\n\nGambar 15: Ilustrasi eksperimen jarum Buffon dan hasil setiap percobaannya"
  },
  {
    "objectID": "pos/2025-10-simulasi-monte-carlo/index.html#sec-catatan-akhir",
    "href": "pos/2025-10-simulasi-monte-carlo/index.html#sec-catatan-akhir",
    "title": "Simulasi Monte Carlo",
    "section": "Catatan Akhir",
    "text": "Catatan Akhir\nKita telah belajar banyak hal melalui masalah jarum Buffon. Pertama, kita telah mengetahui apa itu simulasi Monte Carlo pada Bagian 1. Simulasi itu kita gunakan untuk mengilustrasikan masalah jarum Buffon pada Bagian 2. Pada bagian itu kita memahami secara detail masalah jarum Buffon, khususnya pada Bagian 2.1. Pada Bagian 2.2 kita membuat “kanvas” untuk masalah tersebut, yaitu selembar kertas bergaris-garis. Pada Bagian 2.3 kita memvisualisasikan sebuah jarum. Selain itu, kita juga menemukan kondisi agar jarumnya memotong garis pada kertas. Pada Bagian 2.4 dan Bagian 2.5, kita melakukan eksperimen jarum Buffon dan memvisualisasikan hasilnya.\nTak hanya itu. Kita juga membuat visualisasi hasil eksperimen jarum Buffon menjadi lebih hidup dengan memanfaatkan animasi. Hal ini kita lakukan pada Bagian 3. Pada Bagian 3.5, kita menggabungkan animasi-animasi yang dihasilkan untuk menyampaikan pesan yang lebih efektif dan efisien. Misalnya, Gambar 13 menampilkan pesan yang kuat bahwa peluang empirisnya semakin mendekati ke nilai tertentu, yaitu \\(\\frac{2}{\\pi}\\), ketika percobaannya semakin banyak, sembari kita memantau apa yang terjadi dengan eksperimennya.\nArtikel ini memiliki keterbatasan. Pertama adalah penggunaan asumsi bahwa panjang jarumnya adalah \\(l = 1\\) dan jarak antargaris pada kertasnya adalah \\(d = 1\\). Kamu dapat mengeksplorasi lebih lanjut bagaimana jika panjang jarumnya lebih panjang daripada jarak antargarisnya, ataupun sebaliknya. Selain itu, pembuatan jarum dalam artikel ini menggunakan koordinat satu titik ujung dan besar sudut kemiringannya, untuk menentukan koordinat titik ujung lainnya. Kamu dapat menggunakan cara lain. Misalnya, diketahui koordinat titik tengah jarum dan besar sudutnya, lalu gunakan informasi tersebut untuk menentukan kedua titik ujung jarumnya. Selamat mencoba!"
  }
]